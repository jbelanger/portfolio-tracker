using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Portfolio.App")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+31d574c1b9cd27a85344f9045851c89bede21d94")]
[assembly: System.Reflection.AssemblyProductAttribute("Portfolio.App")]
[assembly: System.Reflection.AssemblyTitleAttribute("Portfolio.App")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
using Portfolio.Domain.Events;

namespace Portfolio.App.DomainEventHandlers
{
    public class FinancialEventAddedDomainEventHandler : INotificationHandler<FinancialEventAdded>
    {
        public Task Handle(FinancialEventAdded notification, CancellationToken cancellationToken)
        {
            var holding = notification.Holding;
            var transaction = notification.Transaction;

            if(string.IsNullOrWhiteSpace(notification.ErrorMessage))
            {
                Log.Information("Financial event created.");
            }
            else
            {
                Log.Error("Financial event could not be created: {ErrorMessage}", notification.ErrorMessage);
            }

            return Task.CompletedTask;
        }
    }
}using Portfolio.Domain.Events;
using Portfolio.Domain.Interfaces;

namespace Portfolio.App.DomainEventHandlers
{
    public class TradesRecalculationNeededEventDomainEventHandler : INotificationHandler<TradesRecalculationNeededEvent>
    {
        private readonly IPriceHistoryService _priceHistoryService;

        public TradesRecalculationNeededEventDomainEventHandler(IPriceHistoryService priceHistoryService)
        {
            _priceHistoryService = priceHistoryService;
        }

        public async Task Handle(TradesRecalculationNeededEvent notification, CancellationToken cancellationToken)
        {
            Log.Information("Trade calculations started for portfolio {Id}.", notification.Portfolio.Id);
            await notification.Portfolio.CalculateTradesAsync(_priceHistoryService);            
            Log.Information("Trade calculations completed for portfolio {Id}.", notification.Portfolio.Id);
        }
    }
}using System.Reflection;
using Microsoft.Extensions.DependencyInjection;
using Portfolio.App.Common.Behaviours;

namespace Portfolio.App
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddApplicationServices(this IServiceCollection services)
        {
            services.AddAutoMapper(Assembly.GetExecutingAssembly());

            services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());

            services.AddMediatR(cfg =>
            {
                cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
                cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(UnhandledExceptionBehaviour<,>));
                cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(AuthorizationBehaviour<,>));
                cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(ValidationBehaviour<,>));
                cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(PerformanceBehaviour<,>));
            });

            return services;
        }
    }
}using System.Collections.Concurrent;

namespace Portfolio.App
{
    public static class ConcurrentDictionaryExtensions
    {
        public static async Task<TValue> GetOrAddAsync<TKey, TValue>(
            this ConcurrentDictionary<TKey, Lazy<Task<TValue>>> dictionary,
            TKey key,
            Func<TKey, Task<TValue>> valueFactory) where TKey : notnull
        {
            var lazyValue = dictionary.GetOrAdd(key, k => new Lazy<Task<TValue>>(() => valueFactory(k)));

            try
            {
                return await lazyValue.Value.ConfigureAwait(false);
            }
            catch
            {
                dictionary.TryRemove(key, out _);
                throw;
            }
        }

        public static async Task<bool> TryAddAsync<TKey, TValue>(
            this ConcurrentDictionary<TKey, Lazy<Task<TValue>>> dictionary,
            TKey key,
            Func<TKey, Task<TValue>> valueFactory) where TKey : notnull
        {
            var lazyValue = new Lazy<Task<TValue>>(() => valueFactory(key));

            if (dictionary.TryAdd(key, lazyValue))
            {
                try
                {
                    await lazyValue.Value.ConfigureAwait(false);
                    return true;
                }
                catch
                {
                    dictionary.TryRemove(key, out _);
                    throw;
                }
            }

            return false; // The key already exists, so we don't add a new value.
        }

        public static async Task<TValue> AddOrUpdateAsync<TKey, TValue>(
            this ConcurrentDictionary<TKey, Lazy<Task<TValue>>> dictionary,
            TKey key,
            Func<TKey, Task<TValue>> addValueFactory,
            Func<TKey, TValue, Task<TValue>> updateValueFactory) where TKey : notnull
        {
            var lazyValue = new Lazy<Task<TValue>>(() => addValueFactory(key));

            var result = dictionary.AddOrUpdate(
                key,
                lazyValue,
                (k, existingLazyValue) => new Lazy<Task<TValue>>(async () =>
                {
                    var existingValue = await existingLazyValue.Value.ConfigureAwait(false);
                    return await updateValueFactory(k, existingValue).ConfigureAwait(false);
                }));

            try
            {
                return await result.Value.ConfigureAwait(false);
            }
            catch
            {
                dictionary.TryRemove(key, out _);
                throw;
            }
        }
    }
}
namespace Portfolio.App;

public enum CsvFileImportType
{
    Standard,
    Kraken
}using Portfolio.Domain.Entities;

namespace Portfolio.App.DTOs
{
    public class AssetHoldingDto
    {
        public long Id { get; set; }
        public string Asset { get; set; } = string.Empty;
        public decimal Balance { get; set; }
        public decimal AverageBoughtPrice { get; set; }
        public decimal CurrentPrice { get; set; }
        public string ErrorMessage { get; set; } = string.Empty;
        
        public static AssetHoldingDto From(AssetHolding holding)
        {
            return new AssetHoldingDto
            {
                Id = holding.Id,
                Asset = holding.Asset,
                Balance = holding.Balance,
                AverageBoughtPrice = holding.AverageBoughtPrice,
                CurrentPrice = holding.CurrentPrice.Amount,
                ErrorMessage = holding.ErrorMessage
            };
        }
    }
}
using Portfolio.Domain.Entities;

namespace Portfolio.App.DTOs
{
    public class WalletDto
    {
        public long Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public List<FinancialTransactionDto> Transactions { get; set; } = new();

        public static WalletDto From(Wallet wallet)
        {
            return new WalletDto
            {
                Id = wallet.Id,
                Name = wallet.Name,
                Transactions = wallet.Transactions.Select(FinancialTransactionDto.From).ToList()
            };
        }
    }
}
using Portfolio.Domain.Entities;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.App.DTOs
{
    public class FinancialTransactionDto
    {
        public long Id { get; set; }
        public DateTime DateTime { get; set; }
        public string Type { get; set; } = string.Empty;
        public decimal? ReceivedAmount { get; set; }
        public string ReceivedCurrency { get; set; } = string.Empty;
        public decimal? SentAmount { get; set; }
        public string SentCurrency { get; set; } = string.Empty;
        public decimal? FeeAmount { get; set; }
        public string FeeCurrency { get; set; } = string.Empty;
        public string Account { get; set; } = string.Empty;
        public string Note { get; set; } = string.Empty;
        public string ErrorMessage { get; private set; } = string.Empty;
        public decimal ValueInDefaultCurrency { get; private set; }
        public decimal FeeValueInDefaultCurrency { get; private set; }

        public static FinancialTransactionDto From(FinancialTransaction transaction)
        {
            if (transaction is null) throw new ArgumentNullException(nameof(transaction));

            return new FinancialTransactionDto
            {
                Id = transaction.Id,
                DateTime = transaction.DateTime,
                Type = transaction.Type.ToString(),
                ReceivedAmount = (transaction.ReceivedAmount == Money.Empty) ? null : transaction.ReceivedAmount.Amount,
                ReceivedCurrency = transaction.ReceivedAmount?.CurrencyCode ?? string.Empty,
                SentAmount = (transaction.SentAmount == Money.Empty) ? null : transaction.SentAmount.Amount,
                SentCurrency = transaction.SentAmount?.CurrencyCode ?? string.Empty,
                FeeAmount = (transaction.FeeAmount == Money.Empty) ? null : transaction.FeeAmount.Amount,
                FeeCurrency = transaction.FeeAmount?.CurrencyCode ?? string.Empty,
                Account = transaction.Account,
                Note = transaction.Note,
                ErrorMessage = transaction.ErrorMessage,
                ValueInDefaultCurrency = transaction.ValueInDefaultCurrency.Amount,
                FeeValueInDefaultCurrency = transaction.FeeValueInDefaultCurrency.Amount,
            };
        }
    }
}
using Portfolio.Domain.Entities;

namespace Portfolio.App.DTOs
{
    public class PortfolioDto
    {
        public long Id { get; set; }
        public string DefaultCurrency { get; set; } = "USD";
        public List<WalletDto> Wallets { get; set; } = new();
        public List<AssetHoldingDto> Holdings { get; set; } = new();

        public static PortfolioDto From(UserPortfolio portfolio)
        {
            return new PortfolioDto
            {
                Id = portfolio.Id,
                DefaultCurrency = portfolio.DefaultCurrency,
                Wallets = portfolio.Wallets.Select(WalletDto.From).ToList(),
                Holdings = portfolio.Holdings.Select(AssetHoldingDto.From).ToList()
            };
        }
    }
}
﻿namespace Portfolio.App.Common.Security;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
public class AuthorizeAttribute : Attribute
{
    public AuthorizeAttribute() { }

    public string Roles { get; set; } = string.Empty;

    public string Policy { get; set; } = string.Empty;
}
﻿using System.Reflection;
using Portfolio.App.Common.Exceptions;
using Portfolio.App.Common.Interfaces;
using Portfolio.App.Common.Security;
using Portfolio.Domain.Interfaces;

namespace Portfolio.App.Common.Behaviours;

public class AuthorizationBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> where TRequest : notnull
{
    private readonly IUser _user;
    private readonly IIdentityService _identityService;

    public AuthorizationBehaviour(
        IUser user,
        IIdentityService identityService)
    {
        _user = user;
        _identityService = identityService;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        var authorizeAttributes = request.GetType().GetCustomAttributes<AuthorizeAttribute>();

        if (authorizeAttributes.Any())
        {
            if (_user.Id == null)
            {
                throw new UnauthorizedAccessException();
            }

            var authorizeAttributesWithRoles = authorizeAttributes.Where(a => !string.IsNullOrWhiteSpace(a.Roles));

            if (authorizeAttributesWithRoles.Any())
            {
                var authorized = false;

                foreach (var roles in authorizeAttributesWithRoles.Select(a => a.Roles.Split(',')))
                {
                    foreach (var role in roles)
                    {
                        var isInRole = await _identityService.IsInRoleAsync(_user.Id, role.Trim());
                        if (isInRole)
                        {
                            authorized = true;
                            break;
                        }
                    }
                }

                if (!authorized)
                {
                    throw new ForbiddenAccessException();
                }
            }

            var authorizeAttributesWithPolicies = authorizeAttributes.Where(a => !string.IsNullOrWhiteSpace(a.Policy));
            if (authorizeAttributesWithPolicies.Any())
            {
                foreach (var policy in authorizeAttributesWithPolicies.Select(a => a.Policy))
                {
                    var authorized = await _identityService.AuthorizeAsync(_user.Id, policy);

                    if (!authorized)
                    {
                        throw new ForbiddenAccessException();
                    }
                }
            }
        }

        return await next();
    }
}
﻿using ValidationException = Portfolio.App.Common.Exceptions.ValidationException;

namespace Portfolio.App.Common.Behaviours;

public class ValidationBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
     where TRequest : notnull
{
    private readonly IEnumerable<IValidator<TRequest>> _validators;

    public ValidationBehaviour(IEnumerable<IValidator<TRequest>> validators)
    {
        _validators = validators;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        if (_validators.Any())
        {
            var context = new ValidationContext<TRequest>(request);

            var validationResults = await Task.WhenAll(
                _validators.Select(v =>
                    v.ValidateAsync(context, cancellationToken)));

            var failures = validationResults
                .Where(r => r.Errors.Any())
                .SelectMany(r => r.Errors)
                .ToList();

            if (failures.Any())
                throw new ValidationException(failures);
        }
        return await next();
    }
}
﻿using System.Diagnostics;
using Microsoft.Extensions.Logging;
using Portfolio.App.Common.Interfaces;
using Portfolio.Domain.Interfaces;

namespace Portfolio.App.Common.Behaviours;

public class PerformanceBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> where TRequest : notnull
{
    private readonly Stopwatch _timer;
    private readonly ILogger<TRequest> _logger;
    private readonly IUser _user;
    private readonly IIdentityService _identityService;

    public PerformanceBehaviour(
        ILogger<TRequest> logger,
        IUser user,
        IIdentityService identityService)
    {
        _timer = new Stopwatch();

        _logger = logger;
        _user = user;
        _identityService = identityService;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        _timer.Start();

        var response = await next();

        _timer.Stop();

        var elapsedMilliseconds = _timer.ElapsedMilliseconds;

        if (elapsedMilliseconds > 500)
        {
            var requestName = typeof(TRequest).Name;
            var userId = _user.Id ?? string.Empty;
            var userName = string.Empty;

            if (!string.IsNullOrEmpty(userId))
            {
                userName = await _identityService.GetUserNameAsync(userId);
            }

            _logger.LogWarning("Wics Long Running Request: {Name} ({ElapsedMilliseconds} milliseconds) {@UserId} {@UserName} {@Request}",
                requestName, elapsedMilliseconds, userId, userName, request);
        }

        return response;
    }
}
﻿using Microsoft.Extensions.Logging;

namespace Portfolio.App.Common.Behaviours;

public class UnhandledExceptionBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> where TRequest : notnull
{
    private readonly ILogger<TRequest> _logger;

    public UnhandledExceptionBehaviour(ILogger<TRequest> logger)
    {
        _logger = logger;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        try
        {
            return await next();
        }
        catch (Exception ex)
        {
            var requestName = typeof(TRequest).Name;

            Log.Error(ex, "Wics Request: Unhandled Exception for Request {Name} {@Request}", requestName, request);

            throw;
        }
    }
}
﻿using MediatR.Pipeline;
using Microsoft.Extensions.Logging;
using Portfolio.App.Common.Interfaces;
using Portfolio.Domain.Interfaces;

namespace Portfolio.App.Common.Behaviours;

public class LoggingBehaviour<TRequest> : IRequestPreProcessor<TRequest> where TRequest : notnull
{
    private readonly Microsoft.Extensions.Logging.ILogger _logger;
    private readonly IUser _user;
    private readonly IIdentityService _identityService;

    public LoggingBehaviour(ILogger<TRequest> logger, IUser user, IIdentityService identityService)
    {
        _logger = logger;
        _user = user;
        _identityService = identityService;
    }

    public async Task Process(TRequest request, CancellationToken cancellationToken)
    {
        var requestName = typeof(TRequest).Name;
        var userId = _user.Id ?? string.Empty;
        string? userName = string.Empty;

        if (!string.IsNullOrEmpty(userId))
        {
            userName = await _identityService.GetUserNameAsync(userId);
        }

        _logger.LogInformation("Wics Request: {Name} {@UserId} {@UserName} {@Request}",
            requestName, userId, userName, request);
    }
}
﻿namespace Portfolio.App.Common.Models;

public class LookupDto
{
    public int Id { get; init; }

    public string? Title { get; init; }

    private class Mapping : Profile
    {
        public Mapping()
        {
        }
    }
}
﻿namespace Portfolio.App.Common.Models;

public class PaginatedList<T>
{
    public IReadOnlyCollection<T> Items { get; }
    public int PageNumber { get; }
    public int TotalPages { get; }
    public int TotalCount { get; }

    public PaginatedList(IReadOnlyCollection<T> items, int count, int pageNumber, int pageSize)
    {
        PageNumber = pageNumber;
        TotalPages = (int)Math.Ceiling(count / (double)pageSize);
        TotalCount = count;
        Items = items;
    }

    public bool HasPreviousPage => PageNumber > 1;

    public bool HasNextPage => PageNumber < TotalPages;

    public static async Task<PaginatedList<T>> CreateAsync(IQueryable<T> source, int pageNumber, int pageSize)
    {
        var count = await source.CountAsync();
        var items = await source.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToListAsync();

        return new PaginatedList<T>(items, count, pageNumber, pageSize);
    }
}
﻿namespace Portfolio.App.Common.Exceptions;

public class ForbiddenAccessException : Exception
{
    public ForbiddenAccessException() : base() { }
}
﻿using FluentValidation.Results;

namespace Portfolio.App.Common.Exceptions;

public class ValidationException : Exception
{
    public ValidationException()
        : base("One or more validation failures have occurred.")
    {
        Errors = new Dictionary<string, string[]>();
    }

    public ValidationException(IEnumerable<ValidationFailure> failures)
        : this()
    {
        Errors = failures
            .GroupBy(e => e.PropertyName, e => e.ErrorMessage)
            .ToDictionary(failureGroup => failureGroup.Key, failureGroup => failureGroup.ToArray());
    }

    public IDictionary<string, string[]> Errors { get; }
}
﻿using Portfolio.App.Common.Models;

namespace Portfolio.App.Common.Mappings;

public static class MappingExtensions
{
    public static Task<PaginatedList<TDestination>> PaginatedListAsync<TDestination>(this IQueryable<TDestination> queryable, int pageNumber, int pageSize) where TDestination : class
        => PaginatedList<TDestination>.CreateAsync(queryable.AsNoTracking(), pageNumber, pageSize);

}
﻿namespace Portfolio.App.Common.Interfaces;

public interface IIdentityService
{
    Task<string?> GetUserNameAsync(string userId);

    Task<bool> IsInRoleAsync(string userId, string role);

    Task<bool> AuthorizeAsync(string userId, string policyName);

    Task<(Result Result, string UserId)> CreateUserAsync(string userName, string password);

    Task<Result> DeleteUserAsync(string userId);
}
global using AutoMapper;
global using Microsoft.EntityFrameworkCore;
global using FluentValidation;
global using MediatR;
global using CSharpFunctionalExtensions;
global using Serilog;using Portfolio.App;
using Portfolio.App.DTOs;

namespace Portfolio.Api.Services
{
    public interface ICryptoTransactionService
    {
        Task<Result<long>> AddTransactionAsync(long portfolioId, long walletId, FinancialTransactionDto transactionDto);
        Task<Result> UpdateTransactionAsync(long portfolioId, long walletId, long transactionId, FinancialTransactionDto transactionDto);
        Task<Result> DeleteTransactionAsync(long portfolioId, long walletId, long transactionId);
        Task<Result<FinancialTransactionDto>> GetTransactionAsync(long portfolioId, long walletId, long transactionId);
        Task<Result<IEnumerable<FinancialTransactionDto>>> GetTransactionsAsync(long portfolioId, long walletId);
        Task<Result> ImportTransactionsFromCsvAsync(long portfolioId, long walletId, CsvFileImportType csvType, StreamReader streamReader);
        Task<Result> BulkUpdateTransactionsAsync(long portfolioId, long walletId, List<FinancialTransactionDto> transactionsToUpdate);
        Task<Result> BulkDeleteTransactionsAsync(long portfolioId, long walletId, long[] transactionIds);
    }
}
using Portfolio.App;
using Portfolio.App.DTOs;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Enums;
using Portfolio.Domain.ValueObjects;
using Portfolio.Infrastructure;
using Portfolio.Transactions.Importers.Csv.Kraken;

namespace Portfolio.Api.Services
{
    public partial class CryptoTransactionService : ICryptoTransactionService
    {
        private readonly PortfolioDbContext _dbContext;

        public CryptoTransactionService(PortfolioDbContext dbContext)
        {
            _dbContext = dbContext;
        }

        public async Task<Result<long>> AddTransactionAsync(long portfolioId, long walletId, FinancialTransactionDto transactionDto)
        {
            var wallet = await _dbContext.Wallets                
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
                return Result.Failure<long>($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");

            if (!Enum.TryParse(transactionDto.Type, true, out TransactionType transactionType))
                return Result.Failure<long>($"Invalid transaction type {transactionDto.Type}");

            Result<FinancialTransaction> addTransactionResult = new Result<FinancialTransaction>();
            switch (transactionType)
            {
                case TransactionType.Deposit:
                    addTransactionResult = FinancialTransaction.CreateDeposit(
                        transactionDto.DateTime,
                        new Money(transactionDto.ReceivedAmount ?? 0m, transactionDto.ReceivedCurrency),
                        transactionDto.FeeAmount.HasValue ? new Money(transactionDto.FeeAmount ?? 0m, transactionDto.FeeCurrency) : null,
                        transactionDto.Account,
                        [],
                        transactionDto.Note
                    );
                    break;
                case TransactionType.Withdrawal:
                    addTransactionResult = FinancialTransaction.CreateWithdraw(
                        transactionDto.DateTime,
                        new Money(transactionDto.SentAmount.GetValueOrDefault(), transactionDto.SentCurrency),
                        transactionDto.FeeAmount.HasValue ? new Money(transactionDto.FeeAmount.Value, transactionDto.FeeCurrency) : null,
                        transactionDto.Account,
                        [],
                        transactionDto.Note
                    );
                    break;
                case TransactionType.Trade:
                    addTransactionResult = FinancialTransaction.CreateTrade(
                        transactionDto.DateTime,
                        new Money(transactionDto.ReceivedAmount.GetValueOrDefault(), transactionDto.ReceivedCurrency),
                        new Money(transactionDto.SentAmount.GetValueOrDefault(), transactionDto.SentCurrency),
                        transactionDto.FeeAmount.HasValue ? new Money(transactionDto.FeeAmount.Value, "USD") : null,
                        transactionDto.Account,
                        [],
                        transactionDto.Note
                    );
                    break;
            }

            return await addTransactionResult
                .Check(t => EnsureTransactionNotAlreadyExistsAsync(walletId, t))
                .Check(wallet.AddTransaction)
                .Tap(async t => await _dbContext.SaveChangesAsync())
                .Map(t => t.Id);
        }

        public async Task<Result> UpdateTransactionAsync(long portfolioId, long walletId, long transactionId, FinancialTransactionDto transactionDto)
        {
            var isUserWallet = await _dbContext.Wallets
                .AsNoTracking()
                .AnyAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (!isUserWallet)
                return Result.Failure<FinancialTransactionDto>($"Transaction with ID {transactionId} not found in Wallet {walletId}.");

            var transaction = _dbContext.Transactions.AsNoTracking().FirstOrDefault(t => t.Id == transactionId);
            if (transaction == null)
                return Result.Failure($"Transaction with ID {transactionId} not found in Wallet {walletId}.");

            var receivedAmount = Money.Create(transactionDto.ReceivedAmount, transactionDto.ReceivedCurrency);
            var sentAmount = Money.Create(transactionDto.SentAmount, transactionDto.SentCurrency);
            var feeAmount = Money.Create(transactionDto.FeeAmount, transactionDto.FeeCurrency);

            return await transaction.SetTransactionAmounts(receivedAmount.GetValueOrDefault(), sentAmount.GetValueOrDefault(), feeAmount.GetValueOrDefault())
                .Bind(() => transaction.SetNote(transactionDto.Note))
                .Bind(() => transaction.SetTransactionDate(transactionDto.DateTime))
                .Tap(async () => await _dbContext.SaveChangesAsync());
        }

        public async Task<Result> BulkUpdateTransactionsAsync(long portfolioId, long walletId, List<FinancialTransactionDto> transactionsToUpdate)
        {
            var wallet = await _dbContext.Wallets
                .Include(w => w.Transactions)
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
                return Result.Failure<IEnumerable<FinancialTransactionDto>>($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");


            var transactionIds = transactionsToUpdate.Select(t => t.Id).ToArray();
            var transactions = await _dbContext.Transactions
                                             .Where(t => transactionIds.Contains(t.Id))
                                             .ToListAsync();

            if (transactions.Count != transactionIds.Length)
                return Result.Failure("Some transactions could not be found.");

            foreach (var transaction in transactions)
            {
                var updatedTransaction = transactionsToUpdate.First(t => t.Id == transaction.Id);
                var receivedAmount = Money.Create(updatedTransaction.ReceivedAmount, updatedTransaction.ReceivedCurrency);
                var sentAmount = Money.Create(updatedTransaction.SentAmount, updatedTransaction.SentCurrency);
                var feeAmount = Money.Create(updatedTransaction.FeeAmount, updatedTransaction.FeeCurrency);

                var result = transaction.SetTransactionAmounts(receivedAmount.GetValueOrDefault(), sentAmount.GetValueOrDefault(), feeAmount.GetValueOrDefault())
                    .Bind(() => transaction.SetNote(updatedTransaction.Note))
                    .Bind(() => transaction.SetTransactionDate(updatedTransaction.DateTime));
            }

            await _dbContext.SaveChangesAsync();

            return Result.Success();
        }

        public async Task<Result> DeleteTransactionAsync(long portfolioId, long walletId, long transactionId)
        {
            var isUserWallet = await _dbContext.Wallets                
                .AnyAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (!isUserWallet)
                return Result.Failure<FinancialTransactionDto>($"Transaction with ID {transactionId} not found in Wallet {walletId}.");

            var transaction = _dbContext.Transactions.AsNoTracking().FirstOrDefault(t => t.Id == transactionId);
            if (transaction == null)
            {
                return Result.Failure($"Transaction with ID {transactionId} not found in Wallet {walletId}.");
            }

            _dbContext.Transactions.Remove(transaction);

            await _dbContext.SaveChangesAsync();

            return Result.Success();
        }

        public async Task<Result> BulkDeleteTransactionsAsync(long portfolioId, long walletId, long[] transactionIds)
        {
            var wallet = await _dbContext.Wallets            
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
                return Result.Failure<IEnumerable<FinancialTransactionDto>>($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");

            var transactions = await _dbContext.Transactions
                                             .Where(t => transactionIds.Contains(t.Id))
                                             .ToListAsync();

            if (transactions.Count != transactionIds.Length)
                return Result.Failure("Some transactions could not be found.");
                        
            _dbContext.Transactions.RemoveRange(transactions);
            await _dbContext.SaveChangesAsync();

            return Result.Success();
        }


        public async Task<Result<IEnumerable<FinancialTransactionDto>>> GetTransactionsAsync(long portfolioId, long walletId)
        {
            var wallet = await _dbContext.Wallets
                .Include(w => w.Transactions)
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
                return Result.Failure<IEnumerable<FinancialTransactionDto>>($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");

            var transactionsDto = wallet.Transactions.Select(t => FinancialTransactionDto.From(t));

            return Result.Success(transactionsDto);
        }

        public async Task<Result<FinancialTransactionDto>> GetTransactionAsync(long portfolioId, long walletId, long transactionId)
        {
            var isUserWallet = await _dbContext
                .Wallets
                .AsNoTracking()
                .AnyAsync(w => w.Id == walletId && w.PortfolioId == portfolioId && w.Transactions.Any(t => t.Id == transactionId));

            if (!isUserWallet)
                return Result.Failure<FinancialTransactionDto>($"Transaction with ID {transactionId} not found in Wallet {walletId}.");

            var transaction = await _dbContext.Transactions.AsNoTracking().FirstAsync(t => t.Id == transactionId);

            return Result.Success(FinancialTransactionDto.From(transaction));
        }

        public async Task<Result> ImportTransactionsFromCsvAsync(long portfolioId, long walletId, CsvFileImportType csvType, StreamReader streamReader)
        {
            var wallet = await _dbContext
                .Wallets                
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
                return Result.Failure($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");

            IEnumerable<FinancialTransaction>? transactions = null;

            try
            {
                switch (csvType)
                {
                    case CsvFileImportType.Standard:
                        break;
                    case CsvFileImportType.Kraken:
                        var parserResult = KrakenCsvParser.Create(streamReader);
                        if (parserResult.IsFailure)
                            return Result.Failure(parserResult.Error);

                        transactions = parserResult.Value.ExtractTransactions();
                        break;
                }
            }
            catch (Exception ex)
            {
                return Result.Failure($"Failed to import transactions from CSV: {ex.Message}");
            }

            if (transactions?.Any() == true)
            {
                foreach (var transaction in transactions)
                {
                    var addTransactionResult = await EnsureTransactionNotAlreadyExistsAsync(walletId, transaction)
                        .Bind(() => wallet.AddTransaction(transaction));

                    if (addTransactionResult.IsFailure)
                        return Result.Failure(addTransactionResult.Error);
                }
            }
            else
                return Result.Failure("No transactions to import from CSV.");

            await _dbContext.SaveChangesAsync();

            return Result.Success();
        }

        private async Task<Result> EnsureTransactionNotAlreadyExistsAsync(long walletId, FinancialTransaction n)
        {
            decimal received = n.ReceivedAmount.Amount;// ?? null;
            decimal sent = n.SentAmount.Amount;// ?? null;
            decimal fee = n.FeeAmount.Amount;// ?? null;
            string receivedCurrency = n.ReceivedAmount.CurrencyCode;// ?? null;
            string sentCurrency = n.SentAmount.CurrencyCode;// ?? null;
            string feeCurrency = n.FeeAmount.CurrencyCode;// ?? null;

            var exists = await _dbContext.Transactions.AsNoTracking().AnyAsync(other =>
                walletId == other.WalletId &&
                n.DateTime == other.DateTime &&
                n.Type == other.Type &&
                received == other.ReceivedAmount.Amount &&
                sent == other.SentAmount.Amount &&
                fee == other.FeeAmount.Amount &&
                receivedCurrency == other.ReceivedAmount.CurrencyCode &&
                sentCurrency == other.SentAmount.CurrencyCode &&
                feeCurrency == other.FeeAmount.CurrencyCode
                );
            if (exists)
                return Result.Failure<long>("Transaction already exists in this wallet.");
            return Result.Success();
        }
    }
}
using Portfolio.App.DTOs;
using Portfolio.Domain.Entities;
using Portfolio.Infrastructure;

namespace Portfolio.App.Services
{
    public class WalletService : IWalletService
    {
        private readonly PortfolioDbContext _dbContext;

        public WalletService(PortfolioDbContext dbContext)
        {
            _dbContext = dbContext;
        }

        public async Task<Result<long>> CreateWalletAsync(long portfolioId, WalletDto walletDto)
        {
            UserPortfolio? portfolio = await _dbContext.Portfolios
                .Include(p => p.Wallets)
                .FirstOrDefaultAsync(p => p.Id == portfolioId)
                .ConfigureAwait(false);

            if (portfolio == null)
            {
                return Result.Failure<long>($"Portfolio with ID {portfolioId} not found.");
            }

            return await Wallet.Create(walletDto.Name)
                .Check(w => portfolio.AddWallet(w))
                .Tap(async () => await _dbContext.SaveChangesAsync().ConfigureAwait(false))
                .Map(w => w.Id);
        }

        public async Task<Result> DeleteWalletAsync(long portfolioId, long walletId)
        {
            Wallet? wallet = await _dbContext.Wallets
                .Include(w => w.Transactions)
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
            {
                return Result.Failure($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");
            }

            _dbContext.Wallets.Remove(wallet);
            await _dbContext.SaveChangesAsync();

            return Result.Success();
        }

        public async Task<Result<WalletDto>> GetWalletAsync(long portfolioId, long walletId)
        {
            var wallet = await _dbContext.Wallets
                .Include(w => w.Transactions)
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
            {
                return Result.Failure<WalletDto>($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");
            }

            var walletDto = WalletDto.From(wallet);
            
            return Result.Success(walletDto);
        }

        public async Task<Result<IEnumerable<WalletDto>>> GetWalletsAsync(long portfolioId)
        {
            var wallets = await _dbContext.Wallets
                .Where(w => w.PortfolioId == portfolioId)
                .Include(w => w.Transactions)
                .ToListAsync();

            var walletDtos = wallets.Select(w => WalletDto.From(w)).ToList();

            return Result.Success<IEnumerable<WalletDto>>(walletDtos);
        }
    }
}
using Portfolio.App.DTOs;

namespace Portfolio.App.Services
{
    public interface IWalletService
    {
        Task<Result<long>> CreateWalletAsync(long portfolioId, WalletDto walletDto);
        Task<Result> DeleteWalletAsync(long portfolioId, long walletId);
        Task<Result<WalletDto>> GetWalletAsync(long portfolioId, long walletId);
        Task<Result<IEnumerable<WalletDto>>> GetWalletsAsync(long portfolioId);
    }
}
