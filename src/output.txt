using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Portfolio.Transactions.Exporters")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+b939afd4dad8882c516038f6d4d9b6d835809e0d")]
[assembly: System.Reflection.AssemblyProductAttribute("Portfolio.Transactions.Exporters")]
[assembly: System.Reflection.AssemblyTitleAttribute("Portfolio.Transactions.Exporters")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
﻿using Portfolio.Domain.Entities;

namespace Portfolio.Transactions.Exporters
{
    public class CryptoTaxCalculatorCsvExporter
    {
        private readonly IEnumerable<CryptoCurrencyTransaction> _transactions;

        public CryptoTaxCalculatorCsvExporter(IEnumerable<CryptoCurrencyTransaction> transactions)
        {
            _transactions = transactions ?? throw new ArgumentNullException(nameof(transactions));
        }

        public IEnumerable<string> GetCsvLines(bool withHeader = true)
        {
            var csvLines = new List<string>();
            if (withHeader)
            {
                csvLines.Add("Timestamp (UTC),Type,Base Currency,Base Amount,Quote Currency (Optional),Quote Amount (Optional),Fee Currency (Optional),Fee Amount (Optional),From (Optional),To (Optional),Blockchain (Optional),ID (Optional),Description (Optional),Reference Price Per Unit (Optional),Reference Price Currency (Optional)");
            }
            csvLines.AddRange(_transactions.Select(t => ToCsvLine(t)));
            return csvLines;
        }

        public void WriteToFile(string filepath)
        {
            File.WriteAllLines(filepath, GetCsvLines());
        }

        private string ToCsvLine(CryptoCurrencyTransaction tx)
        {
            return "";




        }
    }
}
﻿using Portfolio.Domain.Entities;

namespace Portfolio.Transactions.Exporters
{
    public class CoinTrackerCsvExporter
    {
        private readonly IEnumerable<CryptoCurrencyTransaction> _transactions;
    
        public CoinTrackerCsvExporter(IEnumerable<CryptoCurrencyTransaction> transactions)
        {
            _transactions = transactions ?? throw new ArgumentNullException(nameof(transactions));
        }

        public IEnumerable<string> GetCsvLines(bool withHeader = true)
        {
            var csvLines = new List<string>();
            if (withHeader)
            {
                csvLines.Add("Date,Received Quantity,Received Currency,Sent Quantity,Sent Currency,Fee Amount,Fee Currency,Tag");
            }
            csvLines.AddRange(_transactions.Select(t => ToCsvLine(t)));
            return csvLines;
        }

        public void WriteToFile(string filepath)
        {
            File.WriteAllLines(filepath, GetCsvLines());
        }

        private string ToCsvLine(CryptoCurrencyTransaction tx)
        {
            return "";// $"{tx.DateTime:MM/dd/yyyy HH:mm:ss UTC},{tx.ReceivedAmount?.AbsoluteAmount},{tx.ReceivedAmount?.CurrencyCode},{tx.SentAmount?.AbsoluteAmount},{tx.SentAmount?.CurrencyCode},{tx.FeeAmount?.AbsoluteAmount},{tx.FeeAmount?.CurrencyCode},";
        }
    }
}
﻿using Portfolio.Domain.Entities;

namespace Portfolio.Transactions.Exporters
{
    public class CoinTrackingCsvExporter
    {
        public static Dictionary<string, string> CoinTrackingSecificAssetNamesDict { get; } = new Dictionary<string, string>
        {
            {"UNI", "UNI2"},
            {"SOL", "SOL2"},
            {"DOT", "DOT2"},
            {"STX", "STX2"},
            {"ATOM", "ATOM2"},
            {"IMX", "IMX2"},
            {"ARB", "ARB5"},
            {"STRK", "STRK2"},
            {"TIA", "TIA3"},
            {"TAO", "TAO6"}
        };

        private readonly IEnumerable<CryptoCurrencyTransaction> _transactions;

        public CoinTrackingCsvExporter(IEnumerable<CryptoCurrencyTransaction> transactions)
        {
            _transactions = transactions ?? throw new ArgumentNullException(nameof(transactions));
        }

        public IEnumerable<string> GetCsvLines(bool withHeader = true)
        {
            var csvLines = new List<string>();
            if (withHeader)
            {
                csvLines.Add("Type,Buy Amount,Buy Currency,Sell Amount,Sell Currency,Fee,Fee Currency,Exchange,Trade-Group,Comment,Date");
            }
            foreach (var tx in _transactions)
            {
                csvLines.Add(ToCsvLine(tx));
            }
            return csvLines;
        }

        public void WriteToFile(string filepath)
        {
            File.WriteAllLines(filepath, GetCsvLines());
        }

        private string ToCsvLine(CryptoCurrencyTransaction tx)
        {
            return "";
        }

        private string? ConvertToCoinTrackingSymbol(string? symbol)
        {
            if (!string.IsNullOrEmpty(symbol) && CoinTrackingSecificAssetNamesDict.ContainsKey(symbol)) return CoinTrackingSecificAssetNamesDict[symbol];
            return symbol;
        }
    }
}
﻿using Portfolio.Domain.Entities;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Transactions.Exporters
{
    public class KoinlyCsvExporter
    {
        private readonly IEnumerable<CryptoCurrencyTransaction> _transactions;

        public KoinlyCsvExporter(IEnumerable<CryptoCurrencyTransaction> transactions)
        {
            _transactions = transactions ?? throw new ArgumentNullException(nameof(transactions));
        }

        public IEnumerable<string> GetCsvLines(bool withHeader = true)
        {
            var csvLines = new List<string>();
            if (withHeader)
            {
                csvLines.Add("Date,Sent Amount,Sent Currency,Received Amount,Received Currency,Fee Amount,Fee Currency,Net Worth Amount,Net Worth Currency,Label,Description,TxHash");
            }
            csvLines.AddRange(_transactions.Select(t => ToCsvLine(t)));
            return csvLines;
        }

        public void WriteToFile(string filepath)
        {
            File.WriteAllLines(filepath, GetCsvLines());
        }

        private string ToCsvLine(CryptoCurrencyTransaction tx)
        {            
            Money? inAmount = null;
            Money? outAmount = null;
            var label = tx.Note;

            switch (tx)
            {
                case CryptoCurrencyDepositTransaction deposit:
                    inAmount = deposit.Amount;
                    outAmount = null;                    
                    break;
                case CryptoCurrencyWithdrawTransaction wihdraw:
                    inAmount = null;
                    outAmount = wihdraw.Amount;                    
                    break;
                case CryptoCurrencyTradeTransaction trade:
                    var isCryptoToFiat = trade.Amount.IsFiatCurrency && trade.TradeAmount.IsFiatCurrency;
                    var isReceiveFee = trade.Amount.CurrencyCode == trade.FeeAmount?.CurrencyCode;
                    var receiveAmount = isReceiveFee ? trade.Amount.ToAbsoluteAmountMoney().Add(trade.FeeAmount.ToAbsoluteAmountMoney()) : trade.Amount;
                    inAmount = receiveAmount;
                    outAmount = trade.TradeAmount;                    
                    break;
            }

            return $"{tx.DateTime:yyyy-MM-dd HH:mm:ss UTC},{outAmount?.AbsoluteAmount},{outAmount?.CurrencyCode},{inAmount?.AbsoluteAmount},{inAmount?.CurrencyCode},{tx.FeeAmount?.AbsoluteAmount},{tx.FeeAmount?.CurrencyCode},,,{label},{tx.Account},{string.Join("|", tx.TransactionIds.Select(x => x))}"; ;
        }
    }
}
﻿using Portfolio.Domain.Entities;

namespace Portfolio.Transactions.Exporters
{
    public class BlockpitCsvExporter
    {
        private readonly IEnumerable<CryptoCurrencyTransaction> _transactions;

        public BlockpitCsvExporter(IEnumerable<CryptoCurrencyTransaction> transactions)
        {
            _transactions = transactions ?? throw new ArgumentNullException(nameof(transactions));
        }

        public IEnumerable<string> GetCsvLines(bool withHeader = true)
        {
            var csvLines = new List<string>();
            if (withHeader)
            {
                csvLines.Add("Date (UTC),Integration Name,Label,Outgoing Asset,Outgoing Amount,Incoming Asset,Incoming Amount,Fee Asset (optional),Fee Amount (optional),Comment (optional),Trx. ID (optional)");
            }
            csvLines.AddRange(_transactions.Select(t => ToCsvLine(t)));
            return csvLines;
        }

        public void WriteToFile(string filepath)
        {
            File.WriteAllLines(filepath, GetCsvLines());
        }

        private string ToCsvLine(CryptoCurrencyTransaction tx)
        {
            return "";//$"{tx.DateTime:dd.MM.yyyy HH:mm:ss},{tx.Account},{tx.Type},{tx.SentAmount?.CurrencyCode},{tx.SentAmount?.AbsoluteAmount},{tx.ReceivedAmount?.CurrencyCode},{tx.ReceivedAmount?.AbsoluteAmount},{tx.FeeAmount?.CurrencyCode},{tx.FeeAmount?.AbsoluteAmount},,";
        }
    }
}
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Portfolio.App")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+011ea9877178dfe25723c2ee084c5ee6b7ba8590")]
[assembly: System.Reflection.AssemblyProductAttribute("Portfolio.App")]
[assembly: System.Reflection.AssemblyTitleAttribute("Portfolio.App")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
using Microsoft.Data.Sqlite;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.App.HistoricalPrice
{
    public class SQLitePriceHistoryStorageService : IPriceHistoryStorageService
    {
        private readonly string _connectionString;

        public SQLitePriceHistoryStorageService(string databaseFilePath)
        {
            _connectionString = $"Data Source={databaseFilePath};";
            InitializeDatabase();
        }

        private void InitializeDatabase()
        {
            using var connection = new SqliteConnection(_connectionString);
            connection.Open();

            string createTableQuery = @"
                CREATE TABLE IF NOT EXISTS CryptoPriceRecords (
                    Id INTEGER PRIMARY KEY AUTOINCREMENT,
                    CurrencyPair TEXT NOT NULL,
                    CloseDate TEXT NOT NULL,
                    ClosePrice REAL NOT NULL,
                    UNIQUE(CurrencyPair, CloseDate)
                );";

            using var command = new SqliteCommand(createTableQuery, connection);
            command.ExecuteNonQuery();
        }

        public async Task<Result<IEnumerable<PriceRecord>>> LoadHistoryAsync(string symbol)
        {
            var priceHistory = new List<PriceRecord>();

            try
            {
                using var connection = new SqliteConnection(_connectionString);
                await connection.OpenAsync().ConfigureAwait(false);

                string query = "SELECT CurrencyPair, CloseDate, ClosePrice FROM CryptoPriceRecords WHERE CurrencyPair = @CurrencyPair ORDER BY CloseDate;";
                using var command = new SqliteCommand(query, connection);
                command.Parameters.AddWithValue("@CurrencyPair", symbol);

                using var reader = await command.ExecuteReaderAsync().ConfigureAwait(false);
                while (await reader.ReadAsync().ConfigureAwait(false))
                {
                    var currencyPair = reader.GetString(0);
                    var closeDate = DateTime.Parse(reader.GetString(1));
                    var closePrice = reader.GetDecimal(2);

                    priceHistory.Add(new PriceRecord
                    {
                        CurrencyPair = currencyPair,
                        CloseDate = closeDate,
                        ClosePrice = closePrice
                    });
                }

                return Result.Success<IEnumerable<PriceRecord>>(priceHistory);
            }
            catch (Exception ex)
            {
                Log.Error($"[{nameof(SQLitePriceHistoryStorageService)}.{nameof(LoadHistoryAsync)}] An error occurred: {ex.GetBaseException().Message}");
                return Result.Failure<IEnumerable<PriceRecord>>("Error loading data from SQLite.");
            }
        }

        public async Task<Result> SaveHistoryAsync(string symbol, IEnumerable<PriceRecord> priceHistory)
        {
            try
            {
                using var connection = new SqliteConnection(_connectionString);
                await connection.OpenAsync().ConfigureAwait(false);

                using var transaction = connection.BeginTransaction();

                string upsertQuery = @"
                    INSERT OR REPLACE INTO CryptoPriceRecords (CurrencyPair, CloseDate, ClosePrice) 
                    VALUES (@CurrencyPair, @CloseDate, @ClosePrice);";

                using var command = new SqliteCommand(upsertQuery, connection, transaction);

                foreach (var record in priceHistory)
                {
                    command.Parameters.Clear();
                    command.Parameters.AddWithValue("@CurrencyPair", record.CurrencyPair);
                    command.Parameters.AddWithValue("@CloseDate", record.CloseDate.ToString("yyyy-MM-dd"));
                    command.Parameters.AddWithValue("@ClosePrice", record.ClosePrice);

                    await command.ExecuteNonQueryAsync().ConfigureAwait(false);
                }

                transaction.Commit();

                return Result.Success();
            }
            catch (Exception ex)
            {
                Log.Error($"[{nameof(SQLitePriceHistoryStorageService)}.{nameof(SaveHistoryAsync)}] An error occurred: {ex.GetBaseException().Message}");
                return Result.Failure("Error saving data to SQLite.");
            }
        }
    }
}
using System.Globalization;
using CsvHelper;
using CsvHelper.Configuration;
using Portfolio.Domain.Constants;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.App.HistoricalPrice
{
    public sealed class CryptoPriceRecordMap : ClassMap<PriceRecord>
    {
        public CryptoPriceRecordMap()
        {
            AutoMap(CultureInfo.InvariantCulture);
            Map(m => m.CurrencyPair).Ignore();
        }
    }

    public class FilePriceHistoryStorageService : IPriceHistoryStorageService
    {
        public string StorageLocation { get; set; } = "historical_price_data";

        public async Task<Result<IEnumerable<PriceRecord>>> LoadHistoryAsync(string symbol)
        {
            var csvFileName = $"{StorageLocation}/{symbol}_history.csv";

            if (!File.Exists(csvFileName))
                return Result.Failure<IEnumerable<PriceRecord>>($"File not found: {csvFileName}");

            try
            {
                using var reader = new StreamReader(csvFileName);
                using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
                csv.Context.RegisterClassMap<CryptoPriceRecordMap>();

                var records = new List<PriceRecord>();
                await foreach (var record in csv.GetRecordsAsync<PriceRecord>().ConfigureAwait(false))
                {
                    records.Add(record);
                }

                return Result.Success<IEnumerable<PriceRecord>>(records);
            }
            catch (Exception ex)
            {
                Log.ForContext<FilePriceHistoryStorageService>().Error($"[{nameof(FilePriceHistoryStorageService)}.{nameof(LoadHistoryAsync)}] An error occurred: {ex.GetBaseException().Message}");

                File.Delete(csvFileName);

                return Result.Failure<IEnumerable<PriceRecord>>($"Error loading data from CSV.");
            }
        }

        public async Task<Result> SaveHistoryAsync(string symbol, IEnumerable<PriceRecord> priceHistory)
        {
            var csvFileName = $"{StorageLocation}/{symbol}_history.csv";

            if (!Directory.Exists(StorageLocation))
                Directory.CreateDirectory(StorageLocation);

            try
            {
                using (var writer = new StreamWriter(csvFileName))
                using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture))
                {
                    csv.Context.RegisterClassMap<CryptoPriceRecordMap>();
                    csv.WriteRecords(priceHistory.Select(data => new
                    {
                        CloseDate = data.CloseDate.ToString(Strings.DATE_FORMAT),
                        data.ClosePrice
                    }));
                }

                return await Task.FromResult(Result.Success()).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                Log.Error($"[{nameof(FilePriceHistoryStorageService)}.{nameof(SaveHistoryAsync)}] An error occurred: {ex.GetBaseException().Message}");
                return Result.Failure($"Error saving data to CSV.");
            }
        }
    }
}
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.App.HistoricalPrice.YahooFinance
{
    public class PriceHistoryApiWithRetry : IPriceHistoryApi
    {
        private readonly int _numberOfAttemps;
        private readonly IPriceHistoryApi _internalApi;

        public PriceHistoryApiWithRetry(IPriceHistoryApi internalApi, int numberOfAttemps)
        {
            _internalApi = internalApi;
            _numberOfAttemps = numberOfAttemps;
        }

        public async Task<Result<IEnumerable<PriceRecord>>> FetchPriceHistoryAsync(string symbolPair, DateTime startDate, DateTime endDate)
        {
            int retryCount = 0;
            while (retryCount < _numberOfAttemps)
            {
                var priceResult = await _internalApi.FetchPriceHistoryAsync(symbolPair, startDate, endDate).ConfigureAwait(false);
                if (priceResult.IsSuccess)
                {
                    return priceResult;
                }

                retryCount++;
                Log.Warning("Retrying price retrieval for {CurrencyCode} on {Date:yyyy-MM-dd}. Attempt {RetryCount}/{MaxRetries}", symbolPair, startDate, retryCount, _numberOfAttemps);
            }

            return Result.Failure<IEnumerable<PriceRecord>>($"Failed to get price history for {symbolPair} after {_numberOfAttemps} attemps."); // Indicating failure
        }

        public string DetermineTradingPair(string fromSymbol, string toSymbol)
        {
            return _internalApi.DetermineTradingPair(fromSymbol, toSymbol);
        }
    }
}
using System.Diagnostics;
using Portfolio.Domain.Constants;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;
using YahooFinanceApi;

namespace Portfolio.App.HistoricalPrice.YahooFinance
{
    public class YahooFinancePriceHistoryApi : IPriceHistoryApi
    {
        public async Task<Result<IEnumerable<PriceRecord>>> FetchPriceHistoryAsync(string symbolPair, DateTime startDate, DateTime endDate)
        {
            try
            {
                Log.ForContext<YahooFinancePriceHistoryApi>().Information("Initiating data fetch for {SymbolPair} from {StartDate:yyyy-MM-dd} to {EndDate:yyyy-MM-dd}.", symbolPair, startDate, endDate);

                var stopwatch = Stopwatch.StartNew();

                var candles = await Yahoo.GetHistoricalAsync(symbolPair, startDate.Date, endDate.Date, Period.Daily).ConfigureAwait(false);

                stopwatch.Stop();
                Log.Information("Data fetch for {SymbolPair} completed in {ElapsedMilliseconds}ms. Retrieved {CandlesCount} day(s) of data.", symbolPair, stopwatch.ElapsedMilliseconds, candles.Count());

                return Result.Success(MapCandlesToCryptoPriceData(symbolPair, candles));
            }
            catch (HttpRequestException httpEx)
            {
                Log.Error(httpEx, "HTTP error occurred while fetching data for {SymbolPair}.", symbolPair);
                return Result.Failure<IEnumerable<PriceRecord>>(Errors.ERR_YAHOO_API_FETCH_FAILURE);
            }
            catch (TimeoutException timeoutEx)
            {
                Log.Error(timeoutEx, "Timeout occurred while fetching data for {SymbolPair}.", symbolPair);
                return Result.Failure<IEnumerable<PriceRecord>>("Timeout while fetching data.");
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Unexpected error in {MethodName} for {SymbolPair}.", nameof(FetchPriceHistoryAsync), symbolPair);
                return Result.Failure<IEnumerable<PriceRecord>>(Errors.ERR_YAHOO_API_FETCH_FAILURE);
            }
        }

        public string DetermineTradingPair(string fromSymbol, string toSymbol)
        {
            if (FiatCurrency.All.Any(f => f == fromSymbol) && FiatCurrency.All.Any(f => f == toSymbol))
                return $"{fromSymbol}{toSymbol}=X";

            return fromSymbol switch
            {
                "IMX" => $"IMX10603-{toSymbol}",
                "GRT" => $"GRT6719-{toSymbol}",
                "RNDR" => $"RENDER-{toSymbol}",
                "UNI" => $"UNI7083-{toSymbol}",
                "BEAM" => $"BEAM28298-{toSymbol}",
                _ => $"{fromSymbol}-{toSymbol}"
            };
        }

        private static IEnumerable<PriceRecord> MapCandlesToCryptoPriceData(string currencyPair, IEnumerable<Candle> candles)
        {
            return candles.Select(c => ToCryptoPriceData(currencyPair, c));
        }

        private static PriceRecord ToCryptoPriceData(string currencyPair, Candle candle)
        {
            return new PriceRecord
            {
                CurrencyPair = currencyPair,
                CloseDate = candle.DateTime > DateTime.Now ? DateTime.Now.Date : candle.DateTime, // Yahoo API sometimes puts tomorrow's date when fetching current day...
                ClosePrice = candle.Close
            };
        }
    }
}
using System.Collections.Concurrent;
using System.Collections.ObjectModel;
using Portfolio.Domain.Constants;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.App.HistoricalPrice
{
    public class PriceHistoryService : IPriceHistoryService
    {
        private readonly IPriceHistoryApi _priceHistoryApi;
        private readonly IPriceHistoryStorageService _priceHistoryStorage;
        private ConcurrentDictionary<string, Lazy<Task<ReadOnlyDictionary<DateTime, PriceRecord>>>> _dataStores = new();

        public string DefaultCurrency { get; set; }

        public PriceHistoryService(
            IPriceHistoryApi priceHistoryApi,
            IPriceHistoryStorageService priceHistoryStorage,
            string defaultCurrencySymbol = Strings.CURRENCY_USD)
        {
            _priceHistoryApi = priceHistoryApi ?? throw new ArgumentNullException(nameof(priceHistoryApi));
            _priceHistoryStorage = priceHistoryStorage ?? throw new ArgumentNullException(nameof(priceHistoryStorage));

            DefaultCurrency = defaultCurrencySymbol ?? throw new ArgumentNullException(nameof(defaultCurrencySymbol));
        }

        public async Task<Result<decimal>> GetPriceAtCloseTimeAsync(string symbol, DateTime date)
        {
            var dateOnly = date.Date;

            if (symbol == DefaultCurrency)
                return HandleDefaultCurrencyError(symbol);

            var history = await LoadPriceHistoryFromStorageAsync(symbol).ConfigureAwait(false);
            if (history.Any())
            {
                if (history.ContainsKey(dateOnly))
                    return history[dateOnly].ClosePrice;

                if (FiatCurrency.All.Any(f => f == symbol))
                {
                    var handleMissingFiatResult = HandleMissingFiatData(symbol, dateOnly, history);
                    if (handleMissingFiatResult.IsSuccess)
                        return handleMissingFiatResult.Value;
                }
            }

            return await FetchAndSavePriceData(symbol, dateOnly, history).ConfigureAwait(false);
        }

        private Result<decimal> HandleDefaultCurrencyError(string symbol)
        {
            Log.ForContext<PriceHistoryService>().Warning("Attempted to fetch price for the same symbol as the default currency ({Symbol}).", symbol);
            return Result.Failure<decimal>(string.Format(Errors.ERR_SAME_SYMBOLS, symbol, DefaultCurrency));
        }

        private async Task<ReadOnlyDictionary<DateTime, PriceRecord>> LoadPriceHistoryFromStorageAsync(string symbol)
        {
            return await _dataStores.GetOrAddAsync(symbol, async s =>
            {
                var symbolTradingPair = _priceHistoryApi.DetermineTradingPair(symbol, DefaultCurrency);
                var result = await _priceHistoryStorage.LoadHistoryAsync(symbolTradingPair).ConfigureAwait(false);
                if (result.IsSuccess)
                {
                    return result.Value.Where(r => r.ClosePrice > 0).ToDictionary(
                        record => record.CloseDate.Date,
                        record => record
                    ).AsReadOnly();
                }
                else
                {
                    var emptyDictionary = new Dictionary<DateTime, PriceRecord>();
                    var saveResult = await _priceHistoryStorage.SaveHistoryAsync(symbolTradingPair, emptyDictionary.Values)
                        .TapError(Log.ForContext<PriceHistoryService>().Error).ConfigureAwait(false);
                    return emptyDictionary.AsReadOnly();
                }
            }).ConfigureAwait(false);
        }

        private Result<decimal> HandleMissingFiatData(string symbol, DateTime date, ReadOnlyDictionary<DateTime, PriceRecord> history)
        {
            Log.ForContext<PriceHistoryService>().Debug("Missing fiat data for {Symbol} on {Date:yyyy-MM-dd}. Trying previous working days...", symbol, date);

            var previousPriceData = GetPreviousWorkingDayPriceData(date, history);
            if (previousPriceData > -1)
            {
                Log.ForContext<PriceHistoryService>().Debug("Fiat data found for {Symbol} on {Date:yyyy-MM-dd}.", symbol, date);
                return previousPriceData;
            }

            Log.ForContext<PriceHistoryService>().Debug("No available fiat data for {Symbol} on previous working days.", symbol);
            return Result.Failure<decimal>($"No price data available for {symbol} on {date:yyyy-MM-dd}");
        }

        private decimal GetPreviousWorkingDayPriceData(DateTime date, ReadOnlyDictionary<DateTime, PriceRecord> history)
        {
            for (int i = 1; i <= 4; i++)
            {
                var previousDate = date.AddDays(-i);
                if (history.TryGetValue(previousDate, out var priceData))
                    return priceData.ClosePrice;
            }
            return -1;
        }

        private async Task<Result<decimal>> FetchAndSavePriceData(string symbol, DateTime date, ReadOnlyDictionary<DateTime, PriceRecord> history)
        {
            var symbolTradingPair = _priceHistoryApi.DetermineTradingPair(symbol, DefaultCurrency);
            var endDate = AdjustEndDate(date);
            var result = await _priceHistoryApi.FetchPriceHistoryAsync(symbolTradingPair, date.Date, endDate).ConfigureAwait(false);

            if (result.IsSuccess)
            {
                var saveResult = await SaveNewPriceHistoryAsync(symbolTradingPair, history, result.Value)
                    .TapError(Log.ForContext<PriceHistoryService>().Error).ConfigureAwait(false);

                history = await UpdateHistoryWithFetchedDataAsync(symbol, history, result.Value).ConfigureAwait(false);

                if (history.ContainsKey(date.Date))
                    return history[date.Date].ClosePrice;
                else if (FiatCurrency.All.Any(f => f == symbol))
                {
                    var handleMissingFiatResult = HandleMissingFiatData(symbol, date, history);
                    if (handleMissingFiatResult.IsSuccess)
                        return handleMissingFiatResult.Value;
                }

                return Result.Failure<decimal>("Unexpected error has occurred.");
            }

            return Result.Failure<decimal>(result.Error);
        }

        private DateTime AdjustEndDate(DateTime date)
        {
            var endDate = date.AddDays(365);
            return endDate > DateTime.Now ? DateTime.Now.AddDays(1) : endDate;
        }

        private async Task<Result> SaveNewPriceHistoryAsync(string symbol, ReadOnlyDictionary<DateTime, PriceRecord> currentHistory, IEnumerable<PriceRecord> newRecords)
        {
            var existingRecords = currentHistory.Values;

            var recordsToSave = newRecords
                .Where(newRecord => !existingRecords.Any(existingRecord =>
                    existingRecord.CurrencyPair == newRecord.CurrencyPair &&
                    existingRecord.CloseDate == newRecord.CloseDate))
                .ToList();

            if (recordsToSave.Any())
            {
                return await _priceHistoryStorage.SaveHistoryAsync(symbol, recordsToSave).ConfigureAwait(false);
            }
            else
            {
                Log.Information("No new records to save for {Symbol}.", symbol);
                return Result.Success();
            }
        }

        private async Task<ReadOnlyDictionary<DateTime, PriceRecord>> UpdateHistoryWithFetchedDataAsync(string symbol, ReadOnlyDictionary<DateTime, PriceRecord> history, IEnumerable<PriceRecord> records)
        {
            return await _dataStores.AddOrUpdateAsync(symbol, async _ => await Task.FromResult(history), async (k, v) => 
            {
                var dict = v.ToDictionary();
                foreach (var record in records)
                {
                    var closeDate = record.CloseDate.Date;
                    if (!dict.ContainsKey(closeDate) && record.ClosePrice > 0)
                        dict[closeDate] = record;
                }
                return dict.AsReadOnly();
            }).ConfigureAwait(false);
        }
    }
}
using Newtonsoft.Json.Linq;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.App.HistoricalPrice.CoinGecko
{
    public class CoinGeckoPriceHistoryApi : IPriceHistoryApi
    {
        private readonly HttpClient _httpClient;
        private const string BaseUrl = "https://api.coingecko.com/api/v3";

        public CoinGeckoPriceHistoryApi(HttpClient httpClient)
        {
            _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
        }

        public async Task<Result<IEnumerable<PriceRecord>>> FetchPriceHistoryAsync(string symbolPair, DateTime startDate, DateTime endDate)
        {
            try
            {
                Log.Information("Fetching data from CoinGecko for {SymbolPair} from {StartDate:yyyy-MM-dd} to {EndDate:yyyy-MM-dd}.", symbolPair, startDate, endDate);

                var coinId = GetCoinGeckoId(symbolPair.Split('/')[0]);
                if (string.IsNullOrEmpty(coinId))
                {
                    return Result.Failure<IEnumerable<PriceRecord>>($"CoinGecko ID not found for symbol: {symbolPair}");
                }

                var priceData = new List<PriceRecord>();

                for (var date = startDate.Date; date <= endDate.Date; date = date.AddDays(1))
                {
                    var url = $"{BaseUrl}/coins/{coinId}/history?date={date:dd-MM-yyyy}";
                    var response = await _httpClient.GetAsync(url).ConfigureAwait(false);
                    if (!response.IsSuccessStatusCode)
                    {
                        Log.Warning("Failed to fetch data from CoinGecko for {SymbolPair} on {Date:yyyy-MM-dd}. Status Code: {StatusCode}.", symbolPair, date, response.StatusCode);
                        continue;
                    }

                    var content = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                    var jsonData = JObject.Parse(content);
                    var price = jsonData["market_data"]?["current_price"]?[symbolPair.Split('/')[1].ToLower()]?.ToObject<decimal?>();

                    if (price.HasValue)
                    {
                        priceData.Add(new PriceRecord
                        {
                            CurrencyPair = symbolPair,
                            CloseDate = date,
                            ClosePrice = price.Value
                        });
                    }
                    else
                    {
                        Log.Warning("Price data not available for {SymbolPair} on {Date:yyyy-MM-dd}.", symbolPair, date);
                    }
                }

                if (priceData.Any())
                {
                    Log.Information("Successfully retrieved price data from CoinGecko for {SymbolPair}.", symbolPair);
                    return Result.Success<IEnumerable<PriceRecord>>(priceData);
                }
                else
                {
                    return Result.Failure<IEnumerable<PriceRecord>>("No price data retrieved from CoinGecko.");
                }
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Error occurred while fetching data from CoinGecko for {SymbolPair}.", symbolPair);
                return Result.Failure<IEnumerable<PriceRecord>>("An error occurred while fetching data from CoinGecko.");
            }
        }

        private string GetCoinGeckoId(string symbol)
        {
            return symbol.ToLower() switch
            {
                "btc" => "bitcoin",
                "eth" => "ethereum",
                "xrp" => "ripple",
                "ltc" => "litecoin",
                "ada" => "cardano",
                _ => string.Empty
            };
        }

        public string DetermineTradingPair(string fromSymbol, string toSymbol)
        {
            return $"{fromSymbol.ToLower()}/{toSymbol.ToLower()}";
        }
    }
}
global using CSharpFunctionalExtensions;
global using Serilog;using Portfolio.Domain.Events;

namespace Portfolio.App.DomainEventHandlers
{
    public class FinancialEventAddedDomainEventHandler : INotificationHandler<FinancialEventAdded>
    {
        public Task Handle(FinancialEventAdded notification, CancellationToken cancellationToken)
        {
            var holding = notification.Holding;
            var transaction = notification.Transaction;

            if(string.IsNullOrWhiteSpace(notification.ErrorMessage))
            {
                Log.Information("Financial event created.");
            }
            else
            {
                Log.Error("Financial event could not be created: {ErrorMessage}", notification.ErrorMessage);
            }

            return Task.CompletedTask;
        }
    }
}using System.Reflection;
using Microsoft.Extensions.DependencyInjection;
using Portfolio.App.Common.Behaviours;

namespace Portfolio.App
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddApplicationServices(this IServiceCollection services)
        {
            services.AddAutoMapper(Assembly.GetExecutingAssembly());

            services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());

            services.AddMediatR(cfg =>
            {
                cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
                cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(UnhandledExceptionBehaviour<,>));
                cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(AuthorizationBehaviour<,>));
                cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(ValidationBehaviour<,>));
                cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(PerformanceBehaviour<,>));
            });

            return services;
        }
    }
}using System.Collections.Concurrent;

namespace Portfolio.App
{
    public static class ConcurrentDictionaryExtensions
    {
        public static async Task<TValue> GetOrAddAsync<TKey, TValue>(
            this ConcurrentDictionary<TKey, Lazy<Task<TValue>>> dictionary,
            TKey key,
            Func<TKey, Task<TValue>> valueFactory) where TKey : notnull
        {
            var lazyValue = dictionary.GetOrAdd(key, k => new Lazy<Task<TValue>>(() => valueFactory(k)));

            try
            {
                return await lazyValue.Value.ConfigureAwait(false);
            }
            catch
            {
                dictionary.TryRemove(key, out _);
                throw;
            }
        }

        public static async Task<bool> TryAddAsync<TKey, TValue>(
            this ConcurrentDictionary<TKey, Lazy<Task<TValue>>> dictionary,
            TKey key,
            Func<TKey, Task<TValue>> valueFactory) where TKey : notnull
        {
            var lazyValue = new Lazy<Task<TValue>>(() => valueFactory(key));

            if (dictionary.TryAdd(key, lazyValue))
            {
                try
                {
                    await lazyValue.Value.ConfigureAwait(false);
                    return true;
                }
                catch
                {
                    dictionary.TryRemove(key, out _);
                    throw;
                }
            }

            return false; // The key already exists, so we don't add a new value.
        }

        public static async Task<TValue> AddOrUpdateAsync<TKey, TValue>(
            this ConcurrentDictionary<TKey, Lazy<Task<TValue>>> dictionary,
            TKey key,
            Func<TKey, Task<TValue>> addValueFactory,
            Func<TKey, TValue, Task<TValue>> updateValueFactory) where TKey : notnull
        {
            var lazyValue = new Lazy<Task<TValue>>(() => addValueFactory(key));

            var result = dictionary.AddOrUpdate(
                key,
                lazyValue,
                (k, existingLazyValue) => new Lazy<Task<TValue>>(async () =>
                {
                    var existingValue = await existingLazyValue.Value.ConfigureAwait(false);
                    return await updateValueFactory(k, existingValue).ConfigureAwait(false);
                }));

            try
            {
                return await result.Value.ConfigureAwait(false);
            }
            catch
            {
                dictionary.TryRemove(key, out _);
                throw;
            }
        }
    }
}
namespace Portfolio.App;

public enum CsvFileImportType
{
    Standard,
    Kraken
}using Portfolio.Domain.Entities;

namespace Portfolio.App.DTOs
{
    public class WalletDto
    {
        public long Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public IEnumerable<CryptoCurrencyTransactionDto> Transactions { get; set; } = new List<CryptoCurrencyTransactionDto>();

        public static WalletDto From(Wallet wallet)
        {
            return new WalletDto
            {
                Id = wallet.Id,
                Name = wallet.Name,
                Transactions = wallet.Transactions.Select(t => CryptoCurrencyTransactionDto.From(t)).ToList()
            };
        }
    }
}
namespace Portfolio.App.DTOs
{
    public class PortfolioDto
    {
    }
}
using Portfolio.Domain.Entities;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.App.DTOs
{
    public class CryptoCurrencyTransactionDto
    {
        public long Id { get; set; }
        public DateTime DateTime { get; set; }
        public string Type { get; set; } = string.Empty;
        public decimal? ReceivedAmount { get; set; }
        public string ReceivedCurrency { get; set; } = string.Empty;
        public decimal? SentAmount { get; set; }
        public string SentCurrency { get; set; } = string.Empty;
        public decimal? FeeAmount { get; set; }
        public string FeeCurrency { get; set; } = string.Empty;
        public string Account { get; set; } = string.Empty;
        public string Note { get; set; } = string.Empty;

        public static CryptoCurrencyTransactionDto From(FinancialTransaction transaction)
        {
            if (transaction is null) throw new ArgumentNullException(nameof(transaction));

            return new CryptoCurrencyTransactionDto
            {
                Id = transaction.Id,
                DateTime = transaction.DateTime,
                Type = transaction.Type.ToString(),
                ReceivedAmount = (transaction.ReceivedAmount == Money.Empty) ? null : transaction.ReceivedAmount.Amount,
                ReceivedCurrency = transaction.ReceivedAmount?.CurrencyCode ?? string.Empty,
                SentAmount = (transaction.SentAmount == Money.Empty) ? null : transaction.SentAmount.Amount,
                SentCurrency = transaction.SentAmount?.CurrencyCode ?? string.Empty,
                FeeAmount = (transaction.FeeAmount == Money.Empty) ? null : transaction.FeeAmount.Amount,
                FeeCurrency = transaction.FeeAmount?.CurrencyCode ?? string.Empty,
                Account = transaction.Account,
                Note = transaction.Note
            };
        }
    }
}
﻿namespace Portfolio.App.Common.Security;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
public class AuthorizeAttribute : Attribute
{
    public AuthorizeAttribute() { }

    public string Roles { get; set; } = string.Empty;

    public string Policy { get; set; } = string.Empty;
}
﻿using System.Reflection;
using Portfolio.App.Common.Exceptions;
using Portfolio.App.Common.Interfaces;
using Portfolio.App.Common.Security;
using Portfolio.Domain.Interfaces;

namespace Portfolio.App.Common.Behaviours;

public class AuthorizationBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> where TRequest : notnull
{
    private readonly IUser _user;
    private readonly IIdentityService _identityService;

    public AuthorizationBehaviour(
        IUser user,
        IIdentityService identityService)
    {
        _user = user;
        _identityService = identityService;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        var authorizeAttributes = request.GetType().GetCustomAttributes<AuthorizeAttribute>();

        if (authorizeAttributes.Any())
        {
            if (_user.Id == null)
            {
                throw new UnauthorizedAccessException();
            }

            var authorizeAttributesWithRoles = authorizeAttributes.Where(a => !string.IsNullOrWhiteSpace(a.Roles));

            if (authorizeAttributesWithRoles.Any())
            {
                var authorized = false;

                foreach (var roles in authorizeAttributesWithRoles.Select(a => a.Roles.Split(',')))
                {
                    foreach (var role in roles)
                    {
                        var isInRole = await _identityService.IsInRoleAsync(_user.Id, role.Trim());
                        if (isInRole)
                        {
                            authorized = true;
                            break;
                        }
                    }
                }

                if (!authorized)
                {
                    throw new ForbiddenAccessException();
                }
            }

            var authorizeAttributesWithPolicies = authorizeAttributes.Where(a => !string.IsNullOrWhiteSpace(a.Policy));
            if (authorizeAttributesWithPolicies.Any())
            {
                foreach (var policy in authorizeAttributesWithPolicies.Select(a => a.Policy))
                {
                    var authorized = await _identityService.AuthorizeAsync(_user.Id, policy);

                    if (!authorized)
                    {
                        throw new ForbiddenAccessException();
                    }
                }
            }
        }

        return await next();
    }
}
﻿using ValidationException = Portfolio.App.Common.Exceptions.ValidationException;

namespace Portfolio.App.Common.Behaviours;

public class ValidationBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
     where TRequest : notnull
{
    private readonly IEnumerable<IValidator<TRequest>> _validators;

    public ValidationBehaviour(IEnumerable<IValidator<TRequest>> validators)
    {
        _validators = validators;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        if (_validators.Any())
        {
            var context = new ValidationContext<TRequest>(request);

            var validationResults = await Task.WhenAll(
                _validators.Select(v =>
                    v.ValidateAsync(context, cancellationToken)));

            var failures = validationResults
                .Where(r => r.Errors.Any())
                .SelectMany(r => r.Errors)
                .ToList();

            if (failures.Any())
                throw new ValidationException(failures);
        }
        return await next();
    }
}
﻿using System.Diagnostics;
using Microsoft.Extensions.Logging;
using Portfolio.App.Common.Interfaces;
using Portfolio.Domain.Interfaces;

namespace Portfolio.App.Common.Behaviours;

public class PerformanceBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> where TRequest : notnull
{
    private readonly Stopwatch _timer;
    private readonly ILogger<TRequest> _logger;
    private readonly IUser _user;
    private readonly IIdentityService _identityService;

    public PerformanceBehaviour(
        ILogger<TRequest> logger,
        IUser user,
        IIdentityService identityService)
    {
        _timer = new Stopwatch();

        _logger = logger;
        _user = user;
        _identityService = identityService;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        _timer.Start();

        var response = await next();

        _timer.Stop();

        var elapsedMilliseconds = _timer.ElapsedMilliseconds;

        if (elapsedMilliseconds > 500)
        {
            var requestName = typeof(TRequest).Name;
            var userId = _user.Id ?? string.Empty;
            var userName = string.Empty;

            if (!string.IsNullOrEmpty(userId))
            {
                userName = await _identityService.GetUserNameAsync(userId);
            }

            _logger.LogWarning("Wics Long Running Request: {Name} ({ElapsedMilliseconds} milliseconds) {@UserId} {@UserName} {@Request}",
                requestName, elapsedMilliseconds, userId, userName, request);
        }

        return response;
    }
}
﻿using Microsoft.Extensions.Logging;

namespace Portfolio.App.Common.Behaviours;

public class UnhandledExceptionBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> where TRequest : notnull
{
    private readonly ILogger<TRequest> _logger;

    public UnhandledExceptionBehaviour(ILogger<TRequest> logger)
    {
        _logger = logger;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        try
        {
            return await next();
        }
        catch (Exception ex)
        {
            var requestName = typeof(TRequest).Name;

            Log.Error(ex, "Wics Request: Unhandled Exception for Request {Name} {@Request}", requestName, request);

            throw;
        }
    }
}
﻿using MediatR.Pipeline;
using Microsoft.Extensions.Logging;
using Portfolio.App.Common.Interfaces;
using Portfolio.Domain.Interfaces;

namespace Portfolio.App.Common.Behaviours;

public class LoggingBehaviour<TRequest> : IRequestPreProcessor<TRequest> where TRequest : notnull
{
    private readonly Microsoft.Extensions.Logging.ILogger _logger;
    private readonly IUser _user;
    private readonly IIdentityService _identityService;

    public LoggingBehaviour(ILogger<TRequest> logger, IUser user, IIdentityService identityService)
    {
        _logger = logger;
        _user = user;
        _identityService = identityService;
    }

    public async Task Process(TRequest request, CancellationToken cancellationToken)
    {
        var requestName = typeof(TRequest).Name;
        var userId = _user.Id ?? string.Empty;
        string? userName = string.Empty;

        if (!string.IsNullOrEmpty(userId))
        {
            userName = await _identityService.GetUserNameAsync(userId);
        }

        _logger.LogInformation("Wics Request: {Name} {@UserId} {@UserName} {@Request}",
            requestName, userId, userName, request);
    }
}
﻿namespace Portfolio.App.Common.Models;

public class LookupDto
{
    public int Id { get; init; }

    public string? Title { get; init; }

    private class Mapping : Profile
    {
        public Mapping()
        {
        }
    }
}
﻿namespace Portfolio.App.Common.Models;

public class PaginatedList<T>
{
    public IReadOnlyCollection<T> Items { get; }
    public int PageNumber { get; }
    public int TotalPages { get; }
    public int TotalCount { get; }

    public PaginatedList(IReadOnlyCollection<T> items, int count, int pageNumber, int pageSize)
    {
        PageNumber = pageNumber;
        TotalPages = (int)Math.Ceiling(count / (double)pageSize);
        TotalCount = count;
        Items = items;
    }

    public bool HasPreviousPage => PageNumber > 1;

    public bool HasNextPage => PageNumber < TotalPages;

    public static async Task<PaginatedList<T>> CreateAsync(IQueryable<T> source, int pageNumber, int pageSize)
    {
        var count = await source.CountAsync();
        var items = await source.Skip((pageNumber - 1) * pageSize).Take(pageSize).ToListAsync();

        return new PaginatedList<T>(items, count, pageNumber, pageSize);
    }
}
﻿namespace Portfolio.App.Common.Exceptions;

public class ForbiddenAccessException : Exception
{
    public ForbiddenAccessException() : base() { }
}
﻿using FluentValidation.Results;

namespace Portfolio.App.Common.Exceptions;

public class ValidationException : Exception
{
    public ValidationException()
        : base("One or more validation failures have occurred.")
    {
        Errors = new Dictionary<string, string[]>();
    }

    public ValidationException(IEnumerable<ValidationFailure> failures)
        : this()
    {
        Errors = failures
            .GroupBy(e => e.PropertyName, e => e.ErrorMessage)
            .ToDictionary(failureGroup => failureGroup.Key, failureGroup => failureGroup.ToArray());
    }

    public IDictionary<string, string[]> Errors { get; }
}
﻿using Portfolio.App.Common.Models;

namespace Portfolio.App.Common.Mappings;

public static class MappingExtensions
{
    public static Task<PaginatedList<TDestination>> PaginatedListAsync<TDestination>(this IQueryable<TDestination> queryable, int pageNumber, int pageSize) where TDestination : class
        => PaginatedList<TDestination>.CreateAsync(queryable.AsNoTracking(), pageNumber, pageSize);

}
﻿namespace Portfolio.App.Common.Interfaces;

public interface IIdentityService
{
    Task<string?> GetUserNameAsync(string userId);

    Task<bool> IsInRoleAsync(string userId, string role);

    Task<bool> AuthorizeAsync(string userId, string policyName);

    Task<(Result Result, string UserId)> CreateUserAsync(string userName, string password);

    Task<Result> DeleteUserAsync(string userId);
}
global using AutoMapper;
global using Microsoft.EntityFrameworkCore;
global using FluentValidation;
global using MediatR;using Portfolio.App;
using Portfolio.App.DTOs;

namespace Portfolio.Api.Services
{
    public interface ICryptoTransactionService
    {
        Task<Result<long>> AddTransactionAsync(long portfolioId, long walletId, CryptoCurrencyTransactionDto transactionDto);
        Task<Result> UpdateTransactionAsync(long portfolioId, long walletId, long transactionId, CryptoCurrencyTransactionDto transactionDto);
        Task<Result> DeleteTransactionAsync(long portfolioId, long walletId, long transactionId);
        Task<Result<CryptoCurrencyTransactionDto>> GetTransactionAsync(long portfolioId, long walletId, long transactionId);
        Task<Result<IEnumerable<CryptoCurrencyTransactionDto>>> GetTransactionsAsync(long portfolioId, long walletId);
        Task<Result> ImportTransactionsFromCsvAsync(long portfolioId, long walletId, CsvFileImportType csvType, StreamReader streamReader);
        Task<Result> BulkUpdateTransactionsAsync(long portfolioId, long walletId, List<CryptoCurrencyTransactionDto> transactionsToUpdate);
        Task<Result> BulkDeleteTransactionsAsync(long portfolioId, long walletId, long[] transactionIds);
    }
}
using Portfolio.App;
using Portfolio.App.DTOs;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Enums;
using Portfolio.Domain.ValueObjects;
using Portfolio.Infrastructure;
using Portfolio.Transactions.Importers.Csv.Kraken;

namespace Portfolio.Api.Services
{
    public partial class CryptoTransactionService : ICryptoTransactionService
    {
        private readonly PortfolioDbContext _dbContext;

        public CryptoTransactionService(PortfolioDbContext dbContext)
        {
            _dbContext = dbContext;
        }

        public async Task<Result<long>> AddTransactionAsync(long portfolioId, long walletId, CryptoCurrencyTransactionDto transactionDto)
        {
            var wallet = await _dbContext.Wallets                
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
                return Result.Failure<long>($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");

            if (!Enum.TryParse(transactionDto.Type, true, out TransactionType transactionType))
                return Result.Failure<long>($"Invalid transaction type {transactionDto.Type}");

            Result<FinancialTransaction> addTransactionResult = new Result<FinancialTransaction>();
            switch (transactionType)
            {
                case TransactionType.Deposit:
                    addTransactionResult = FinancialTransaction.CreateDeposit(
                        transactionDto.DateTime,
                        new Money(transactionDto.ReceivedAmount ?? 0m, transactionDto.ReceivedCurrency),
                        transactionDto.FeeAmount.HasValue ? new Money(transactionDto.FeeAmount ?? 0m, transactionDto.FeeCurrency) : null,
                        transactionDto.Account,
                        [],
                        transactionDto.Note
                    );
                    break;
                case TransactionType.Withdrawal:
                    addTransactionResult = FinancialTransaction.CreateWithdraw(
                        transactionDto.DateTime,
                        new Money(transactionDto.SentAmount.GetValueOrDefault(), transactionDto.SentCurrency),
                        transactionDto.FeeAmount.HasValue ? new Money(transactionDto.FeeAmount.Value, transactionDto.FeeCurrency) : null,
                        transactionDto.Account,
                        [],
                        transactionDto.Note
                    );
                    break;
                case TransactionType.Trade:
                    addTransactionResult = FinancialTransaction.CreateTrade(
                        transactionDto.DateTime,
                        new Money(transactionDto.ReceivedAmount.GetValueOrDefault(), transactionDto.ReceivedCurrency),
                        new Money(transactionDto.SentAmount.GetValueOrDefault(), transactionDto.SentCurrency),
                        transactionDto.FeeAmount.HasValue ? new Money(transactionDto.FeeAmount.Value, "USD") : null,
                        transactionDto.Account,
                        [],
                        transactionDto.Note
                    );
                    break;
            }

            return await addTransactionResult
                .Check(t => EnsureTransactionNotAlreadyExistsAsync(walletId, t))
                .Check(wallet.AddTransaction)
                .Tap(async t => await _dbContext.SaveChangesAsync())
                .Map(t => t.Id);
        }

        public async Task<Result> UpdateTransactionAsync(long portfolioId, long walletId, long transactionId, CryptoCurrencyTransactionDto transactionDto)
        {
            var isUserWallet = await _dbContext.Wallets
                .AsNoTracking()
                .AnyAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (!isUserWallet)
                return Result.Failure<CryptoCurrencyTransactionDto>($"Transaction with ID {transactionId} not found in Wallet {walletId}.");

            var transaction = _dbContext.RawTransactions.AsNoTracking().FirstOrDefault(t => t.Id == transactionId);
            if (transaction == null)
                return Result.Failure($"Transaction with ID {transactionId} not found in Wallet {walletId}.");

            var receivedAmount = Money.Create(transactionDto.ReceivedAmount, transactionDto.ReceivedCurrency);
            var sentAmount = Money.Create(transactionDto.SentAmount, transactionDto.SentCurrency);
            var feeAmount = Money.Create(transactionDto.FeeAmount, transactionDto.FeeCurrency);

            return await transaction.SetTransactionAmounts(receivedAmount.GetValueOrDefault(), sentAmount.GetValueOrDefault(), feeAmount.GetValueOrDefault())
                .Bind(() => transaction.SetNote(transactionDto.Note))
                .Bind(() => transaction.SetTransactionDate(transactionDto.DateTime))
                .Tap(async () => await _dbContext.SaveChangesAsync());
        }

        public async Task<Result> BulkUpdateTransactionsAsync(long portfolioId, long walletId, List<CryptoCurrencyTransactionDto> transactionsToUpdate)
        {
            var wallet = await _dbContext.Wallets
                .Include(w => w.Transactions)
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
                return Result.Failure<IEnumerable<CryptoCurrencyTransactionDto>>($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");


            var transactionIds = transactionsToUpdate.Select(t => t.Id).ToArray();
            var transactions = await _dbContext.RawTransactions
                                             .Where(t => transactionIds.Contains(t.Id))
                                             .ToListAsync();

            if (transactions.Count != transactionIds.Length)
                return Result.Failure("Some transactions could not be found.");

            foreach (var transaction in transactions)
            {
                var updatedTransaction = transactionsToUpdate.First(t => t.Id == transaction.Id);
                var receivedAmount = Money.Create(updatedTransaction.ReceivedAmount, updatedTransaction.ReceivedCurrency);
                var sentAmount = Money.Create(updatedTransaction.SentAmount, updatedTransaction.SentCurrency);
                var feeAmount = Money.Create(updatedTransaction.FeeAmount, updatedTransaction.FeeCurrency);

                var result = transaction.SetTransactionAmounts(receivedAmount.GetValueOrDefault(), sentAmount.GetValueOrDefault(), feeAmount.GetValueOrDefault())
                    .Bind(() => transaction.SetNote(updatedTransaction.Note))
                    .Bind(() => transaction.SetTransactionDate(updatedTransaction.DateTime));
            }

            await _dbContext.SaveChangesAsync();

            return Result.Success();
        }

        public async Task<Result> DeleteTransactionAsync(long portfolioId, long walletId, long transactionId)
        {
            var isUserWallet = await _dbContext.Wallets                
                .AnyAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (!isUserWallet)
                return Result.Failure<CryptoCurrencyTransactionDto>($"Transaction with ID {transactionId} not found in Wallet {walletId}.");

            var transaction = _dbContext.RawTransactions.AsNoTracking().FirstOrDefault(t => t.Id == transactionId);
            if (transaction == null)
            {
                return Result.Failure($"Transaction with ID {transactionId} not found in Wallet {walletId}.");
            }

            _dbContext.RawTransactions.Remove(transaction);

            await _dbContext.SaveChangesAsync();

            return Result.Success();
        }

        public async Task<Result> BulkDeleteTransactionsAsync(long portfolioId, long walletId, long[] transactionIds)
        {
            var wallet = await _dbContext.Wallets            
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
                return Result.Failure<IEnumerable<CryptoCurrencyTransactionDto>>($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");

            var transactions = await _dbContext.RawTransactions
                                             .Where(t => transactionIds.Contains(t.Id))
                                             .ToListAsync();

            if (transactions.Count != transactionIds.Length)
                return Result.Failure("Some transactions could not be found.");
                        
            _dbContext.RawTransactions.RemoveRange(transactions);
            await _dbContext.SaveChangesAsync();

            return Result.Success();
        }


        public async Task<Result<IEnumerable<CryptoCurrencyTransactionDto>>> GetTransactionsAsync(long portfolioId, long walletId)
        {
            var wallet = await _dbContext.Wallets
                .Include(w => w.Transactions)
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
                return Result.Failure<IEnumerable<CryptoCurrencyTransactionDto>>($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");

            var transactionsDto = wallet.Transactions.Select(t => CryptoCurrencyTransactionDto.From(t));

            return Result.Success(transactionsDto);
        }

        public async Task<Result<CryptoCurrencyTransactionDto>> GetTransactionAsync(long portfolioId, long walletId, long transactionId)
        {
            var isUserWallet = await _dbContext
                .Wallets
                .AsNoTracking()
                .AnyAsync(w => w.Id == walletId && w.PortfolioId == portfolioId && w.Transactions.Any(t => t.Id == transactionId));

            if (!isUserWallet)
                return Result.Failure<CryptoCurrencyTransactionDto>($"Transaction with ID {transactionId} not found in Wallet {walletId}.");

            var transaction = await _dbContext.RawTransactions.AsNoTracking().FirstAsync(t => t.Id == transactionId);

            return Result.Success(CryptoCurrencyTransactionDto.From(transaction));
        }

        public async Task<Result> ImportTransactionsFromCsvAsync(long portfolioId, long walletId, CsvFileImportType csvType, StreamReader streamReader)
        {
            var wallet = await _dbContext
                .Wallets                
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
                return Result.Failure($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");

            IEnumerable<FinancialTransaction>? transactions = null;

            try
            {
                switch (csvType)
                {
                    case CsvFileImportType.Standard:
                        break;
                    case CsvFileImportType.Kraken:
                        var parserResult = KrakenCsvParser.Create(streamReader);
                        if (parserResult.IsFailure)
                            return Result.Failure(parserResult.Error);

                        transactions = parserResult.Value.ExtractTransactions();
                        break;
                }
            }
            catch (Exception ex)
            {
                return Result.Failure($"Failed to import transactions from CSV: {ex.Message}");
            }

            if (transactions?.Any() == true)
            {
                foreach (var transaction in transactions)
                {
                    var addTransactionResult = await EnsureTransactionNotAlreadyExistsAsync(walletId, transaction)
                        .Bind(() => wallet.AddTransaction(transaction));

                    if (addTransactionResult.IsFailure)
                        return Result.Failure(addTransactionResult.Error);
                }
            }
            else
                return Result.Failure("No transactions to import from CSV.");

            await _dbContext.SaveChangesAsync();

            return Result.Success();
        }

        private async Task<Result> EnsureTransactionNotAlreadyExistsAsync(long walletId, FinancialTransaction n)
        {
            decimal received = n.ReceivedAmount.Amount;// ?? null;
            decimal sent = n.SentAmount.Amount;// ?? null;
            decimal fee = n.FeeAmount.Amount;// ?? null;
            string receivedCurrency = n.ReceivedAmount.CurrencyCode;// ?? null;
            string sentCurrency = n.SentAmount.CurrencyCode;// ?? null;
            string feeCurrency = n.FeeAmount.CurrencyCode;// ?? null;

            var exists = await _dbContext.RawTransactions.AsNoTracking().AnyAsync(other =>
                walletId == other.WalletId &&
                n.DateTime == other.DateTime &&
                n.Type == other.Type &&
                received == other.ReceivedAmount.Amount &&
                sent == other.SentAmount.Amount &&
                fee == other.FeeAmount.Amount &&
                receivedCurrency == other.ReceivedAmount.CurrencyCode &&
                sentCurrency == other.SentAmount.CurrencyCode &&
                feeCurrency == other.FeeAmount.CurrencyCode
                );
            if (exists)
                return Result.Failure<long>("Transaction already exists in this wallet.");
            return Result.Success();
        }
    }
}
using Portfolio.App.DTOs;
using Portfolio.Domain.Entities;
using Portfolio.Infrastructure;

namespace Portfolio.App.Services
{
    public class WalletService : IWalletService
    {
        private readonly PortfolioDbContext _dbContext;

        public WalletService(PortfolioDbContext dbContext)
        {
            _dbContext = dbContext;
        }

        public async Task<Result<long>> CreateWalletAsync(long portfolioId, WalletDto walletDto)
        {
            UserPortfolio? portfolio = await _dbContext.Portfolios
                .Include(p => p.Wallets)
                .FirstOrDefaultAsync(p => p.Id == portfolioId)
                .ConfigureAwait(false);

            if (portfolio == null)
            {
                return Result.Failure<long>($"Portfolio with ID {portfolioId} not found.");
            }

            return await Wallet.Create(walletDto.Name)
                .Check(w => portfolio.AddWallet(w))
                .Tap(async () => await _dbContext.SaveChangesAsync().ConfigureAwait(false))
                .Map(w => w.Id);
        }

        public async Task<Result> DeleteWalletAsync(long portfolioId, long walletId)
        {
            Wallet? wallet = await _dbContext.Wallets
                .Include(w => w.Transactions)
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
            {
                return Result.Failure($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");
            }

            _dbContext.Wallets.Remove(wallet);
            await _dbContext.SaveChangesAsync();

            return Result.Success();
        }

        public async Task<Result<WalletDto>> GetWalletAsync(long portfolioId, long walletId)
        {
            var wallet = await _dbContext.Wallets
                .Include(w => w.Transactions)
                .FirstOrDefaultAsync(w => w.Id == walletId && w.PortfolioId == portfolioId);

            if (wallet == null)
            {
                return Result.Failure<WalletDto>($"Wallet with ID {walletId} not found in Portfolio {portfolioId}.");
            }

            var walletDto = WalletDto.From(wallet);
            
            return Result.Success(walletDto);
        }

        public async Task<Result<IEnumerable<WalletDto>>> GetWalletsAsync(long portfolioId)
        {
            var wallets = await _dbContext.Wallets
                .Where(w => w.PortfolioId == portfolioId)
                .Include(w => w.Transactions)
                .ToListAsync();

            var walletDtos = wallets.Select(w => WalletDto.From(w)).ToList();

            return Result.Success<IEnumerable<WalletDto>>(walletDtos);
        }
    }
}
using Portfolio.App.DTOs;

namespace Portfolio.App.Services
{
    public interface IWalletService
    {
        Task<Result<long>> CreateWalletAsync(long portfolioId, WalletDto walletDto);
        Task<Result> DeleteWalletAsync(long portfolioId, long walletId);
        Task<Result<WalletDto>> GetWalletAsync(long portfolioId, long walletId);
        Task<Result<IEnumerable<WalletDto>>> GetWalletsAsync(long portfolioId);
    }
}
﻿using Serilog.Events;
using Serilog.Formatting.Json;
using Portfolio.Transactions.Importers.Csv.Kraken;
using Portfolio.Domain.Entities;
using Portfolio.App.HistoricalPrice;
using Portfolio.App.HistoricalPrice.YahooFinance;
using Portfolio.Domain.Constants;

namespace Portfolio.App
{
    internal class Program
    {
        private static async Task Main(string[] args)
        {
            Log.Logger = new LoggerConfiguration()
                .Enrich.FromLogContext() // Allows you to add properties to the log context dynamically
                .WriteTo.Console()
                .WriteTo.File(new JsonFormatter(), "important.json", restrictedToMinimumLevel: LogEventLevel.Warning)
                .WriteTo.File("all-.logs", rollingInterval: RollingInterval.Day)
                .MinimumLevel.Debug()
                .CreateLogger();

            using (var reader = new StreamReader("sample.csv"))
            {
                var processor = KrakenCsvParser.Create(reader).Value;
                var transactions = processor.ExtractTransactions();


                var krakenWalletResult = Wallet.Create("kraken");
                if (krakenWalletResult.IsFailure)
                    throw new Exception(krakenWalletResult.Error);
                var krakenWallet = krakenWalletResult.Value;
                foreach (var t in transactions)
                {
                    krakenWallet.AddTransaction(t);
                }


                var storage = new SQLitePriceHistoryStorageService("crypto_price_history.db");


                var api = new YahooFinancePriceHistoryApi();
                var svc = new PriceHistoryService(api, storage, Strings.CURRENCY_USD);
                var portfolio = new Domain.Entities.UserPortfolio();

                portfolio.AddWallet(krakenWalletResult.Value);

                var processResult = await portfolio.CalculateTradesAsync(svc).ConfigureAwait(false);
                if (processResult.IsFailure)
                    throw new Exception(processResult.Error);


                foreach (var h in portfolio.Holdings.Where(h => h.Balance > 0))
                {
                    Log.Information($"Currency:{h.Asset}    Balance:{h.Balance:F2}     AvgPrice:{h.AverageBoughtPrice:F2}     Cost:{(h.Balance * h.AverageBoughtPrice):F2}     Value:{(h.Balance * h.CurrentPrice?.Amount):F2}");
                }
            }
        }






    }
}// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;

using System;
using System.Reflection;

[assembly: Microsoft.Extensions.Configuration.UserSecrets.UserSecretsIdAttribute("0f1f6528-1dbd-438c-9ca6-78a556e2c229")]
[assembly: System.Reflection.AssemblyCompanyAttribute("Portfolio.Api")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+b939afd4dad8882c516038f6d4d9b6d835809e0d")]
[assembly: System.Reflection.AssemblyProductAttribute("Portfolio.Api")]
[assembly: System.Reflection.AssemblyTitleAttribute("Portfolio.Api")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]



using System;
using System.Reflection;

[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Microsoft.AspNetCore.OpenApi")]
[assembly: Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute("Swashbuckle.AspNetCore.SwaggerGen")]


namespace Portfolio.Api
{
    public class WeatherForecast
    {
        public DateOnly Date { get; set; }

        public int TemperatureC { get; set; }

        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);

        public string? Summary { get; set; }
    }
}
using System.Security.Claims;
using Portfolio.Domain.Interfaces;

namespace Portfolio.Api;

public class CurrentUser : IUser
{
    private readonly IHttpContextAccessor _httpContextAccessor;

    public CurrentUser(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }

    public string? Id => _httpContextAccessor.HttpContext?.User?.FindFirstValue(ClaimTypes.NameIdentifier);
}using Microsoft.EntityFrameworkCore;
using Portfolio.App.DTOs;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Interfaces;
using Portfolio.Infrastructure;

namespace Portfolio.Api.Features
{
    public static class PortfolioEndpoints
    {
        public static void MapPortfolioEndpoints(this IEndpointRouteBuilder routes)
        {
            var group = routes.MapGroup("/portfolios");

            group.MapPost("/", async (PortfolioDbContext dbContext, PortfolioDto portfolio) =>
            {
                var up = new UserPortfolio();
                dbContext.Portfolios.Add(up);
                await dbContext.SaveChangesAsync();
                return Results.Created($"/portfolios/{up.Id}", portfolio);
            });

            group.MapGet("/{id:long}", async (PortfolioDbContext dbContext, long id) =>
            {
                var portfolio = await dbContext.Portfolios
                    .Include(p => p.Wallets)
                    .Include(p => p.Holdings)
                    .Include("Wallets.Transactions")
                    .FirstOrDefaultAsync(p => p.Id == id);

                return portfolio is not null ? Results.Ok(portfolio) : Results.NotFound();
            });

            group.MapGet("/", async (PortfolioDbContext dbContext) =>
            {
                var portfolios = await dbContext.Portfolios
                    .Include(p => p.Wallets)
                    .Include(p => p.Holdings)
                    .Include("Wallets.Transactions")
                    .ToListAsync();

                return Results.Ok(portfolios);
            });

            group.MapPut("/{id:long}", async (PortfolioDbContext dbContext, long id, UserPortfolio updatedPortfolio) =>
            {
                var portfolio = await dbContext.Portfolios.FindAsync(id);

                if (portfolio is null)
                {
                    return Results.NotFound();
                }

                dbContext.Entry(portfolio).CurrentValues.SetValues(updatedPortfolio);
                await dbContext.SaveChangesAsync();

                return Results.NoContent();
            });

            group.MapDelete("/{id:long}", async (PortfolioDbContext dbContext, long id) =>
            {
                var portfolio = await dbContext.Portfolios.FindAsync(id);

                if (portfolio is null)
                {
                    return Results.NotFound();
                }

                dbContext.Portfolios.Remove(portfolio);
                await dbContext.SaveChangesAsync();

                return Results.NoContent();
            });

            group.MapPost("/{id:long}/calculate-trades", async (PortfolioDbContext dbContext, IPriceHistoryService priceHistoryService, long id) =>
            {
                var portfolio = await dbContext.Portfolios
                    .Include(p => p.Holdings)
                    .Include("Wallets.Transactions")
                    .Include(p => p.FinancialEvents)                    
                    .FirstOrDefaultAsync(p => p.Id == id);

                if (portfolio is null)
                {
                    return Results.NotFound();
                }

                await portfolio.CalculateTradesAsync(priceHistoryService);
                await dbContext.SaveChangesAsync();

                return Results.Ok(portfolio);
            });
        }
    }
}
using Portfolio.App.DTOs;
using Portfolio.App.Services;

namespace Portfolio.Api.Features
{
    public static class WalletEndpoints
    {
        public static void MapWalletEndpoints(this IEndpointRouteBuilder routes)
        {
            var group = routes.MapGroup("/portfolios/{portfolioId:long}/wallets");

            group.MapGet("/{walletId:long}", async (IWalletService walletService, long portfolioId, long walletId) =>
            {
                var result = await walletService.GetWalletAsync(portfolioId, walletId);
                
                if (result.IsSuccess)
                {
                    return Results.Ok(result.Value);
                }
                return Results.NotFound(result.Error);
            });

            group.MapGet("/", async (IWalletService walletService, long portfolioId) =>
            {
                var result = await walletService.GetWalletsAsync(portfolioId);
                
                if (result.IsSuccess)
                {
                    return Results.Ok(result.Value);
                }
                return Results.NotFound(result.Error);
            });

            group.MapPost("/", async (IWalletService walletService, long portfolioId, WalletDto walletDto) =>
            {
                var result = await walletService.CreateWalletAsync(portfolioId, walletDto);

                if (result.IsSuccess)
                {
                    return Results.Created($"/portfolios/{portfolioId}/wallets/{result.Value}", result.Value);
                }
                return Results.BadRequest(result.Error);
            });

            group.MapDelete("/{walletId:long}", async (IWalletService walletService, long portfolioId, long walletId) =>
            {
                var result = await walletService.DeleteWalletAsync(portfolioId, walletId);

                if (result.IsSuccess)
                {
                    return Results.NoContent();
                }
                return Results.BadRequest(result.Error);
            });
        }


    }
}
using Microsoft.AspNetCore.Mvc;
using Portfolio.Api.Services;
using Portfolio.App;
using Portfolio.App.DTOs;

namespace Portfolio.Api.Features
{
    public static class TransactionEndpoints
    {
        public static void MapTransactionEndpoints(this IEndpointRouteBuilder routes)
        {
            var group = routes.MapGroup("/portfolios/{portfolioId:long}/wallets/{walletId:long}/transactions");

            group.MapPost("/", async (ICryptoTransactionService transactionService, long portfolioId, long walletId, CryptoCurrencyTransactionDto transactionDto) =>
            {
                var result = await transactionService.AddTransactionAsync(portfolioId, walletId, transactionDto);

                if (result.IsSuccess)
                {
                    return Results.Created($"/portfolios/{portfolioId}/wallets/{walletId}/transactions/{result.Value}", result.Value);
                }
                return Results.BadRequest(result.Error);
            });

            group.MapPut("/{transactionId:long}", async (ICryptoTransactionService transactionService, long portfolioId, long walletId, long transactionId, CryptoCurrencyTransactionDto transactionDto) =>
            {
                var result = await transactionService.UpdateTransactionAsync(portfolioId, walletId, transactionId, transactionDto);

                if (result.IsSuccess)
                {
                    return Results.NoContent();
                }
                return Results.BadRequest(result.Error);
            });

            group.MapPut("/bulk-edit", async (ICryptoTransactionService transactionService, long portfolioId, long walletId, [FromBody] List<CryptoCurrencyTransactionDto> transactionsToUpdate) =>
            {
                var result = await transactionService.BulkUpdateTransactionsAsync(portfolioId, walletId, transactionsToUpdate);

                if (result.IsSuccess)
                {
                    return Results.NoContent();
                }
                return Results.BadRequest(result.Error);
            });


            group.MapDelete("/{transactionId:long}", async (ICryptoTransactionService transactionService, long portfolioId, long walletId, long transactionId) =>
            {
                var result = await transactionService.DeleteTransactionAsync(portfolioId, walletId, transactionId);

                if (result.IsSuccess)
                {
                    return Results.NoContent();
                }
                return Results.BadRequest(result.Error);
            });

            group.MapDelete("/bulk-delete", async (ICryptoTransactionService transactionService, long portfolioId, long walletId, [FromBody] long[] transactionIds) =>
            {
                var result = await transactionService.BulkDeleteTransactionsAsync(portfolioId, walletId, transactionIds);

                if (result.IsSuccess)
                {
                    return Results.NoContent();
                }
                return Results.BadRequest(result.Error);
            });


            group.MapGet("/", async (ICryptoTransactionService transactionService, long portfolioId, long walletId) =>
            {
                var result = await transactionService.GetTransactionsAsync(portfolioId, walletId);

                if (result.IsSuccess)
                {
                    return Results.Ok(result.Value);
                }
                return Results.NotFound(result.Error);
            });

            group.MapGet("/{transactionId:long}", async (ICryptoTransactionService transactionService, long portfolioId, long walletId, long transactionId) =>
            {
                var result = await transactionService.GetTransactionAsync(portfolioId, walletId, transactionId);

                if (result.IsSuccess)
                {
                    return Results.Ok(result.Value);
                }
                return Results.NotFound(result.Error);
            });

            group.MapPost("/upload-csv", async (ICryptoTransactionService transactionService, long portfolioId, long walletId, CsvFileImportType csvImportType, IFormFile file) =>
            {
                using (var reader = new StreamReader(file.OpenReadStream()))
                {
                    var result = await transactionService.ImportTransactionsFromCsvAsync(portfolioId, walletId, App.CsvFileImportType.Kraken, reader);
                    if (result.IsSuccess)
                    {
                        return Results.Ok("Transactions imported successfully.");
                    }
                    return Results.BadRequest(result.Error);
                }
            })
#if DEBUG
            .DisableAntiforgery();
#endif
            ;
        }
    }
}
using Portfolio.Infrastructure.Data;

namespace Portfolio.Api;

public static class InitialiserExtensions
{
    public static async Task InitialiseDatabaseAsync(this WebApplication app)
    {
        using var scope = app.Services.CreateScope();

        var initialiser = scope.ServiceProvider.GetRequiredService<PortfolioDbContextInitialiser>();

        await initialiser.InitialiseAsync();

        await initialiser.SeedAsync();
    }
}using Portfolio.Api.Features;
using Portfolio.Api.Services;
using Portfolio.App;
using Portfolio.App.HistoricalPrice;
using Portfolio.App.HistoricalPrice.YahooFinance;
using Portfolio.App.Services;
using Portfolio.Domain.Interfaces;
using Portfolio.Infrastructure;


namespace Portfolio.Api
{
    public class Program
    {
        public static async Task Main(string[] args)
        {
            var builder = WebApplication.CreateBuilder(args);

            builder.Services.AddApplicationServices();
            builder.Services.AddInfrastructureServices(builder.Configuration);

            builder.Services.AddCors(options =>
            {
                options.AddPolicy("AllowSpecificOrigin",
                    builder => builder
                        .WithOrigins("http://localhost:3000") // Replace with your React app's URL
                        .AllowAnyHeader()
                        .AllowAnyMethod()
                        .AllowCredentials()); // Add this if you're using cookies or authentication
            });

            builder.Services.AddScoped<IUser, CurrentUser>();
            builder.Services.AddHttpContextAccessor();

            builder.Services.AddAuthorization();

            builder.Services.AddEndpointsApiExplorer();
            builder.Services.AddSwaggerGen();

            builder.Services.AddScoped<IWalletService, WalletService>();
            builder.Services.AddScoped<ICryptoTransactionService, CryptoTransactionService>();
            builder.Services.AddScoped<IPriceHistoryApi>(p => new PriceHistoryApiWithRetry(new YahooFinancePriceHistoryApi(), 3));
            builder.Services.AddScoped<IPriceHistoryService, PriceHistoryService>();
            builder.Services.AddScoped<IPriceHistoryStorageService>(s => new SQLitePriceHistoryStorageService("portfolio.db"));


            var app = builder.Build();

            app.UseCors("AllowSpecificOrigin");
            
            if (app.Environment.IsDevelopment())
            {
                app.UseSwagger();
                app.UseSwaggerUI();
            }

            app.UseHttpsRedirection();

            app.UseAuthorization();

            var summaries = new[]
            {
                "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
            };

            app.MapGet("/weatherforecast", (HttpContext httpContext) =>
            {
                var forecast = Enumerable.Range(1, 5).Select(index =>
                    new WeatherForecast
                    {
                        Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
                        TemperatureC = Random.Shared.Next(-20, 55),
                        Summary = summaries[Random.Shared.Next(summaries.Length)]
                    })
                    .ToArray();
                return forecast;
            })
            .WithName("GetWeatherForecast")
            .WithOpenApi();

            app.MapWalletEndpoints();
            app.MapPortfolioEndpoints();
            app.MapTransactionEndpoints();


            app.Run();
        }
    }
}
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Portfolio.Domain")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+b939afd4dad8882c516038f6d4d9b6d835809e0d")]
[assembly: System.Reflection.AssemblyProductAttribute("Portfolio.Domain")]
[assembly: System.Reflection.AssemblyTitleAttribute("Portfolio.Domain")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Portfolio.Domain.Tests")]


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Portfolio.Shared")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+9cb887642bcb17c71c06f2d64730127665cdee41")]
[assembly: System.Reflection.AssemblyProductAttribute("Portfolio.Shared")]
[assembly: System.Reflection.AssemblyTitleAttribute("Portfolio.Shared")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


using CSharpFunctionalExtensions;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Enums;

namespace Portfolio.Domain.Strategies.CostBasis
{
    public class LifoCostBasisCalculationStrategy : ICostBasisCalculationStrategy
    {
        public Result<decimal> CalculateCostBasis(AssetHolding holding, FinancialTransaction tx)
        {
            var sortedRecords = holding.PurchaseRecords.OrderByDescending(r => r.PurchaseDate).ToList();
            return CalculateCostFromRecords(sortedRecords, tx);
        }

        private Result<decimal> CalculateCostFromRecords(List<PurchaseRecord> sortedRecords, FinancialTransaction tx)
        {
            decimal totalCost = 0m;
            decimal amountToMatch = tx.SentAmount.Amount;

            foreach (var record in sortedRecords)
            {
                if (amountToMatch <= 0)
                    break;

                var matchAmount = Math.Min(record.Amount, amountToMatch);
                totalCost += matchAmount * record.PricePerUnit;
                amountToMatch -= matchAmount;
            }

            if (amountToMatch > 0)
            {
                tx.ErrorType = ErrorType.InsufficientFunds;
                tx.ErrorMessage = $"Insufficient holdings to match the transaction amount. Unable to match {amountToMatch} {tx.SentAmount.CurrencyCode}.";
                return Result.Failure<decimal>($"Insufficient holdings to match the transaction amount. Unable to match {amountToMatch} {tx.SentAmount.CurrencyCode}.");
            }

            return totalCost;
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Entities;

namespace Portfolio.Domain.Strategies.CostBasis
{
    public class AcbCostBasisCalculationStrategy : ICostBasisCalculationStrategy
    {
        public Result<decimal> CalculateCostBasis(AssetHolding holding, FinancialTransaction tx)
        {
            return holding.AverageBoughtPrice * tx.SentAmount.Amount;
        }
    }
}
using CSharpFunctionalExtensions;

namespace Portfolio.Domain.Entities
{
    public interface ICostBasisCalculationStrategy
    {
        Result<decimal> CalculateCostBasis(AssetHolding holding, FinancialTransaction tx);
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Enums;

namespace Portfolio.Domain.Strategies.CostBasis
{
    public class FifoCostBasisCalculationStrategy : ICostBasisCalculationStrategy
    {
        public Result<decimal> CalculateCostBasis(AssetHolding holding, FinancialTransaction tx)
        {
            var sortedRecords = holding.PurchaseRecords.OrderBy(r => r.PurchaseDate).ToList();
            return CalculateCostFromRecords(sortedRecords, tx);
        }

        private Result<decimal> CalculateCostFromRecords(List<PurchaseRecord> sortedRecords, FinancialTransaction tx)        
        {
            decimal totalCost = 0m;
            decimal amountToMatch = tx.SentAmount.Amount;

            foreach (var record in sortedRecords)
            {
                if (amountToMatch <= 0)
                    break;

                var matchAmount = Math.Min(record.Amount, amountToMatch);
                totalCost += matchAmount * record.PricePerUnit;
                amountToMatch -= matchAmount;
            }

            if (amountToMatch > 0)
            {
                tx.ErrorType = ErrorType.InsufficientFunds;
                tx.ErrorMessage = $"Insufficient holdings to match the transaction amount. Unable to match {amountToMatch} {tx.SentAmount.CurrencyCode}.";
                return Result.Failure<decimal>($"Insufficient holdings to match the transaction amount. Unable to match {amountToMatch} {tx.SentAmount.CurrencyCode}.");
            }

            return totalCost;
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Enums;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Strategies.Transactions
{
    public class WithdrawalTransactionStrategy : ITransactionStrategy
    {
        public async Task<Result> ProcessTransactionAsync(FinancialTransaction tx, UserPortfolio portfolio, IPriceHistoryService priceHistoryService)
        {
            if (!EnsureAboveZeroAmount(tx, false)) return Result.Failure(tx.ErrorMessage);

            var sender = portfolio.GetOrCreateHolding(tx.SentAmount.CurrencyCode);
            var priceResult = await priceHistoryService.GetPriceAtCloseTimeAsync(tx.SentAmount.CurrencyCode, tx.DateTime);

            decimal price;
            if (priceResult.IsSuccess)
            {
                price = priceResult.Value;
            }
            else
            {
                tx.ErrorType = ErrorType.PriceHistoryUnavailable;
                tx.ErrorMessage = $"Could not get price history for {sender.Asset}. Average price will be incorrect.";
                price = sender.AverageBoughtPrice;// Fallback to average bought price                
            }

            tx.ValueInDefaultCurrency = new Money(tx.SentAmount.Amount * price, portfolio.DefaultCurrency);

            portfolio.RecordFinancialEvent(tx, sender, price);            

            UpdateBalance(tx, sender);
            HandleFees(tx, portfolio, priceHistoryService);

            return Result.Success();
        }

        private async void HandleFees(FinancialTransaction tx, UserPortfolio portfolio, IPriceHistoryService priceHistoryService)
        {
            if (tx.FeeAmount != Money.Empty)
            {
                var fees = portfolio.GetOrCreateHolding(tx.FeeAmount.CurrencyCode);
                fees.Balance -= tx.FeeAmount.Amount;

                if (tx.FeeAmount.CurrencyCode == portfolio.DefaultCurrency)
                {
                    tx.FeeValueInDefaultCurrency = tx.FeeAmount;
                }
                else
                {
                    var feePriceResult = await priceHistoryService.GetPriceAtCloseTimeAsync(tx.FeeAmount.CurrencyCode, tx.DateTime);
                    if (feePriceResult.IsSuccess)
                    {
                        decimal feePrice = feePriceResult.Value;
                        tx.FeeValueInDefaultCurrency = new Money(tx.FeeAmount.Amount * feePrice, portfolio.DefaultCurrency);
                    }
                    else
                    {
                        tx.ErrorType = ErrorType.PriceHistoryUnavailable;
                        tx.ErrorMessage = $"Could not get price history for {fees.Asset} fees. Fees calculations will be incorrect.";
                    }
                }

                EnsureBalanceNotNegative(tx, fees.Asset, fees.Balance);
            }
        }

        private static void UpdateBalance(FinancialTransaction tx, AssetHolding sender)
        {
            sender.Balance -= tx.SentAmount.Amount;
            if (sender.Balance == 0)
                sender.AverageBoughtPrice = 0m;

            EnsureBalanceNotNegative(tx, sender.Asset, sender.Balance);
        }

        private static bool EnsureAboveZeroAmount(FinancialTransaction tx, bool incoming = true)
        {
            if (tx.SentAmount.Amount <= 0)
            {
                tx.ErrorMessage = $"Sent amount is zero or negative in withdrawal transaction: {tx.TransactionIds}";
                tx.ErrorType = ErrorType.InvalidCurrency;
                return false;
            }
            return true;
        }

        private static void EnsureBalanceNotNegative(FinancialTransaction tx, string asset, decimal balance)
        {
            if (balance < 0)
            {
                tx.ErrorType = ErrorType.InsufficientFunds;
                tx.ErrorMessage = $"{asset} balance is under zero: {balance}";
            }
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Enums;
using Portfolio.Domain.Events;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Strategies.Transactions
{
    public class TradeTransactionStrategy : ITransactionStrategy
    {
        public async Task<Result> ProcessTransactionAsync(FinancialTransaction tx, UserPortfolio portfolio, IPriceHistoryService priceHistoryService)
        {
            if (!EnsureAboveZeroAmount(tx)) return Result.Failure(tx.ErrorMessage);
            if (!EnsureAboveZeroAmount(tx, false)) return Result.Failure(tx.ErrorMessage);

            var receiver = portfolio.GetOrCreateHolding(tx.ReceivedAmount.CurrencyCode);
            var sender = portfolio.GetOrCreateHolding(tx.SentAmount.CurrencyCode);
            var priceResult = await priceHistoryService.GetPriceAtCloseTimeAsync(tx.SentAmount.CurrencyCode, tx.DateTime);

            decimal price;
            if (priceResult.IsSuccess)
            {
                price = priceResult.Value;
            }
            else
            {
                tx.ErrorType = ErrorType.PriceHistoryUnavailable;
                tx.ErrorMessage = $"Could not get price history for {sender.Asset}. Average price will be incorrect.";
                price = sender.AverageBoughtPrice;// Fallback to average bought price
            }

            var tradedCostInUsd = CalculateTradedCostInUsd(tx, portfolio, price);
            tx.ValueInDefaultCurrency = new Money(tradedCostInUsd, portfolio.DefaultCurrency);

            UpdateReceiverAverageBoughtPrice(tx, receiver);

            portfolio.RecordFinancialEvent(tx, sender, price);

            UpdateBalances(tx, receiver, sender);
            HandleFees(tx, portfolio, priceHistoryService);

            return Result.Success();
        }

        private static bool EnsureAboveZeroAmount(FinancialTransaction tx, bool incoming = true)
        {
            if (incoming && tx.ReceivedAmount.Amount <= 0 || !incoming && tx.SentAmount.Amount <= 0)
            {
                tx.ErrorMessage = $"Amount is zero or negative in trade transaction: {tx.TransactionIds}";
                tx.ErrorType = ErrorType.InvalidCurrency;
                return false;
            }
            return true;
        }

        private decimal CalculateTradedCostInUsd(FinancialTransaction tx, UserPortfolio portfolio, decimal price)
        {
            if (tx.ReceivedAmount.CurrencyCode == portfolio.DefaultCurrency)
            {
                return tx.ReceivedAmount.Amount;
            }
            else if (tx.SentAmount.CurrencyCode == portfolio.DefaultCurrency)
            {
                return tx.SentAmount.Amount;
            }
            else
            {
                return tx.SentAmount.Amount * price;
            }
        }

        private static void UpdateReceiverAverageBoughtPrice(FinancialTransaction tx, AssetHolding receiver)
        {
            receiver.AverageBoughtPrice = (receiver.AverageBoughtPrice * receiver.Balance + tx.ValueInDefaultCurrency.Amount) / (receiver.Balance + tx.ReceivedAmount.Amount);
        }

        private static void UpdateBalances(FinancialTransaction tx, AssetHolding receiver, AssetHolding sender)
        {
            receiver.Balance += tx.ReceivedAmount.Amount;
            sender.Balance -= tx.SentAmount.Amount;

            if (sender.Balance == 0)
                sender.AverageBoughtPrice = 0m;

            EnsureBalanceNotNegative(tx, sender.Asset, sender.Balance);
        }

        private async void HandleFees(FinancialTransaction tx, UserPortfolio portfolio, IPriceHistoryService priceHistoryService)
        {
            if (tx.FeeAmount == Money.Empty) return;

            var fees = portfolio.GetOrCreateHolding(tx.FeeAmount.CurrencyCode);

            bool shouldDeductFeesFromBalance = tx.FeeAmount.CurrencyCode != tx.ReceivedAmount.CurrencyCode;
            if (shouldDeductFeesFromBalance)
                fees.Balance -= tx.FeeAmount.Amount;

            if (tx.FeeAmount.CurrencyCode == portfolio.DefaultCurrency)
            {
                tx.FeeValueInDefaultCurrency = tx.FeeAmount;
            }
            else
            {
                var feePriceResult = await priceHistoryService.GetPriceAtCloseTimeAsync(tx.FeeAmount.CurrencyCode, tx.DateTime);
                if (feePriceResult.IsSuccess)
                {
                    decimal feePrice = feePriceResult.Value;
                    tx.FeeValueInDefaultCurrency = new Money(tx.FeeAmount.Amount * feePrice, portfolio.DefaultCurrency);
                }
                else
                {
                    tx.ErrorType = ErrorType.PriceHistoryUnavailable;
                    tx.ErrorMessage = $"Could not get price history for {fees.Asset} fees. Fees calculations will be incorrect.";
                }
            }

            EnsureBalanceNotNegative(tx, fees.Asset, fees.Balance);
        }

        private static void EnsureBalanceNotNegative(FinancialTransaction tx, string asset, decimal balance)
        {
            if (balance < 0)
            {
                tx.ErrorType = ErrorType.InsufficientFunds;
                tx.ErrorMessage = $"{asset} balance is under zero: {balance}";
            }
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Enums;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Strategies.Transactions
{
    public class DepositTransactionStrategy : ITransactionStrategy
    {
        public async Task<Result> ProcessTransactionAsync(FinancialTransaction tx, UserPortfolio portfolio, IPriceHistoryService priceHistoryService)
        {
            if (!EnsureAboveZeroAmount(tx)) return Result.Failure(tx.ErrorMessage);

            var receiver = portfolio.GetOrCreateHolding(tx.ReceivedAmount.CurrencyCode);
            receiver.Balance += tx.ReceivedAmount.Amount;

            if (tx.ReceivedAmount.CurrencyCode == portfolio.DefaultCurrency)
            {
                receiver.AverageBoughtPrice = 1;
                receiver.AddPurchase(tx.ReceivedAmount.Amount, 1, tx.DateTime);
                tx.ValueInDefaultCurrency = new Money(tx.ReceivedAmount.Amount, portfolio.DefaultCurrency);
            }
            else
            {
                var priceResult = await priceHistoryService.GetPriceAtCloseTimeAsync(tx.ReceivedAmount.CurrencyCode, tx.DateTime);
                if (priceResult.IsSuccess)
                {
                    decimal price = priceResult.Value;
                    tx.ValueInDefaultCurrency = new Money(tx.ReceivedAmount.Amount * price, portfolio.DefaultCurrency);
                    receiver.AverageBoughtPrice = (receiver.AverageBoughtPrice * (receiver.Balance - tx.ReceivedAmount.Amount) + tx.ValueInDefaultCurrency.Amount) / receiver.Balance;
                    receiver.AddPurchase(tx.ReceivedAmount.Amount, price, tx.DateTime);
                }
                else
                {
                    tx.ErrorType = ErrorType.PriceHistoryUnavailable;
                    tx.ErrorMessage = $"Could not get price history for {receiver.Asset}. Average price will be incorrect.";
                }
            }

            await FeeHandlingUtils.HandleFeesAsync(tx, portfolio, priceHistoryService);

            return Result.Success();
        }

        private static bool EnsureAboveZeroAmount(FinancialTransaction tx)
        {
            if (tx.ReceivedAmount.Amount <= 0)
            {
                tx.ErrorMessage = $"Received amount is zero or negative in deposit transaction: {tx.TransactionIds}";
                tx.ErrorType = ErrorType.InvalidCurrency;
                return false;
            }
            return true;
        }
    }
}
﻿namespace Portfolio.Domain.Constants
{
    public abstract class Roles
    {
        public const string Administrator = nameof(Administrator);
    }
}﻿namespace Portfolio.Domain.Constants
{
    public abstract class Policies
    {
        public const string CanPurge = nameof(CanPurge);
    }
}namespace Portfolio.Domain.Constants
{
    public class Strings
    {
        public const string DATE_FORMAT = "yyyy-MM-dd";
        public const string CURRENCY_USD = "USD";
    }

    public class Errors
    {
        public const string ERR_SAME_SYMBOLS = "Symbols must be of different currency/coin ({0}-{1}).";
        public const string ERR_YAHOO_API_FETCH_FAILURE = "An error occurred while fetching from Yahoo Finance API.";
    }
}namespace Portfolio.Domain.Enums
{
    public enum ErrorType
    {
        None, // No error
        PriceHistoryUnavailable, // Price history could not be retrieved
        InsufficientFunds, // Attempted to trade or withdraw more than available
        InvalidCurrency, // Currency code not recognized
        DataCorruption, // General data issues, possibly due to external factors
        ManualReviewRequired, // Generic case where user needs to inspect the transaction
        EventCreationFailed // When error creating tax event
    }
}
namespace Portfolio.Domain.Enums
{
    public enum TransactionType
    {
        Undefined,

        Trade,

        Deposit,

        Withdrawal,

        Fee
    }
}

public static class DateTimeExtensions
{
    public static DateTime TruncateToSecond(this DateTime dateTime)
    {
        return new DateTime(
            dateTime.Year,
            dateTime.Month,
            dateTime.Day,
            dateTime.Hour,
            dateTime.Minute,
            dateTime.Second,
            0, // Milliseconds set to 0
            dateTime.Kind); // Preserve the original DateTimeKind (Local, UTC, or Unspecified)
    }
}
using System.ComponentModel.DataAnnotations.Schema;

namespace Portfolio.Domain.Common
{
    public abstract class AggregateRoot : BaseAuditableEntity
    {
        private readonly List<BaseEvent> _domainEvents = new();

        [NotMapped]
        public IReadOnlyCollection<BaseEvent> DomainEvents => _domainEvents.AsReadOnly();

        public void AddDomainEvent(BaseEvent domainEvent)
        {
            _domainEvents.Add(domainEvent);
        }

        public void RemoveDomainEvent(BaseEvent domainEvent)
        {
            _domainEvents.Remove(domainEvent);
        }

        public void ClearDomainEvents()
        {
            _domainEvents.Clear();
        }
    }
}﻿namespace Portfolio.Domain.Common
{
    public abstract class BaseEntity
    {
        public long Id { get; set; }
    }
}
﻿using MediatR;

namespace Portfolio.Domain.Common
{
    public abstract class BaseEvent : INotification
    {
    }
}
﻿namespace Portfolio.Domain.Common
{
    public abstract class BaseAuditableEntity : BaseEntity
    {
        public DateTimeOffset Created { get; set; }

        public string? CreatedBy { get; set; }

        public DateTimeOffset LastModified { get; set; }

        public string? LastModifiedBy { get; set; }
    }
}
using Portfolio.Domain.Entities;
using Portfolio.Domain.Enums;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain
{
    public static class TransactionValidationUtils
    {
        public static bool EnsureAboveZeroAmount(FinancialTransaction tx, bool incoming = true)
        {
            if (incoming && tx.ReceivedAmount.Amount <= 0)
            {
                tx.ErrorMessage = $"Received amount is zero or negative in transaction: {tx.TransactionIds}";
                tx.ErrorType = ErrorType.InvalidCurrency;
                return false;
            }

            if (!incoming && tx.SentAmount.Amount <= 0)
            {
                tx.ErrorMessage = $"Sent amount is zero or negative in transaction: {tx.TransactionIds}";
                tx.ErrorType = ErrorType.InvalidCurrency;
                return false;
            }

            if (tx.FeeAmount.Amount < 0)
            {
                tx.ErrorMessage = $"Fee amount is negative in transaction: {tx.TransactionIds}";
                tx.ErrorType = ErrorType.InvalidCurrency;
                return false;
            }

            return true;
        }

        public static void EnsureBalanceNotNegative(FinancialTransaction tx, string asset, decimal balance)
        {
            if (balance < 0)
            {
                tx.ErrorType = ErrorType.InsufficientFunds;
                tx.ErrorMessage = $"{asset} balance is under zero: {balance}";
            }
        }
    }


    public static class FeeHandlingUtils
    {
        public static async Task HandleFeesAsync(FinancialTransaction tx, UserPortfolio portfolio, IPriceHistoryService priceHistoryService)
        {
            if (tx.FeeAmount == Money.Empty) return;

            var fees = portfolio.GetOrCreateHolding(tx.FeeAmount.CurrencyCode);

            bool shouldDeductFeesFromBalance = ShouldDeductFeesFromBalance(tx);
            if (shouldDeductFeesFromBalance)
                fees.Balance -= tx.FeeAmount.Amount;

            if (tx.FeeAmount.CurrencyCode == portfolio.DefaultCurrency)
            {
                tx.FeeValueInDefaultCurrency = tx.FeeAmount;
            }
            else
            {
                var feePriceResult = await priceHistoryService.GetPriceAtCloseTimeAsync(tx.FeeAmount.CurrencyCode, tx.DateTime);
                if (feePriceResult.IsSuccess)
                {
                    decimal feePrice = feePriceResult.Value;
                    tx.FeeValueInDefaultCurrency = new Money(tx.FeeAmount.Amount * feePrice, portfolio.DefaultCurrency);
                }
                else
                {
                    tx.ErrorType = ErrorType.PriceHistoryUnavailable;
                    tx.ErrorMessage = $"Could not get price history for {fees.Asset} fees. Fees calculations will be incorrect.";
                }
            }

            TransactionValidationUtils.EnsureBalanceNotNegative(tx, fees.Asset, fees.Balance);
        }

        private static bool ShouldDeductFeesFromBalance(FinancialTransaction tx)
        {
            return tx.FeeAmount.CurrencyCode != tx.ReceivedAmount.CurrencyCode || tx.Type == TransactionType.Withdrawal;
        }
    }
}
using Portfolio.Domain.Common;
using Portfolio.Domain.Entities;

namespace Portfolio.Domain.Events
{
    public class FinancialEventAdded : BaseEvent
    {
        public FinancialTransaction Transaction { get; }
        public AssetHolding Holding { get; }
        public decimal MarketPricePerUnit { get; }
        public string ErrorMessage { get; }

        public FinancialEventAdded(
            FinancialTransaction transaction,
            AssetHolding holding,
            decimal marketPricePerUnit,
            string errorMessage = "")
        {
            Transaction = transaction ?? throw new ArgumentNullException(nameof(transaction));
            Holding = holding ?? throw new ArgumentNullException(nameof(holding));
            MarketPricePerUnit = marketPricePerUnit;
            ErrorMessage = errorMessage ?? string.Empty;
        }

    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Enums;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.Strategies.Transactions;

namespace Portfolio.Domain.Services
{
    public class TransactionProcessor
    {
        private readonly Dictionary<TransactionType, ITransactionStrategy> _transactionStrategies;

        public TransactionProcessor()
        {
            _transactionStrategies = new Dictionary<TransactionType, ITransactionStrategy>
            {
                { TransactionType.Deposit, new DepositTransactionStrategy() },
                { TransactionType.Withdrawal, new WithdrawalTransactionStrategy() },
                { TransactionType.Trade, new TradeTransactionStrategy() }
            };
        }

        public async Task<Result> ProcessTransactionsAsync(IEnumerable<FinancialTransaction> transactions, UserPortfolio portfolio, IPriceHistoryService priceHistoryService)
        {
            foreach (var tx in transactions)
            {
                if (_transactionStrategies.TryGetValue(tx.Type, out var strategy))
                {
                    var result = await strategy.ProcessTransactionAsync(tx, portfolio, priceHistoryService);
                    if (result.IsFailure)
                    {
                        return result; // Optionally stop processing on failure
                    }
                }
                else
                {
                    return Result.Failure($"No strategy found for transaction type: {tx.Type}");
                }
            }

            return Result.Success();
        }
    }
}
using Portfolio.Domain.Common;
using Portfolio.Domain.Enums;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Entities
{
    public abstract class CryptoCurrencyTransaction : BaseAuditableEntity, ICryptoCurrencyTransaction
    {
        public Money UnitValue { get; set; }
        
        public DateTime DateTime { get; set; }

        public TransactionType Type { get; set; }

        public Money? FeeAmount { get; set; } = null!;

        public string Account { get; set; } = string.Empty;

        public string Note { get; set; } = string.Empty;

        public IEnumerable<string> TransactionIds { get; set; } = new List<string>();

        public Money Amount { get; set; }

        public object State { get; set; }

        protected CryptoCurrencyTransaction()
        { }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Common;
using Portfolio.Domain.Constants;
using Portfolio.Domain.Enums;
using Portfolio.Domain.Events;
using Portfolio.Domain.Interfaces;
using Portfolio.Domain.Services;
using Portfolio.Domain.Strategies.CostBasis;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Entities
{
    public class UserPortfolio : AggregateRoot
    {
        private readonly TransactionProcessor _transactionProcessor;
        private List<AssetHolding> _holdings = new();
        private List<Wallet> _wallets = new();
        private List<FinancialEvent> _financialEvents = new();
        private ICostBasisCalculationStrategy _costBasisStrategy = null!;
        private readonly Dictionary<string, ICostBasisCalculationStrategy> _costBasisStrategies = new()
        {
            { "AVG", new AcbCostBasisCalculationStrategy() },
            { "FIFO", new FifoCostBasisCalculationStrategy() },
            { "LIFO", new LifoCostBasisCalculationStrategy() }
        };

        public string DefaultCurrency { get; private set; } = Strings.CURRENCY_USD;

        public IReadOnlyCollection<Wallet> Wallets => _wallets.AsReadOnly();
        public IReadOnlyCollection<AssetHolding> Holdings => _holdings.AsReadOnly();
        public IReadOnlyCollection<FinancialEvent> FinancialEvents => _financialEvents.AsReadOnly();

        public UserPortfolio()
        {
            _transactionProcessor = new TransactionProcessor();
            SetCostBasisStrategy("AVG"); // Default to AVG
        }

        public void SetCostBasisStrategy(string strategy)
        {
            if (_costBasisStrategies.ContainsKey(strategy))
            {
                _costBasisStrategy = _costBasisStrategies[strategy];
            }
            else
            {
                throw new ArgumentException($"Cost basis strategy {strategy} not supported.");
            }
        }

        public Result AddWallet(Wallet wallet)
        {
            if (wallet == null)
                throw new ArgumentNullException(nameof(wallet));

            if (_wallets.Any(w => w.Name == wallet.Name))
                return Result.Failure("Wallet already exists.");

            _wallets.Add(wallet);

            return Result.Success();
        }

        public Result SetDefaultCurrency(string currencyCode)
        {
            currencyCode = currencyCode.ToUpper();
            if (!FiatCurrency.All.Any(f => f == currencyCode))
                return Result.Failure("Currency code unknown.");

            DefaultCurrency = currencyCode;

            return Result.Success();
        }

        public async Task<Result> CalculateTradesAsync(IPriceHistoryService priceHistoryService)
        {
            if (!Wallets.Any())
                return Result.Failure("No wallets to process. Start by adding a wallet.");

            var transactions = GetTransactionsFromAllWallets();
            var result = await _transactionProcessor.ProcessTransactionsAsync(transactions, this, priceHistoryService);

            if (result.IsFailure)
            {
                return result;
            }

            return Result.Success();
        }

        internal AssetHolding GetOrCreateHolding(string currencyCode)
        {
            var holding = _holdings.SingleOrDefault(h => h.Asset == currencyCode);
            if (holding == null)
            {
                holding = new AssetHolding(currencyCode);
                _holdings.Add(holding);
            }
            return holding;
        }

        internal void RecordFinancialEvent(
            FinancialTransaction transaction,
            AssetHolding holding,
            decimal marketPricePerUnit
        )
        {           
            if(transaction.Type == TransactionType.Deposit)
                return;

            if (transaction.SentAmount.IsFiatCurrency)
            {
                return;
            }

            Result result = Result.Success();

            var costBasisPerUnitResult = _costBasisStrategy.CalculateCostBasis(holding, transaction);
            if (costBasisPerUnitResult.IsFailure)
                result = Result.Failure(costBasisPerUnitResult.Error);
            else
            {
                var costBasisPerUnit = costBasisPerUnitResult.Value / transaction.SentAmount.Amount;

                var financialEventResult = FinancialEvent.Create(
                    transaction.DateTime,
                    transaction.SentAmount.CurrencyCode,
                    costBasisPerUnit,
                    marketPricePerUnit,
                    transaction.SentAmount.Amount,
                    DefaultCurrency
                );

                if (financialEventResult.IsSuccess)
                {
                    _financialEvents.Add(financialEventResult.Value);
                }
                else
                {
                    transaction.ErrorMessage = "Could not create financial event for this transaction.";
                    transaction.ErrorType = ErrorType.EventCreationFailed;
                    result = financialEventResult;
                }
            }

            AddDomainEvent(new FinancialEventAdded(transaction, holding, marketPricePerUnit, result.IsFailure ? result.Error: string.Empty));                    
        }

        private IEnumerable<FinancialTransaction> GetTransactionsFromAllWallets()
        {
            return _wallets.SelectMany(w => w.Transactions).OrderBy(t => t.DateTime).ToList();
        }
    }
}using Portfolio.Domain.Common;
using Portfolio.Domain.Enums;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Entities
{
    public class AssetHolding : BaseAuditableEntity
    {
        public string Asset { get; private set; }

        public decimal Balance { get; set; }

        public decimal AverageBoughtPrice { get; set; }

        public Money CurrentPrice { get; set; } = Money.Empty;

        public ErrorType ErrorType { get; set; } = ErrorType.None;

        public string ErrorMessage { get; set; } = string.Empty;

        public List<PurchaseRecord> PurchaseRecords { get; private set; } = new();

        public AssetHolding(string asset)
        {
            Asset = asset;
            Balance = 0;
            AverageBoughtPrice = 0;
        }

        public void AddPurchase(decimal amount, decimal pricePerUnit, DateTime purchaseDate)
        {
            PurchaseRecords.Add(new PurchaseRecord(amount, pricePerUnit, purchaseDate));            
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Common;
using Portfolio.Domain.Enums;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Entities
{
    public class FinancialTransaction : BaseAuditableEntity
    {
        public long WalletId { get; private set; }

        public DateTime DateTime { get; private set; }

        public TransactionType Type { get; init; }

        public Money ReceivedAmount { get; private set; } = Money.Empty;

        public Money SentAmount { get; private set; } = Money.Empty;

        public Money FeeAmount { get; private set; } = Money.Empty;

        public string Account { get; init; } = string.Empty;

        public string Note { get; private set; } = string.Empty;

        public IEnumerable<string>? TransactionIds { get; init; }

        public ErrorType ErrorType { get; set; } = ErrorType.None;

        public string ErrorMessage { get; set; } = string.Empty;

        public Money ValueInDefaultCurrency { get; set; } = Money.Empty;

        public Money FeeValueInDefaultCurrency { get; set; } = Money.Empty;

        public string CsvLinesJson { get; set; } = string.Empty;

        internal FinancialTransaction() { }

        public static Result<FinancialTransaction> CreateDeposit(
            DateTime date,
            Money receivedAmount,
            Money? feeAmount,
            string account,
            IEnumerable<string>? transactionIds,
            string note = "")
        {
            if (string.IsNullOrWhiteSpace(account))
                return Result.Failure<FinancialTransaction>($"Account cannot be null or whitespace.");

            var transaction = new FinancialTransaction()
            {
                Type = TransactionType.Deposit,
                Account = account,
                TransactionIds = transactionIds
            };

            return Result.Success(transaction)
                .Check(t => t.SetTransactionDate(date))
                .Check(t => t.SetNote(note))
                .Check(t => t.SetTransactionAmounts(receivedAmount, Money.Empty, feeAmount ?? Money.Empty));
        }

        public static Result<FinancialTransaction> CreateWithdraw(
            DateTime date,
            Money sentAmount,
            Money? feeAmount,
            string account,
            IEnumerable<string>? transactionIds,
            string note = "")
        {
            if (string.IsNullOrWhiteSpace(account))
                return Result.Failure<FinancialTransaction>($"Account cannot be null or whitespace.");

            var transaction = new FinancialTransaction()
            {
                Type = TransactionType.Withdrawal,
                Account = account,
                TransactionIds = transactionIds
            };

            return Result.Success(transaction)
                .Check(t => t.SetTransactionDate(date))
                .Check(t => t.SetNote(note))
                .Check(t => t.SetTransactionAmounts(Money.Empty, sentAmount, feeAmount ?? Money.Empty));
        }

        public static Result<FinancialTransaction> CreateTrade(
            DateTime date,
            Money receivedAmount,
            Money sentAmount,
            Money? feeAmount,
            string account,
            IEnumerable<string>? transactionIds,
            string note = "")
        {
            if (string.IsNullOrWhiteSpace(account))
                return Result.Failure<FinancialTransaction>("Account cannot be null or whitespace.");

            var transaction = new FinancialTransaction()
            {
                Type = TransactionType.Trade,
                Account = account,
                TransactionIds = transactionIds
            };

            return Result.Success(transaction)
                .Check(t => t.SetTransactionDate(date))
                .Check(t => t.SetNote(note))
                .Check(t => t.SetTransactionAmounts(receivedAmount, sentAmount, feeAmount ?? Money.Empty));
        }

        public Result SetTransactionAmounts(Money receivedAmount, Money sentAmount, Money feeAmount)
        {
            receivedAmount = receivedAmount ?? Money.Empty;
            sentAmount = sentAmount ?? Money.Empty;
            feeAmount = feeAmount ?? Money.Empty;

            if ((receivedAmount == Money.Empty || receivedAmount.Amount <= 0) && (Type == TransactionType.Deposit || Type == TransactionType.Trade))
                return Result.Failure<FinancialTransaction>($"Received amount must be greater than zero.");
            else if (receivedAmount.Amount > 0 && Type == TransactionType.Withdrawal)
                return Result.Failure($"Received amount cannot be set on a 'withdrawal' transaction.");

            if ((sentAmount == Money.Empty || sentAmount.Amount <= 0) && (Type == TransactionType.Withdrawal || Type == TransactionType.Trade))
                return Result.Failure<FinancialTransaction>($"Sent amount must be greater than zero.");
            else if (sentAmount.Amount > 0 && Type == TransactionType.Deposit)
                return Result.Failure($"Sent amount cannot be set on a 'deposit' transaction.");

            ReceivedAmount = receivedAmount;
            SentAmount = sentAmount;
            FeeAmount = feeAmount;

            return Result.Success();
        }

        public Result SetTransactionDate(DateTime date)
        {
            if (date == null || date == DateTime.MinValue)
                return Result.Failure("Transaction date is invalid.");

            DateTime = date.TruncateToSecond();

            return Result.Success();
        }

        public Result SetNote(string note)
        {
            if (note?.Length > 500)
                return Result.Failure("Note cannot be longer than 500 characters.");
            Note = note ?? string.Empty;

            return Result.Success();
        }

        public Money GetRelevantTransactionAmount()
        {
            return Type switch
            {
                TransactionType.Deposit => ReceivedAmount,
                TransactionType.Withdrawal => SentAmount,
                TransactionType.Trade => SentAmount, // Typically, SentAmount is used for trade cost basis
                _ => throw new NotSupportedException($"Transaction type {Type} is not supported.")
            };
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Entities
{
    public class CryptoCurrencyWithdrawTransaction : CryptoCurrencyTransaction
    {
        private CryptoCurrencyWithdrawTransaction()
        { }

        public static Result<CryptoCurrencyWithdrawTransaction> Create(
            DateTime date,
            Money amount,
            Money feeAmount,
            string account,
            IEnumerable<string> transactionIds,
            string note = "")
        {
            if (amount == null)
                return Result.Failure<CryptoCurrencyWithdrawTransaction>("Sent amount cannot be null for a withdrawal.");

            if (feeAmount == null)
                feeAmount = new Money(0, amount.CurrencyCode);
            else if (feeAmount.CurrencyCode != amount.CurrencyCode)
                return Result.Failure<CryptoCurrencyWithdrawTransaction>($"Fees are not in the same currency as the withdraw currency.");

            if (string.IsNullOrWhiteSpace(account))
                return Result.Failure<CryptoCurrencyWithdrawTransaction>("Account cannot be null or whitespace.");

            if (transactionIds == null || !transactionIds.Any())
                return Result.Failure<CryptoCurrencyWithdrawTransaction>("Transaction IDs cannot be null or empty.");

            var withdrawal = new CryptoCurrencyWithdrawTransaction()
            {
                DateTime = date,
                Amount = amount.ToAbsoluteAmountMoney(),
                FeeAmount = feeAmount.ToAbsoluteAmountMoney(),
                Account = account,
                TransactionIds = transactionIds,
                Note = note
            };

            return withdrawal;
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Common;

namespace Portfolio.Domain.Entities
{
    public class FinancialEvent : BaseAuditableEntity
    {
        public DateTime EventDate { get; private set; }

        public decimal CostBasisPerUnit { get; private set; }

        public decimal MarketPricePerUnit { get; private set; }

        public decimal FairMarketValue => MarketPricePerUnit * Amount;

        public decimal CapitalGain => FairMarketValue - (CostBasisPerUnit * Amount);

        public decimal Amount { get; private set; }

        public string AssetSymbol { get; set; } = string.Empty;

        public string BaseCurrency { get; set; } = string.Empty;

        private FinancialEvent() { }

        public static Result<FinancialEvent> Create(
            DateTime eventDate,
            string assetSymbol,
            decimal costBasisPerUnit,
            decimal marketPricePerUnit,
            decimal amount,
            string baseCurrency)
        {        
            return new FinancialEvent()
            {
                EventDate = eventDate,
                AssetSymbol = assetSymbol,
                CostBasisPerUnit = costBasisPerUnit,
                MarketPricePerUnit = marketPricePerUnit,            
                Amount = amount,
                BaseCurrency = baseCurrency
            };
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Entities
{
    public class CryptoCurrencyDepositTransaction : CryptoCurrencyTransaction
    {
        private CryptoCurrencyDepositTransaction()
        { }

        public static Result<CryptoCurrencyDepositTransaction> Create(
            DateTime date,
            Money receivedAmount,
            Money feeAmount,
            string account,
            IEnumerable<string> transactionIds,
            string note = "")
        {
            if (receivedAmount == null)
                return Result.Failure<CryptoCurrencyDepositTransaction>($"Received amount cannot be null for a deposit.");

            if (feeAmount == null)
                feeAmount = new Money(0, receivedAmount.CurrencyCode);
            else if (feeAmount.CurrencyCode != receivedAmount.CurrencyCode)
                return Result.Failure<CryptoCurrencyDepositTransaction>($"Fees are not in the same currency as the deposit currency.");

            if (string.IsNullOrWhiteSpace(account))
                return Result.Failure<CryptoCurrencyDepositTransaction>($"Account cannot be null or whitespace.");

            if (transactionIds == null || !transactionIds.Any())
                return Result.Failure<CryptoCurrencyDepositTransaction>($"Transaction IDs cannot be null or empty.");

            var deposit = new CryptoCurrencyDepositTransaction()
            {
                DateTime = date,
                Amount = receivedAmount.ToAbsoluteAmountMoney(),
                FeeAmount = feeAmount.ToAbsoluteAmountMoney(),
                Account = account,
                TransactionIds = transactionIds,
                Note = note
            };
            return deposit;
        }
    }
}
using Portfolio.Domain.Common;

namespace Portfolio.Domain.Entities
{
    public class PurchaseRecord : BaseAuditableEntity
    {
        public decimal Amount { get; private set; }

        public decimal PricePerUnit { get; private set; }

        public DateTime PurchaseDate { get; private set; }

        public PurchaseRecord(decimal amount, decimal pricePerUnit, DateTime purchaseDate)
        {
            Amount = amount;
            PricePerUnit = pricePerUnit;
            PurchaseDate = purchaseDate;
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Common;

namespace Portfolio.Domain.Entities
{
    public class Wallet : BaseAuditableEntity
    {
        public string Name { get; init; } = string.Empty;
        public long PortfolioId { get; set; }
        private readonly List<FinancialTransaction> _transactions = new();
        public IReadOnlyCollection<FinancialTransaction> Transactions => _transactions.AsReadOnly();

        private Wallet() { }

        public static Result<Wallet> Create(string walletName)
        {
            if (string.IsNullOrWhiteSpace(walletName)) return Result.Failure<Wallet>("Name cannot be empty.");

            return new Wallet
            {
                Name = walletName
            };
        }

        public Result AddTransaction(FinancialTransaction transaction)
        {
            if (transaction == null)
                return Result.Failure("Transaction cannot be null.");

            if (_transactions.Any(t => IsSameTransaction(t, transaction)))// || !_transactions.Add(transaction))
                return Result.Failure("Transaction already exists in this holding.");
            _transactions.Add(transaction);
            return Result.Success();
        }

        public Result RemoveTransaction(FinancialTransaction transaction)
        {
            if (transaction == null)
                return Result.Failure("Transaction cannot be null.");

            if (!_transactions.Remove(transaction))
            {
                return Result.Failure("Transaction not found in this holding.");
            }

            return Result.Success();
        }

        public bool IsSameTransaction(FinancialTransaction obj, FinancialTransaction other)
        {
            return obj.DateTime.TruncateToSecond() == other.DateTime.TruncateToSecond() &&
                   obj.Type == other.Type &&
                   Equals(obj.ReceivedAmount, other.ReceivedAmount) &&
                   Equals(obj.SentAmount, other.SentAmount) &&
                   Equals(obj.FeeAmount, other.FeeAmount);
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Entities
{
    public class CryptoCurrencyTradeTransaction : CryptoCurrencyTransaction
    {
        public Money TradeAmount { get; set; } = null!;

        private CryptoCurrencyTradeTransaction()
        { }

        public static Result<CryptoCurrencyTradeTransaction> Create(
            DateTime date,
            Money receivedAmount,
            Money sentAmount,
            Money feeAmount,
            string account,
            IEnumerable<string> transactionIds,
            string note = "")
        {
            if (receivedAmount == null)
                return Result.Failure<CryptoCurrencyTradeTransaction>("Received amount cannot be null for a trade transaction.");

            if (sentAmount == null)
                return Result.Failure<CryptoCurrencyTradeTransaction>("Sent amount cannot be null for a trade transaction.");

            if (string.IsNullOrWhiteSpace(account))
                return Result.Failure<CryptoCurrencyTradeTransaction>("Account cannot be null or whitespace.");

            if (transactionIds == null || !transactionIds.Any())
                return Result.Failure<CryptoCurrencyTradeTransaction>("Transaction IDs cannot be null or empty.");

            if (feeAmount == null)
                feeAmount = new Money(0, receivedAmount.CurrencyCode);

            var trade = new CryptoCurrencyTradeTransaction()
            {
                DateTime = date,
                Amount = receivedAmount.ToAbsoluteAmountMoney(),
                TradeAmount = sentAmount.ToAbsoluteAmountMoney(),
                FeeAmount = feeAmount.ToAbsoluteAmountMoney(),
                Account = account,
                TransactionIds = transactionIds,
                Note = note
            };
            return trade;
        }
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Interfaces
{
    public interface IPriceHistoryApi
    {
        string DetermineTradingPair(string fromSymbol, string toSymbol);

        Task<Result<IEnumerable<PriceRecord>>> FetchPriceHistoryAsync(string symbol, DateTime startDate, DateTime endDate);
    }
}
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Interfaces
{
    public interface ICryptoCurrencyTransaction
    {
        public DateTime DateTime { get; set; }

        public Money Amount { get; set; }

        public Money FeeAmount { get; set; }

        public string Account { get; set; }

        public string Note { get; set; }

        public IEnumerable<string> TransactionIds { get; set; }

        public object State { get; set; }


    }
}
using CSharpFunctionalExtensions;

namespace Portfolio.Domain.Interfaces
{
    public interface IPriceHistoryService
    {
        string DefaultCurrency { get; set; }

        Task<Result<decimal>> GetPriceAtCloseTimeAsync(string symbol, DateTime date);
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Domain.Interfaces
{
    public interface IPriceHistoryStorageService
    {
        Task<Result<IEnumerable<PriceRecord>>> LoadHistoryAsync(string symbol);

        Task<Result> SaveHistoryAsync(string symbol, IEnumerable<PriceRecord> priceHistory);
    }
}
using CSharpFunctionalExtensions;
using Portfolio.Domain.Entities;

namespace Portfolio.Domain.Interfaces
{
    public interface ITransactionStrategy
    {
        Task<Result> ProcessTransactionAsync(FinancialTransaction tx, UserPortfolio portfolio, IPriceHistoryService priceHistoryService);
    }
}﻿namespace Portfolio.Domain.Interfaces
{
    public interface IUser
    {
        string? Id { get; }
    }
}
using System.ComponentModel.DataAnnotations.Schema;
using CSharpFunctionalExtensions;

namespace Portfolio.Domain.ValueObjects
{
    public class Money : ValueObject
    {
        public static Money Empty => new Money(0, string.Empty);

        [NotMapped]
        public decimal Amount { get; private set; }//{ get => _amount ?? 0; private set => _amount = value == 0 ? new decimal?() : value; }

        public string CurrencyCode { get; private set; } = string.Empty;

        public bool IsFiatCurrency => FiatCurrency.All.Any(c => c == CurrencyCode);

        public decimal AbsoluteAmount => Math.Abs(Amount);

        public Money(decimal amount, string currencyCode)
        {
            Amount = amount;
            CurrencyCode = currencyCode ?? throw new ArgumentNullException(nameof(currencyCode));
        }

        public static Maybe<Money> Create(decimal? amount, string currencyCode)
        {
            if ((amount ?? 0) == 0 || string.IsNullOrWhiteSpace(currencyCode))
                return Maybe.None;
            return new Money(amount.GetValueOrDefault(), currencyCode);
        }

        public Money ToAbsoluteAmountMoney()
        {
            return new Money(AbsoluteAmount, CurrencyCode);
        }

        public Money Add(Money? other)
        {
            if (other == null)
                return this;

            if (CurrencyCode != other.CurrencyCode)
                throw new InvalidOperationException("Cannot add amounts in different currencies.");

            return new Money(Amount + other.Amount, CurrencyCode);
        }

        public Money Subtract(Money? other)
        {
            if (other == null)
                return this;

            if (CurrencyCode != other.CurrencyCode)
                throw new InvalidOperationException("Cannot subtract amounts in different currencies.");

            return new Money(Amount - other.Amount, CurrencyCode);
        }

        public override string ToString()
        {
            return $"{Amount:0.##} {CurrencyCode}";
        }

        protected override IEnumerable<IComparable> GetEqualityComponents()
        {
            yield return Amount;
            yield return CurrencyCode;
        }
    }
}
using CSharpFunctionalExtensions;

namespace Portfolio.Domain.ValueObjects
{
    public class FiatCurrency : EnumValueObject<FiatCurrency>
    {
        public static readonly FiatCurrency USD = new FiatCurrency("USD");
        public static readonly FiatCurrency EUR = new FiatCurrency("EUR");
        public static readonly FiatCurrency JPY = new FiatCurrency("JPY");
        public static readonly FiatCurrency GBP = new FiatCurrency("GBP");
        public static readonly FiatCurrency AUD = new FiatCurrency("AUD");
        public static readonly FiatCurrency CAD = new FiatCurrency("CAD");
        public static readonly FiatCurrency CHF = new FiatCurrency("CHF");
        public static readonly FiatCurrency CNY = new FiatCurrency("CNY");
        public static readonly FiatCurrency SEK = new FiatCurrency("SEK");
        public static readonly FiatCurrency NZD = new FiatCurrency("NZD");
        public static readonly FiatCurrency MXN = new FiatCurrency("MXN");
        public static readonly FiatCurrency SGD = new FiatCurrency("SGD");
        public static readonly FiatCurrency HKD = new FiatCurrency("HKD");
        public static readonly FiatCurrency NOK = new FiatCurrency("NOK");
        public static readonly FiatCurrency KRW = new FiatCurrency("KRW");
        public static readonly FiatCurrency TRY = new FiatCurrency("TRY");
        public static readonly FiatCurrency RUB = new FiatCurrency("RUB");
        public static readonly FiatCurrency INR = new FiatCurrency("INR");
        public static readonly FiatCurrency BRL = new FiatCurrency("BRL");
        public static readonly FiatCurrency ZAR = new FiatCurrency("ZAR");
        public static readonly FiatCurrency AOA = new FiatCurrency("AOA");
        public static readonly FiatCurrency ARS = new FiatCurrency("ARS");
        public static readonly FiatCurrency BND = new FiatCurrency("BND");
        public static readonly FiatCurrency BZD = new FiatCurrency("BZD");
        public static readonly FiatCurrency CLP = new FiatCurrency("CLP");
        public static readonly FiatCurrency COP = new FiatCurrency("COP");
        public static readonly FiatCurrency CRC = new FiatCurrency("CRC");
        public static readonly FiatCurrency CZK = new FiatCurrency("CZK");
        public static readonly FiatCurrency DJF = new FiatCurrency("DJF");
        public static readonly FiatCurrency DKK = new FiatCurrency("DKK");
        public static readonly FiatCurrency DOP = new FiatCurrency("DOP");
        public static readonly FiatCurrency FJD = new FiatCurrency("FJD");
        public static readonly FiatCurrency FKP = new FiatCurrency("FKP");
        public static readonly FiatCurrency GEL = new FiatCurrency("GEL");
        public static readonly FiatCurrency GTQ = new FiatCurrency("GTQ");
        public static readonly FiatCurrency HNL = new FiatCurrency("HNL");
        public static readonly FiatCurrency HUF = new FiatCurrency("HUF");
        public static readonly FiatCurrency IDR = new FiatCurrency("IDR");
        public static readonly FiatCurrency ILS = new FiatCurrency("ILS");
        public static readonly FiatCurrency ISK = new FiatCurrency("ISK");
        public static readonly FiatCurrency KES = new FiatCurrency("KES");
        public static readonly FiatCurrency KGS = new FiatCurrency("KGS");
        public static readonly FiatCurrency KMF = new FiatCurrency("KMF");
        public static readonly FiatCurrency KZT = new FiatCurrency("KZT");
        public static readonly FiatCurrency MDL = new FiatCurrency("MDL");
        public static readonly FiatCurrency MGA = new FiatCurrency("MGA");
        public static readonly FiatCurrency MRU = new FiatCurrency("MRU");
        public static readonly FiatCurrency MWK = new FiatCurrency("MWK");
        public static readonly FiatCurrency MYR = new FiatCurrency("MYR");
        public static readonly FiatCurrency OMR = new FiatCurrency("OMR");
        public static readonly FiatCurrency PEN = new FiatCurrency("PEN");
        public static readonly FiatCurrency PGK = new FiatCurrency("PGK");
        public static readonly FiatCurrency PHP = new FiatCurrency("PHP");
        public static readonly FiatCurrency PLN = new FiatCurrency("PLN");
        public static readonly FiatCurrency PYG = new FiatCurrency("PYG");
        public static readonly FiatCurrency RON = new FiatCurrency("RON");
        public static readonly FiatCurrency RWF = new FiatCurrency("RWF");
        public static readonly FiatCurrency SBD = new FiatCurrency("SBD");
        public static readonly FiatCurrency SCR = new FiatCurrency("SCR");
        public static readonly FiatCurrency SRD = new FiatCurrency("SRD");
        public static readonly FiatCurrency STN = new FiatCurrency("STN");
        public static readonly FiatCurrency SZL = new FiatCurrency("SZL");
        public static readonly FiatCurrency TJS = new FiatCurrency("TJS");
        public static readonly FiatCurrency TMT = new FiatCurrency("TMT");
        public static readonly FiatCurrency TOP = new FiatCurrency("TOP");
        public static readonly FiatCurrency UYU = new FiatCurrency("UYU");
        public static readonly FiatCurrency VND = new FiatCurrency("VND");
        public static readonly FiatCurrency XCD = new FiatCurrency("XCD");

        private FiatCurrency(string code) : base(code) { }
    }
}
using CSharpFunctionalExtensions;

namespace Portfolio.Domain.ValueObjects
{
    public class PriceRecord : ValueObject
    {
        public string CurrencyPair { get; set; } = string.Empty;

        public DateTime CloseDate { get; set; }

        public decimal ClosePrice { get; set; }

        protected override IEnumerable<IComparable> GetEqualityComponents()
        {
            yield return CurrencyPair;
            yield return CloseDate;
            yield return ClosePrice;
        }
    }
}
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Portfolio.Infrastructure")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+b939afd4dad8882c516038f6d4d9b6d835809e0d")]
[assembly: System.Reflection.AssemblyProductAttribute("Portfolio.Infrastructure")]
[assembly: System.Reflection.AssemblyTitleAttribute("Portfolio.Infrastructure")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    [Migration("20240820004525_Initial1")]
    partial class Initial1
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("decimal(18,8)");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AveragePriceAtTime")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal?>("BalanceAfterTransaction")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("WalletName")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyProcessedTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .IsRequired()
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long?>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long>("PortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("PortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("ProcessedTransactions")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId");

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount");

                    b.Navigation("ReceivedAmount");

                    b.Navigation("SentAmount");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("PortfolioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("ProcessedTransactions");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    public partial class InitialMigration8 : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<int>(
                name: "ErrorType",
                table: "CryptoCurrencyRawTransactions",
                type: "INTEGER",
                nullable: false,
                defaultValue: 0);

            migrationBuilder.AlterColumn<decimal>(
                name: "AverageBoughtPrice",
                table: "CryptoCurrencyHoldings",
                type: "decimal(18,8)",
                nullable: false,
                defaultValue: 0m,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)",
                oldNullable: true);

            migrationBuilder.AddColumn<decimal>(
                name: "Fees",
                table: "CryptoCurrencyHoldings",
                type: "decimal(18,8)",
                nullable: false,
                defaultValue: 0m);

            migrationBuilder.AddColumn<decimal>(
                name: "SentAmount",
                table: "CryptoCurrencyHoldings",
                type: "decimal(18,8)",
                nullable: false,
                defaultValue: 0m);

            migrationBuilder.AddColumn<string>(
                name: "SentCurrency",
                table: "CryptoCurrencyHoldings",
                type: "TEXT",
                maxLength: 3,
                nullable: false,
                defaultValue: "");
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "ErrorType",
                table: "CryptoCurrencyRawTransactions");

            migrationBuilder.DropColumn(
                name: "Fees",
                table: "CryptoCurrencyHoldings");

            migrationBuilder.DropColumn(
                name: "SentAmount",
                table: "CryptoCurrencyHoldings");

            migrationBuilder.DropColumn(
                name: "SentCurrency",
                table: "CryptoCurrencyHoldings");

            migrationBuilder.AlterColumn<decimal>(
                name: "AverageBoughtPrice",
                table: "CryptoCurrencyHoldings",
                type: "decimal(18,8)",
                nullable: true,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)");
        }
    }
}
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    public partial class InitialMigration6 : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {

        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {

        }
    }
}
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    partial class PortfolioDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("ErrorMessage")
                        .IsRequired()
                        .HasMaxLength(250)
                        .HasColumnType("TEXT");

                    b.Property<int>("ErrorType")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("CsvLinesJson")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<string>("ErrorMessage")
                        .IsRequired()
                        .HasMaxLength(250)
                        .HasColumnType("TEXT");

                    b.Property<int>("ErrorType")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.PurchaseRecord", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("CryptoCurrencyHoldingId")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<decimal>("PricePerUnit")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("PurchaseDate")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("CryptoCurrencyHoldingId");

                    b.ToTable("PurchaseRecord");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.TaxableEvent", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("AverageCost")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Currency")
                        .IsRequired()
                        .HasMaxLength(5)
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<string>("DisposedAsset")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<decimal>("Quantity")
                        .HasColumnType("decimal(18,8)");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("ValueAtDisposal")
                        .HasColumnType("decimal(18,8)");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("TaxableEvents", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("DefaultCurrency")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long>("PortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("PortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "CurrentPrice", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyHoldingId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyHoldingId");

                            b1.ToTable("CryptoCurrencyHoldings");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyHoldingId");
                        });

                    b.Navigation("CurrentPrice")
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeValueInDefaultCurrency", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ValueInDefaultCurrency", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount")
                        .IsRequired();

                    b.Navigation("FeeValueInDefaultCurrency")
                        .IsRequired();

                    b.Navigation("ReceivedAmount")
                        .IsRequired();

                    b.Navigation("SentAmount")
                        .IsRequired();

                    b.Navigation("ValueInDefaultCurrency")
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.PurchaseRecord", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.CryptoCurrencyHolding", null)
                        .WithMany("PurchaseRecords")
                        .HasForeignKey("CryptoCurrencyHoldingId");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.TaxableEvent", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("TaxableEvents")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("PortfolioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Navigation("PurchaseRecords");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("TaxableEvents");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    [Migration("20240824030639_InitialMigration9")]
    partial class InitialMigration9
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("ErrorMessage")
                        .IsRequired()
                        .HasMaxLength(250)
                        .HasColumnType("TEXT");

                    b.Property<int>("ErrorType")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("CsvLinesJson")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<string>("ErrorMessage")
                        .IsRequired()
                        .HasMaxLength(250)
                        .HasColumnType("TEXT");

                    b.Property<int>("ErrorType")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.PurchaseRecord", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("CryptoCurrencyHoldingId")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<decimal>("PricePerUnit")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("PurchaseDate")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("CryptoCurrencyHoldingId");

                    b.ToTable("PurchaseRecord");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.TaxableEvent", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("AverageCost")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Currency")
                        .IsRequired()
                        .HasMaxLength(5)
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<string>("DisposedAsset")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<decimal>("Quantity")
                        .HasColumnType("decimal(18,8)");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("ValueAtDisposal")
                        .HasColumnType("decimal(18,8)");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("TaxableEvents", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("DefaultCurrency")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long>("PortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("PortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "CurrentPrice", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyHoldingId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyHoldingId");

                            b1.ToTable("CryptoCurrencyHoldings");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyHoldingId");
                        });

                    b.Navigation("CurrentPrice")
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeValueInDefaultCurrency", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ValueInDefaultCurrency", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount")
                        .IsRequired();

                    b.Navigation("FeeValueInDefaultCurrency")
                        .IsRequired();

                    b.Navigation("ReceivedAmount")
                        .IsRequired();

                    b.Navigation("SentAmount")
                        .IsRequired();

                    b.Navigation("ValueInDefaultCurrency")
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.PurchaseRecord", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.CryptoCurrencyHolding", null)
                        .WithMany("PurchaseRecords")
                        .HasForeignKey("CryptoCurrencyHoldingId");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.TaxableEvent", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("TaxableEvents")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("PortfolioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Navigation("PurchaseRecords");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("TaxableEvents");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    [Migration("20240822144610_InitialMigration6")]
    partial class InitialMigration6
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("TEXT");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AveragePriceAtTime")
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("BalanceAfterTransaction")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("WalletName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyProcessedTransaction");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("CsvLinesJson")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long>("PortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("PortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("ProcessedTransactions")
                        .HasForeignKey("UserPortfolioId");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount")
                        .IsRequired();

                    b.Navigation("ReceivedAmount")
                        .IsRequired();

                    b.Navigation("SentAmount")
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("PortfolioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("ProcessedTransactions");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    public partial class Initial : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "AspNetRoles",
                columns: table => new
                {
                    Id = table.Column<string>(type: "TEXT", nullable: false),
                    Name = table.Column<string>(type: "TEXT", maxLength: 256, nullable: true),
                    NormalizedName = table.Column<string>(type: "TEXT", maxLength: 256, nullable: true),
                    ConcurrencyStamp = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetRoles", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "AspNetUsers",
                columns: table => new
                {
                    Id = table.Column<string>(type: "TEXT", nullable: false),
                    UserName = table.Column<string>(type: "TEXT", maxLength: 256, nullable: true),
                    NormalizedUserName = table.Column<string>(type: "TEXT", maxLength: 256, nullable: true),
                    Email = table.Column<string>(type: "TEXT", maxLength: 256, nullable: true),
                    NormalizedEmail = table.Column<string>(type: "TEXT", maxLength: 256, nullable: true),
                    EmailConfirmed = table.Column<bool>(type: "INTEGER", nullable: false),
                    PasswordHash = table.Column<string>(type: "TEXT", nullable: true),
                    SecurityStamp = table.Column<string>(type: "TEXT", nullable: true),
                    ConcurrencyStamp = table.Column<string>(type: "TEXT", nullable: true),
                    PhoneNumber = table.Column<string>(type: "TEXT", nullable: true),
                    PhoneNumberConfirmed = table.Column<bool>(type: "INTEGER", nullable: false),
                    TwoFactorEnabled = table.Column<bool>(type: "INTEGER", nullable: false),
                    LockoutEnd = table.Column<DateTimeOffset>(type: "TEXT", nullable: true),
                    LockoutEnabled = table.Column<bool>(type: "INTEGER", nullable: false),
                    AccessFailedCount = table.Column<int>(type: "INTEGER", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetUsers", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "UserPortfolios",
                columns: table => new
                {
                    Id = table.Column<long>(type: "INTEGER", nullable: false)
                        .Annotation("Sqlite:Autoincrement", true),
                    Created = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    CreatedBy = table.Column<string>(type: "TEXT", nullable: true),
                    LastModified = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    LastModifiedBy = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_UserPortfolios", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "AspNetRoleClaims",
                columns: table => new
                {
                    Id = table.Column<int>(type: "INTEGER", nullable: false)
                        .Annotation("Sqlite:Autoincrement", true),
                    RoleId = table.Column<string>(type: "TEXT", nullable: false),
                    ClaimType = table.Column<string>(type: "TEXT", nullable: true),
                    ClaimValue = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetRoleClaims", x => x.Id);
                    table.ForeignKey(
                        name: "FK_AspNetRoleClaims_AspNetRoles_RoleId",
                        column: x => x.RoleId,
                        principalTable: "AspNetRoles",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "AspNetUserClaims",
                columns: table => new
                {
                    Id = table.Column<int>(type: "INTEGER", nullable: false)
                        .Annotation("Sqlite:Autoincrement", true),
                    UserId = table.Column<string>(type: "TEXT", nullable: false),
                    ClaimType = table.Column<string>(type: "TEXT", nullable: true),
                    ClaimValue = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetUserClaims", x => x.Id);
                    table.ForeignKey(
                        name: "FK_AspNetUserClaims_AspNetUsers_UserId",
                        column: x => x.UserId,
                        principalTable: "AspNetUsers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "AspNetUserLogins",
                columns: table => new
                {
                    LoginProvider = table.Column<string>(type: "TEXT", nullable: false),
                    ProviderKey = table.Column<string>(type: "TEXT", nullable: false),
                    ProviderDisplayName = table.Column<string>(type: "TEXT", nullable: true),
                    UserId = table.Column<string>(type: "TEXT", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetUserLogins", x => new { x.LoginProvider, x.ProviderKey });
                    table.ForeignKey(
                        name: "FK_AspNetUserLogins_AspNetUsers_UserId",
                        column: x => x.UserId,
                        principalTable: "AspNetUsers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "AspNetUserRoles",
                columns: table => new
                {
                    UserId = table.Column<string>(type: "TEXT", nullable: false),
                    RoleId = table.Column<string>(type: "TEXT", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetUserRoles", x => new { x.UserId, x.RoleId });
                    table.ForeignKey(
                        name: "FK_AspNetUserRoles_AspNetRoles_RoleId",
                        column: x => x.RoleId,
                        principalTable: "AspNetRoles",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_AspNetUserRoles_AspNetUsers_UserId",
                        column: x => x.UserId,
                        principalTable: "AspNetUsers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "AspNetUserTokens",
                columns: table => new
                {
                    UserId = table.Column<string>(type: "TEXT", nullable: false),
                    LoginProvider = table.Column<string>(type: "TEXT", nullable: false),
                    Name = table.Column<string>(type: "TEXT", nullable: false),
                    Value = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetUserTokens", x => new { x.UserId, x.LoginProvider, x.Name });
                    table.ForeignKey(
                        name: "FK_AspNetUserTokens_AspNetUsers_UserId",
                        column: x => x.UserId,
                        principalTable: "AspNetUsers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "CryptoCurrencyHoldings",
                columns: table => new
                {
                    Id = table.Column<long>(type: "INTEGER", nullable: false)
                        .Annotation("Sqlite:Autoincrement", true),
                    Asset = table.Column<string>(type: "TEXT", maxLength: 10, nullable: false),
                    Balance = table.Column<decimal>(type: "decimal(18,8)", nullable: false),
                    AverageBoughtPrice = table.Column<decimal>(type: "decimal(18,8)", nullable: true),
                    UserPortfolioId = table.Column<long>(type: "INTEGER", nullable: true),
                    Created = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    CreatedBy = table.Column<string>(type: "TEXT", nullable: true),
                    LastModified = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    LastModifiedBy = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CryptoCurrencyHoldings", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CryptoCurrencyHoldings_UserPortfolios_UserPortfolioId",
                        column: x => x.UserPortfolioId,
                        principalTable: "UserPortfolios",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "CryptoCurrencyProcessedTransactions",
                columns: table => new
                {
                    Id = table.Column<long>(type: "INTEGER", nullable: false)
                        .Annotation("Sqlite:Autoincrement", true),
                    WalletName = table.Column<string>(type: "TEXT", maxLength: 100, nullable: false),
                    Asset = table.Column<string>(type: "TEXT", maxLength: 10, nullable: false),
                    Amount = table.Column<decimal>(type: "decimal(18,8)", nullable: false),
                    DateTime = table.Column<DateTime>(type: "TEXT", nullable: false),
                    AveragePriceAtTime = table.Column<decimal>(type: "decimal(18,8)", nullable: true),
                    BalanceAfterTransaction = table.Column<decimal>(type: "decimal(18,8)", nullable: true),
                    UserPortfolioId = table.Column<long>(type: "INTEGER", nullable: true),
                    Created = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    CreatedBy = table.Column<string>(type: "TEXT", nullable: true),
                    LastModified = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    LastModifiedBy = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CryptoCurrencyProcessedTransactions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CryptoCurrencyProcessedTransactions_UserPortfolios_UserPortfolioId",
                        column: x => x.UserPortfolioId,
                        principalTable: "UserPortfolios",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Wallets",
                columns: table => new
                {
                    Id = table.Column<long>(type: "INTEGER", nullable: false)
                        .Annotation("Sqlite:Autoincrement", true),
                    Name = table.Column<string>(type: "TEXT", maxLength: 100, nullable: false),
                    UserPortfolioId = table.Column<long>(type: "INTEGER", nullable: true),
                    Created = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    CreatedBy = table.Column<string>(type: "TEXT", nullable: true),
                    LastModified = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    LastModifiedBy = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Wallets", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Wallets_UserPortfolios_UserPortfolioId",
                        column: x => x.UserPortfolioId,
                        principalTable: "UserPortfolios",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "CryptoCurrencyRawTransactions",
                columns: table => new
                {
                    Id = table.Column<long>(type: "INTEGER", nullable: false)
                        .Annotation("Sqlite:Autoincrement", true),
                    DateTime = table.Column<DateTime>(type: "TEXT", nullable: false),
                    Type = table.Column<int>(type: "INTEGER", nullable: false),
                    ReceivedAmount = table.Column<decimal>(type: "decimal(18,8)", nullable: true),
                    ReceivedAmountCurrency = table.Column<string>(type: "TEXT", maxLength: 3, nullable: true),
                    SentAmount = table.Column<decimal>(type: "decimal(18,8)", nullable: true),
                    SentAmountCurrency = table.Column<string>(type: "TEXT", maxLength: 3, nullable: true),
                    FeeAmount = table.Column<decimal>(type: "decimal(18,8)", nullable: true),
                    FeeAmountCurrency = table.Column<string>(type: "TEXT", maxLength: 3, nullable: true),
                    Account = table.Column<string>(type: "TEXT", maxLength: 100, nullable: false),
                    Note = table.Column<string>(type: "TEXT", maxLength: 500, nullable: false),
                    TransactionIds = table.Column<string>(type: "TEXT", nullable: false),
                    WalletId = table.Column<long>(type: "INTEGER", nullable: true),
                    Created = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    CreatedBy = table.Column<string>(type: "TEXT", nullable: true),
                    LastModified = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    LastModifiedBy = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CryptoCurrencyRawTransactions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CryptoCurrencyRawTransactions_Wallets_WalletId",
                        column: x => x.WalletId,
                        principalTable: "Wallets",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateIndex(
                name: "IX_AspNetRoleClaims_RoleId",
                table: "AspNetRoleClaims",
                column: "RoleId");

            migrationBuilder.CreateIndex(
                name: "RoleNameIndex",
                table: "AspNetRoles",
                column: "NormalizedName",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_AspNetUserClaims_UserId",
                table: "AspNetUserClaims",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_AspNetUserLogins_UserId",
                table: "AspNetUserLogins",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_AspNetUserRoles_RoleId",
                table: "AspNetUserRoles",
                column: "RoleId");

            migrationBuilder.CreateIndex(
                name: "EmailIndex",
                table: "AspNetUsers",
                column: "NormalizedEmail");

            migrationBuilder.CreateIndex(
                name: "UserNameIndex",
                table: "AspNetUsers",
                column: "NormalizedUserName",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_CryptoCurrencyHoldings_UserPortfolioId",
                table: "CryptoCurrencyHoldings",
                column: "UserPortfolioId");

            migrationBuilder.CreateIndex(
                name: "IX_CryptoCurrencyProcessedTransactions_UserPortfolioId",
                table: "CryptoCurrencyProcessedTransactions",
                column: "UserPortfolioId");

            migrationBuilder.CreateIndex(
                name: "IX_CryptoCurrencyRawTransactions_WalletId",
                table: "CryptoCurrencyRawTransactions",
                column: "WalletId");

            migrationBuilder.CreateIndex(
                name: "IX_Wallets_UserPortfolioId",
                table: "Wallets",
                column: "UserPortfolioId");
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "AspNetRoleClaims");

            migrationBuilder.DropTable(
                name: "AspNetUserClaims");

            migrationBuilder.DropTable(
                name: "AspNetUserLogins");

            migrationBuilder.DropTable(
                name: "AspNetUserRoles");

            migrationBuilder.DropTable(
                name: "AspNetUserTokens");

            migrationBuilder.DropTable(
                name: "CryptoCurrencyHoldings");

            migrationBuilder.DropTable(
                name: "CryptoCurrencyProcessedTransactions");

            migrationBuilder.DropTable(
                name: "CryptoCurrencyRawTransactions");

            migrationBuilder.DropTable(
                name: "AspNetRoles");

            migrationBuilder.DropTable(
                name: "AspNetUsers");

            migrationBuilder.DropTable(
                name: "Wallets");

            migrationBuilder.DropTable(
                name: "UserPortfolios");
        }
    }
}
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    public partial class InitialMigration2 : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterColumn<string>(
                name: "TransactionIds",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                nullable: true,
                oldClrType: typeof(string),
                oldType: "TEXT");

            migrationBuilder.AddColumn<string>(
                name: "CsvLinesJson",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                nullable: false,
                defaultValue: "");
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "CsvLinesJson",
                table: "CryptoCurrencyRawTransactions");

            migrationBuilder.AlterColumn<string>(
                name: "TransactionIds",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                nullable: false,
                defaultValue: "",
                oldClrType: typeof(string),
                oldType: "TEXT",
                oldNullable: true);
        }
    }
}
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    [Migration("20240822173358_InitialMigration8")]
    partial class InitialMigration8
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<decimal>("Fees")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("TEXT");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AveragePriceAtTime")
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("BalanceAfterTransaction")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("WalletName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyProcessedTransaction");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("CsvLinesJson")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<int>("ErrorType")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long>("PortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("PortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "CurrentPrice", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyHoldingId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyHoldingId");

                            b1.ToTable("CryptoCurrencyHoldings");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyHoldingId");
                        });

                    b.Navigation("CurrentPrice")
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("ProcessedTransactions")
                        .HasForeignKey("UserPortfolioId");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount")
                        .IsRequired();

                    b.Navigation("ReceivedAmount")
                        .IsRequired();

                    b.Navigation("SentAmount")
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("PortfolioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("ProcessedTransactions");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    public partial class InitialMigration5 : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterColumn<string>(
                name: "SentCurrency",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                maxLength: 3,
                nullable: false,
                defaultValue: "",
                oldClrType: typeof(string),
                oldType: "TEXT",
                oldMaxLength: 3,
                oldNullable: true);

            migrationBuilder.AlterColumn<decimal>(
                name: "SentAmount",
                table: "CryptoCurrencyRawTransactions",
                type: "decimal(18,8)",
                nullable: false,
                defaultValue: 0m,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)",
                oldNullable: true);

            migrationBuilder.AlterColumn<string>(
                name: "ReceivedCurrency",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                maxLength: 3,
                nullable: false,
                defaultValue: "",
                oldClrType: typeof(string),
                oldType: "TEXT",
                oldMaxLength: 3,
                oldNullable: true);

            migrationBuilder.AlterColumn<decimal>(
                name: "ReceivedAmount",
                table: "CryptoCurrencyRawTransactions",
                type: "decimal(18,8)",
                nullable: false,
                defaultValue: 0m,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)",
                oldNullable: true);
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterColumn<string>(
                name: "SentCurrency",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                maxLength: 3,
                nullable: true,
                oldClrType: typeof(string),
                oldType: "TEXT",
                oldMaxLength: 3);

            migrationBuilder.AlterColumn<decimal>(
                name: "SentAmount",
                table: "CryptoCurrencyRawTransactions",
                type: "decimal(18,8)",
                nullable: true,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)");

            migrationBuilder.AlterColumn<string>(
                name: "ReceivedCurrency",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                maxLength: 3,
                nullable: true,
                oldClrType: typeof(string),
                oldType: "TEXT",
                oldMaxLength: 3);

            migrationBuilder.AlterColumn<decimal>(
                name: "ReceivedAmount",
                table: "CryptoCurrencyRawTransactions",
                type: "decimal(18,8)",
                nullable: true,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)");
        }
    }
}
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    public partial class InitialMigration3 : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_CryptoCurrencyProcessedTransactions_UserPortfolios_UserPortfolioId",
                table: "CryptoCurrencyProcessedTransactions");

            migrationBuilder.DropForeignKey(
                name: "FK_CryptoCurrencyRawTransactions_Wallets_WalletId",
                table: "CryptoCurrencyRawTransactions");

            migrationBuilder.DropPrimaryKey(
                name: "PK_CryptoCurrencyProcessedTransactions",
                table: "CryptoCurrencyProcessedTransactions");

            migrationBuilder.RenameTable(
                name: "CryptoCurrencyProcessedTransactions",
                newName: "CryptoCurrencyProcessedTransaction");

            migrationBuilder.RenameIndex(
                name: "IX_CryptoCurrencyProcessedTransactions_UserPortfolioId",
                table: "CryptoCurrencyProcessedTransaction",
                newName: "IX_CryptoCurrencyProcessedTransaction_UserPortfolioId");

            migrationBuilder.AlterColumn<long>(
                name: "WalletId",
                table: "CryptoCurrencyRawTransactions",
                type: "INTEGER",
                nullable: false,
                defaultValue: 0L,
                oldClrType: typeof(long),
                oldType: "INTEGER",
                oldNullable: true);

            migrationBuilder.AlterColumn<decimal>(
                name: "BalanceAfterTransaction",
                table: "CryptoCurrencyProcessedTransaction",
                type: "TEXT",
                nullable: true,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)",
                oldNullable: true);

            migrationBuilder.AlterColumn<decimal>(
                name: "AveragePriceAtTime",
                table: "CryptoCurrencyProcessedTransaction",
                type: "TEXT",
                nullable: true,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)",
                oldNullable: true);

            migrationBuilder.AlterColumn<decimal>(
                name: "Amount",
                table: "CryptoCurrencyProcessedTransaction",
                type: "TEXT",
                nullable: false,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)");

            migrationBuilder.AddPrimaryKey(
                name: "PK_CryptoCurrencyProcessedTransaction",
                table: "CryptoCurrencyProcessedTransaction",
                column: "Id");

            migrationBuilder.AddForeignKey(
                name: "FK_CryptoCurrencyProcessedTransaction_UserPortfolios_UserPortfolioId",
                table: "CryptoCurrencyProcessedTransaction",
                column: "UserPortfolioId",
                principalTable: "UserPortfolios",
                principalColumn: "Id");

            migrationBuilder.AddForeignKey(
                name: "FK_CryptoCurrencyRawTransactions_Wallets_WalletId",
                table: "CryptoCurrencyRawTransactions",
                column: "WalletId",
                principalTable: "Wallets",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_CryptoCurrencyProcessedTransaction_UserPortfolios_UserPortfolioId",
                table: "CryptoCurrencyProcessedTransaction");

            migrationBuilder.DropForeignKey(
                name: "FK_CryptoCurrencyRawTransactions_Wallets_WalletId",
                table: "CryptoCurrencyRawTransactions");

            migrationBuilder.DropPrimaryKey(
                name: "PK_CryptoCurrencyProcessedTransaction",
                table: "CryptoCurrencyProcessedTransaction");

            migrationBuilder.RenameTable(
                name: "CryptoCurrencyProcessedTransaction",
                newName: "CryptoCurrencyProcessedTransactions");

            migrationBuilder.RenameIndex(
                name: "IX_CryptoCurrencyProcessedTransaction_UserPortfolioId",
                table: "CryptoCurrencyProcessedTransactions",
                newName: "IX_CryptoCurrencyProcessedTransactions_UserPortfolioId");

            migrationBuilder.AlterColumn<long>(
                name: "WalletId",
                table: "CryptoCurrencyRawTransactions",
                type: "INTEGER",
                nullable: true,
                oldClrType: typeof(long),
                oldType: "INTEGER");

            migrationBuilder.AlterColumn<decimal>(
                name: "BalanceAfterTransaction",
                table: "CryptoCurrencyProcessedTransactions",
                type: "decimal(18,8)",
                nullable: true,
                oldClrType: typeof(decimal),
                oldType: "TEXT",
                oldNullable: true);

            migrationBuilder.AlterColumn<decimal>(
                name: "AveragePriceAtTime",
                table: "CryptoCurrencyProcessedTransactions",
                type: "decimal(18,8)",
                nullable: true,
                oldClrType: typeof(decimal),
                oldType: "TEXT",
                oldNullable: true);

            migrationBuilder.AlterColumn<decimal>(
                name: "Amount",
                table: "CryptoCurrencyProcessedTransactions",
                type: "decimal(18,8)",
                nullable: false,
                oldClrType: typeof(decimal),
                oldType: "TEXT");

            migrationBuilder.AddPrimaryKey(
                name: "PK_CryptoCurrencyProcessedTransactions",
                table: "CryptoCurrencyProcessedTransactions",
                column: "Id");

            migrationBuilder.AddForeignKey(
                name: "FK_CryptoCurrencyProcessedTransactions_UserPortfolios_UserPortfolioId",
                table: "CryptoCurrencyProcessedTransactions",
                column: "UserPortfolioId",
                principalTable: "UserPortfolios",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);

            migrationBuilder.AddForeignKey(
                name: "FK_CryptoCurrencyRawTransactions_Wallets_WalletId",
                table: "CryptoCurrencyRawTransactions",
                column: "WalletId",
                principalTable: "Wallets",
                principalColumn: "Id");
        }
    }
}
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    public partial class Initial1 : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_Wallets_UserPortfolios_UserPortfolioId",
                table: "Wallets");

            migrationBuilder.DropIndex(
                name: "IX_Wallets_UserPortfolioId",
                table: "Wallets");

            migrationBuilder.DropColumn(
                name: "UserPortfolioId",
                table: "Wallets");

            migrationBuilder.AddColumn<long>(
                name: "PortfolioId",
                table: "Wallets",
                type: "INTEGER",
                nullable: false,
                defaultValue: 0L);

            migrationBuilder.CreateIndex(
                name: "IX_Wallets_PortfolioId",
                table: "Wallets",
                column: "PortfolioId");

            migrationBuilder.AddForeignKey(
                name: "FK_Wallets_UserPortfolios_PortfolioId",
                table: "Wallets",
                column: "PortfolioId",
                principalTable: "UserPortfolios",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_Wallets_UserPortfolios_PortfolioId",
                table: "Wallets");

            migrationBuilder.DropIndex(
                name: "IX_Wallets_PortfolioId",
                table: "Wallets");

            migrationBuilder.DropColumn(
                name: "PortfolioId",
                table: "Wallets");

            migrationBuilder.AddColumn<long>(
                name: "UserPortfolioId",
                table: "Wallets",
                type: "INTEGER",
                nullable: true);

            migrationBuilder.CreateIndex(
                name: "IX_Wallets_UserPortfolioId",
                table: "Wallets",
                column: "UserPortfolioId");

            migrationBuilder.AddForeignKey(
                name: "FK_Wallets_UserPortfolios_UserPortfolioId",
                table: "Wallets",
                column: "UserPortfolioId",
                principalTable: "UserPortfolios",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);
        }
    }
}
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    public partial class InitialMigration4 : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.RenameColumn(
                name: "SentAmountCurrency",
                table: "CryptoCurrencyRawTransactions",
                newName: "SentCurrency");

            migrationBuilder.RenameColumn(
                name: "ReceivedAmountCurrency",
                table: "CryptoCurrencyRawTransactions",
                newName: "ReceivedCurrency");

            migrationBuilder.RenameColumn(
                name: "FeeAmountCurrency",
                table: "CryptoCurrencyRawTransactions",
                newName: "FeeCurrency");

            migrationBuilder.AlterColumn<decimal>(
                name: "FeeAmount",
                table: "CryptoCurrencyRawTransactions",
                type: "decimal(18,8)",
                nullable: false,
                defaultValue: 0m,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)",
                oldNullable: true);

            migrationBuilder.AlterColumn<string>(
                name: "FeeCurrency",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                maxLength: 3,
                nullable: false,
                defaultValue: "",
                oldClrType: typeof(string),
                oldType: "TEXT",
                oldMaxLength: 3,
                oldNullable: true);
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.RenameColumn(
                name: "SentCurrency",
                table: "CryptoCurrencyRawTransactions",
                newName: "SentAmountCurrency");

            migrationBuilder.RenameColumn(
                name: "ReceivedCurrency",
                table: "CryptoCurrencyRawTransactions",
                newName: "ReceivedAmountCurrency");

            migrationBuilder.RenameColumn(
                name: "FeeCurrency",
                table: "CryptoCurrencyRawTransactions",
                newName: "FeeAmountCurrency");

            migrationBuilder.AlterColumn<decimal>(
                name: "FeeAmount",
                table: "CryptoCurrencyRawTransactions",
                type: "decimal(18,8)",
                nullable: true,
                oldClrType: typeof(decimal),
                oldType: "decimal(18,8)");

            migrationBuilder.AlterColumn<string>(
                name: "FeeAmountCurrency",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                maxLength: 3,
                nullable: true,
                oldClrType: typeof(string),
                oldType: "TEXT",
                oldMaxLength: 3);
        }
    }
}
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    [Migration("20240820001059_Initial")]
    partial class Initial
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("decimal(18,8)");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AveragePriceAtTime")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal?>("BalanceAfterTransaction")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("WalletName")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyProcessedTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .IsRequired()
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long?>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("ProcessedTransactions")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId");

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount");

                    b.Navigation("ReceivedAmount");

                    b.Navigation("SentAmount");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("ProcessedTransactions");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    [Migration("20240822141821_InitialMigration4")]
    partial class InitialMigration4
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("TEXT");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AveragePriceAtTime")
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("BalanceAfterTransaction")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("WalletName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyProcessedTransaction");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("CsvLinesJson")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long>("PortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("PortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("ProcessedTransactions")
                        .HasForeignKey("UserPortfolioId");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount")
                        .IsRequired();

                    b.Navigation("ReceivedAmount");

                    b.Navigation("SentAmount");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("PortfolioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("ProcessedTransactions");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    public partial class InitialMigration9 : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<decimal>(
                name: "FeeValueInDefaultCurrency_Amount",
                table: "CryptoCurrencyRawTransactions",
                type: "decimal(18,8)",
                nullable: false,
                defaultValue: 0m);

            migrationBuilder.AddColumn<string>(
                name: "FeeValueInDefaultCurrency_CurrencyCode",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                maxLength: 3,
                nullable: false,
                defaultValue: "");

            migrationBuilder.AddColumn<decimal>(
                name: "ValueInDefaultCurrency_Amount",
                table: "CryptoCurrencyRawTransactions",
                type: "decimal(18,8)",
                nullable: false,
                defaultValue: 0m);

            migrationBuilder.AddColumn<string>(
                name: "ValueInDefaultCurrency_CurrencyCode",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                maxLength: 3,
                nullable: false,
                defaultValue: "");
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "FeeValueInDefaultCurrency_Amount",
                table: "CryptoCurrencyRawTransactions");

            migrationBuilder.DropColumn(
                name: "FeeValueInDefaultCurrency_CurrencyCode",
                table: "CryptoCurrencyRawTransactions");

            migrationBuilder.DropColumn(
                name: "ValueInDefaultCurrency_Amount",
                table: "CryptoCurrencyRawTransactions");

            migrationBuilder.DropColumn(
                name: "ValueInDefaultCurrency_CurrencyCode",
                table: "CryptoCurrencyRawTransactions");
        }
    }
}
﻿using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    public partial class InitialMigration7 : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "CryptoCurrencyProcessedTransaction");

            migrationBuilder.DropColumn(
                name: "Fees",
                table: "CryptoCurrencyHoldings");

            migrationBuilder.AddColumn<string>(
                name: "DefaultCurrency",
                table: "UserPortfolios",
                type: "TEXT",
                nullable: false,
                defaultValue: "");

            migrationBuilder.AddColumn<string>(
                name: "ErrorMessage",
                table: "CryptoCurrencyRawTransactions",
                type: "TEXT",
                maxLength: 250,
                nullable: false,
                defaultValue: "");

            migrationBuilder.AddColumn<string>(
                name: "ErrorMessage",
                table: "CryptoCurrencyHoldings",
                type: "TEXT",
                maxLength: 250,
                nullable: false,
                defaultValue: "");

            migrationBuilder.AddColumn<int>(
                name: "ErrorType",
                table: "CryptoCurrencyHoldings",
                type: "INTEGER",
                nullable: false,
                defaultValue: 0);

            migrationBuilder.CreateTable(
                name: "PurchaseRecord",
                columns: table => new
                {
                    Id = table.Column<long>(type: "INTEGER", nullable: false)
                        .Annotation("Sqlite:Autoincrement", true),
                    Amount = table.Column<decimal>(type: "TEXT", nullable: false),
                    PricePerUnit = table.Column<decimal>(type: "TEXT", nullable: false),
                    PurchaseDate = table.Column<DateTime>(type: "TEXT", nullable: false),
                    CryptoCurrencyHoldingId = table.Column<long>(type: "INTEGER", nullable: true),
                    Created = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    CreatedBy = table.Column<string>(type: "TEXT", nullable: true),
                    LastModified = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    LastModifiedBy = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_PurchaseRecord", x => x.Id);
                    table.ForeignKey(
                        name: "FK_PurchaseRecord_CryptoCurrencyHoldings_CryptoCurrencyHoldingId",
                        column: x => x.CryptoCurrencyHoldingId,
                        principalTable: "CryptoCurrencyHoldings",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateTable(
                name: "TaxableEvents",
                columns: table => new
                {
                    Id = table.Column<long>(type: "INTEGER", nullable: false)
                        .Annotation("Sqlite:Autoincrement", true),
                    DateTime = table.Column<DateTime>(type: "TEXT", nullable: false),
                    AverageCost = table.Column<decimal>(type: "decimal(18,8)", nullable: false),
                    ValueAtDisposal = table.Column<decimal>(type: "decimal(18,8)", nullable: false),
                    Quantity = table.Column<decimal>(type: "decimal(18,8)", nullable: false),
                    DisposedAsset = table.Column<string>(type: "TEXT", nullable: false),
                    Currency = table.Column<string>(type: "TEXT", maxLength: 5, nullable: false),
                    UserPortfolioId = table.Column<long>(type: "INTEGER", nullable: true),
                    Created = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    CreatedBy = table.Column<string>(type: "TEXT", nullable: true),
                    LastModified = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    LastModifiedBy = table.Column<string>(type: "TEXT", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_TaxableEvents", x => x.Id);
                    table.ForeignKey(
                        name: "FK_TaxableEvents_UserPortfolios_UserPortfolioId",
                        column: x => x.UserPortfolioId,
                        principalTable: "UserPortfolios",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_PurchaseRecord_CryptoCurrencyHoldingId",
                table: "PurchaseRecord",
                column: "CryptoCurrencyHoldingId");

            migrationBuilder.CreateIndex(
                name: "IX_TaxableEvents_UserPortfolioId",
                table: "TaxableEvents",
                column: "UserPortfolioId");
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "PurchaseRecord");

            migrationBuilder.DropTable(
                name: "TaxableEvents");

            migrationBuilder.DropColumn(
                name: "DefaultCurrency",
                table: "UserPortfolios");

            migrationBuilder.DropColumn(
                name: "ErrorMessage",
                table: "CryptoCurrencyRawTransactions");

            migrationBuilder.DropColumn(
                name: "ErrorMessage",
                table: "CryptoCurrencyHoldings");

            migrationBuilder.DropColumn(
                name: "ErrorType",
                table: "CryptoCurrencyHoldings");

            migrationBuilder.AddColumn<decimal>(
                name: "Fees",
                table: "CryptoCurrencyHoldings",
                type: "decimal(18,8)",
                nullable: false,
                defaultValue: 0m);

            migrationBuilder.CreateTable(
                name: "CryptoCurrencyProcessedTransaction",
                columns: table => new
                {
                    Id = table.Column<long>(type: "INTEGER", nullable: false)
                        .Annotation("Sqlite:Autoincrement", true),
                    Amount = table.Column<decimal>(type: "TEXT", nullable: false),
                    Asset = table.Column<string>(type: "TEXT", nullable: false),
                    AveragePriceAtTime = table.Column<decimal>(type: "TEXT", nullable: true),
                    BalanceAfterTransaction = table.Column<decimal>(type: "TEXT", nullable: true),
                    Created = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    CreatedBy = table.Column<string>(type: "TEXT", nullable: true),
                    DateTime = table.Column<DateTime>(type: "TEXT", nullable: false),
                    LastModified = table.Column<DateTimeOffset>(type: "TEXT", nullable: false),
                    LastModifiedBy = table.Column<string>(type: "TEXT", nullable: true),
                    UserPortfolioId = table.Column<long>(type: "INTEGER", nullable: true),
                    WalletName = table.Column<string>(type: "TEXT", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CryptoCurrencyProcessedTransaction", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CryptoCurrencyProcessedTransaction_UserPortfolios_UserPortfolioId",
                        column: x => x.UserPortfolioId,
                        principalTable: "UserPortfolios",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateIndex(
                name: "IX_CryptoCurrencyProcessedTransaction_UserPortfolioId",
                table: "CryptoCurrencyProcessedTransaction",
                column: "UserPortfolioId");
        }
    }
}
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    [Migration("20240820123127_InitialMigration2")]
    partial class InitialMigration2
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("decimal(18,8)");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AveragePriceAtTime")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal?>("BalanceAfterTransaction")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("WalletName")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyProcessedTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("CsvLinesJson")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long?>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long>("PortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("PortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("ProcessedTransactions")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId");

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount");

                    b.Navigation("ReceivedAmount");

                    b.Navigation("SentAmount");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("PortfolioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("ProcessedTransactions");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    [Migration("20240822143400_InitialMigration5")]
    partial class InitialMigration5
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("TEXT");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AveragePriceAtTime")
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("BalanceAfterTransaction")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("WalletName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyProcessedTransaction");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("CsvLinesJson")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long>("PortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("PortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("ProcessedTransactions")
                        .HasForeignKey("UserPortfolioId");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount")
                        .IsRequired();

                    b.Navigation("ReceivedAmount")
                        .IsRequired();

                    b.Navigation("SentAmount")
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("PortfolioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("ProcessedTransactions");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    [Migration("20240824030416_InitialMigration7")]
    partial class InitialMigration7
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("ErrorMessage")
                        .IsRequired()
                        .HasMaxLength(250)
                        .HasColumnType("TEXT");

                    b.Property<int>("ErrorType")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("CsvLinesJson")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<string>("ErrorMessage")
                        .IsRequired()
                        .HasMaxLength(250)
                        .HasColumnType("TEXT");

                    b.Property<int>("ErrorType")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.PurchaseRecord", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("CryptoCurrencyHoldingId")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<decimal>("PricePerUnit")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("PurchaseDate")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("CryptoCurrencyHoldingId");

                    b.ToTable("PurchaseRecord");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.TaxableEvent", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("AverageCost")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Currency")
                        .IsRequired()
                        .HasMaxLength(5)
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<string>("DisposedAsset")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<decimal>("Quantity")
                        .HasColumnType("decimal(18,8)");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("ValueAtDisposal")
                        .HasColumnType("decimal(18,8)");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("TaxableEvents", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("DefaultCurrency")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long>("PortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("PortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "CurrentPrice", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyHoldingId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyHoldingId");

                            b1.ToTable("CryptoCurrencyHoldings");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyHoldingId");
                        });

                    b.Navigation("CurrentPrice")
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeValueInDefaultCurrency", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .ValueGeneratedOnUpdateSometimes()
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .ValueGeneratedOnUpdateSometimes()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .ValueGeneratedOnUpdateSometimes()
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .ValueGeneratedOnUpdateSometimes()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ValueInDefaultCurrency", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .ValueGeneratedOnUpdateSometimes()
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .ValueGeneratedOnUpdateSometimes()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount")
                        .IsRequired();

                    b.Navigation("FeeValueInDefaultCurrency")
                        .IsRequired();

                    b.Navigation("ReceivedAmount")
                        .IsRequired();

                    b.Navigation("SentAmount")
                        .IsRequired();

                    b.Navigation("ValueInDefaultCurrency")
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.PurchaseRecord", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.CryptoCurrencyHolding", null)
                        .WithMany("PurchaseRecords")
                        .HasForeignKey("CryptoCurrencyHoldingId");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.TaxableEvent", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("TaxableEvents")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("PortfolioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Navigation("PurchaseRecords");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("TaxableEvents");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
﻿// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Portfolio.Infrastructure;

#nullable disable

namespace Portfolio.Infrastructure.DataMigrations
{
    [DbContext(typeof(PortfolioDbContext))]
    [Migration("20240822031716_InitialMigration3")]
    partial class InitialMigration3
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "8.0.8");

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ClaimType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("TEXT");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("TEXT");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("RoleId")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("TEXT");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Value")
                        .HasColumnType("TEXT");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasMaxLength(10)
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AverageBoughtPrice")
                        .HasColumnType("decimal(18,8)");

                    b.Property<decimal>("Balance")
                        .HasColumnType("decimal(18,8)");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyHoldings", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<decimal>("Amount")
                        .HasColumnType("TEXT");

                    b.Property<string>("Asset")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("AveragePriceAtTime")
                        .HasColumnType("TEXT");

                    b.Property<decimal?>("BalanceAfterTransaction")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<long?>("UserPortfolioId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("WalletName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("UserPortfolioId");

                    b.ToTable("CryptoCurrencyProcessedTransaction");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Account")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("CsvLinesJson")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<DateTime>("DateTime")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Note")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("TEXT");

                    b.Property<string>("TransactionIds")
                        .HasColumnType("TEXT")
                        .HasColumnName("TransactionIds");

                    b.Property<int>("Type")
                        .HasColumnType("INTEGER");

                    b.Property<long>("WalletId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("WalletId");

                    b.ToTable("CryptoCurrencyRawTransactions", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.ToTable("UserPortfolios", (string)null);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Property<long>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset>("Created")
                        .HasColumnType("TEXT");

                    b.Property<string>("CreatedBy")
                        .HasColumnType("TEXT");

                    b.Property<DateTimeOffset>("LastModified")
                        .HasColumnType("TEXT");

                    b.Property<string>("LastModifiedBy")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("TEXT");

                    b.Property<long>("PortfolioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("Id");

                    b.HasIndex("PortfolioId");

                    b.ToTable("Wallets", (string)null);
                });

            modelBuilder.Entity("Portfolio.Infrastructure.Identity.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("TEXT");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("TEXT");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("TEXT");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("TEXT");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("INTEGER");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("TEXT");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("INTEGER");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("TEXT");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("Portfolio.Infrastructure.Identity.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyHolding", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Holdings")
                        .HasForeignKey("UserPortfolioId")
                        .OnDelete(DeleteBehavior.Cascade);
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyProcessedTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("ProcessedTransactions")
                        .HasForeignKey("UserPortfolioId");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.CryptoCurrencyRawTransaction", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.Wallet", null)
                        .WithMany("Transactions")
                        .HasForeignKey("WalletId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "FeeAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("FeeAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("FeeAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "ReceivedAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("ReceivedAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("ReceivedAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.OwnsOne("Portfolio.Domain.ValueObjects.Money", "SentAmount", b1 =>
                        {
                            b1.Property<long>("CryptoCurrencyRawTransactionId")
                                .HasColumnType("INTEGER");

                            b1.Property<decimal>("Amount")
                                .HasColumnType("decimal(18,8)")
                                .HasColumnName("SentAmount");

                            b1.Property<string>("CurrencyCode")
                                .IsRequired()
                                .HasMaxLength(3)
                                .HasColumnType("TEXT")
                                .HasColumnName("SentAmountCurrency");

                            b1.HasKey("CryptoCurrencyRawTransactionId");

                            b1.ToTable("CryptoCurrencyRawTransactions");

                            b1.WithOwner()
                                .HasForeignKey("CryptoCurrencyRawTransactionId");
                        });

                    b.Navigation("FeeAmount");

                    b.Navigation("ReceivedAmount");

                    b.Navigation("SentAmount");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.HasOne("Portfolio.Domain.Entities.UserPortfolio", null)
                        .WithMany("Wallets")
                        .HasForeignKey("PortfolioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.UserPortfolio", b =>
                {
                    b.Navigation("Holdings");

                    b.Navigation("ProcessedTransactions");

                    b.Navigation("Wallets");
                });

            modelBuilder.Entity("Portfolio.Domain.Entities.Wallet", b =>
                {
                    b.Navigation("Transactions");
                });
#pragma warning restore 612, 618
        }
    }
}
using Microsoft.AspNetCore.Identity;

namespace Portfolio.Infrastructure.Identity;

public class ApplicationUser : IdentityUser
{
}using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Portfolio.Infrastructure.Data.Interceptors;

namespace Portfolio.Infrastructure
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
        {
            var connectionString = configuration.GetConnectionString("DefaultConnection");


            services.AddScoped<ISaveChangesInterceptor, AuditableEntityInterceptor>();
            services.AddScoped<ISaveChangesInterceptor, DispatchDomainEventsInterceptor>();

            services.AddDbContext<PortfolioDbContext>((sp, options) =>
            {
                options.AddInterceptors(sp.GetServices<ISaveChangesInterceptor>());

                options.UseSqlite(connectionString);

            });




            services.AddSingleton(TimeProvider.System);


            return services;
        }
    }
}using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Portfolio.Domain;

namespace Portfolio.Infrastructure.Persistence.Configurations
{
    public class FinancialEventConfiguration : IEntityTypeConfiguration<FinancialEvent>
    {
        public void Configure(EntityTypeBuilder<FinancialEvent> builder)
        {
            builder.ToTable("FinancialEvents");

            builder.HasKey(te => te.Id);

            builder.Property(te => te.EventDate)
                .IsRequired();

            builder.Property(te => te.CostBasisPerUnit)
                .HasColumnType("decimal(18,8)")
                .IsRequired();

            builder.Property(te => te.MarketPricePerUnit)
                .HasColumnType("decimal(18,8)")
                .IsRequired();

            builder.Property(te => te.Amount)
                .HasColumnType("decimal(18,8)")
                .IsRequired();

            builder.Property(te => te.BaseCurrency)
                .HasMaxLength(10)
                .IsRequired();
            
            builder.Property(te => te.AssetSymbol)
                .HasMaxLength(10)
                .IsRequired();
        }
    }
}
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Portfolio.Domain.Entities;

namespace Portfolio.Infrastructure.Persistence.Configurations
{
    public class PurchaseRecordConfiguration : IEntityTypeConfiguration<PurchaseRecord>
    {
        public void Configure(EntityTypeBuilder<PurchaseRecord> builder)
        {
            builder.ToTable("TaxableEvents");

            builder.HasKey(te => te.Id);

            builder.Property(te => te.PurchaseDate)
                .IsRequired();

            builder.Property(te => te.Amount)
                .HasColumnType("decimal(18,8)")
                .IsRequired();

            builder.Property(te => te.PricePerUnit)
                .HasColumnType("decimal(18,8)")
                .IsRequired();
        }
    }
}
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Portfolio.Domain.Entities;

namespace Portfolio.Infrastructure.Data.Configurations
{
       public class FinancialTransactionConfiguration : IEntityTypeConfiguration<FinancialTransaction>
       {
              public void Configure(EntityTypeBuilder<FinancialTransaction> builder)
              {
                     builder.ToTable("FinancialTransactions");

                     builder.HasKey(t => t.Id);

                     builder.Property(t => t.DateTime)
                            .IsRequired();

                     builder.Property(t => t.Type)
                            .IsRequired();

                     builder.Property(t => t.Account)
                            .IsRequired()
                            .HasMaxLength(100); // Assuming the account name has a max length, adjust as needed

                     builder.Property(t => t.Note)
                            .HasMaxLength(500); // Optional: define max length for the note field

                     builder.Property(t => t.CsvLinesJson);

                     builder.Property(t => t.ErrorType);
                     builder.Property(t => t.ErrorMessage).HasMaxLength(250);

                     builder.OwnsOne(t => t.ReceivedAmount, money =>
                     {
                            money.Property(m => m.Amount)
                                   .HasColumnName("ReceivedAmount")
                                   .HasColumnType("decimal(18,8)");

                            money.Property(m => m.CurrencyCode)
                                   .HasColumnName("ReceivedCurrency")
                                   .HasMaxLength(3);
                     });

                     builder.OwnsOne(t => t.SentAmount, money =>
                     {
                            money.Property(m => m.Amount)
                                   .HasColumnName("SentAmount")
                                   .HasColumnType("decimal(18,8)");

                            money.Property(m => m.CurrencyCode)
                                   .HasColumnName("SentCurrency")
                                   .HasMaxLength(3);
                     });

                     builder.OwnsOne(t => t.FeeAmount, money =>
                     {
                            var x = money.Property(m => m.Amount)
                                   .HasColumnName("FeeAmount")
                                   .HasColumnType("decimal(18,8)");



                            money.Property(m => m.CurrencyCode)
                                   .HasColumnName("FeeCurrency")
                                   .HasMaxLength(3);
                     });

                     builder.OwnsOne(t => t.ValueInDefaultCurrency, money =>
                     {
                            money.Property(m => m.Amount)
                                   .HasColumnType("decimal(18,8)");

                            money.Property(m => m.CurrencyCode)
                                   .HasMaxLength(3);
                     });

                     builder.OwnsOne(t => t.FeeValueInDefaultCurrency, money =>
                     {
                            money.Property(m => m.Amount)
                                   .HasColumnType("decimal(18,8)");

                            money.Property(m => m.CurrencyCode)
                                   .HasMaxLength(3);
                     });

                     builder.Property(t => t.TransactionIds)
                            .HasConversion(
                                v => string.Join(',', v),
                                v => v.Split(',', StringSplitOptions.RemoveEmptyEntries))
                            .HasColumnName("TransactionIds");
              }
       }
}
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Portfolio.Domain.Entities;

namespace Portfolio.Infrastructure.Data.Configurations
{
    public class AssetHoldingConfiguration : IEntityTypeConfiguration<AssetHolding>
    {
        public void Configure(EntityTypeBuilder<AssetHolding> builder)
        {
            builder.ToTable("AssetHoldings");

            builder.HasKey(h => h.Id);

            builder.Property(h => h.Asset)
                   .IsRequired()
                   .HasMaxLength(10); // Assuming the asset code is a short string, adjust the length as needed

            builder.Property(h => h.Balance)
                   .IsRequired()
                   .HasColumnType("decimal(18,8)"); // Adjust precision and scale based on your requirements

            builder.Property(t => t.ErrorType);
            builder.Property(t => t.ErrorMessage).HasMaxLength(250);

            builder.Property(h => h.AverageBoughtPrice)
                   .HasColumnType("decimal(18,8)"); // Nullable, with precision and scale for high precision calculations

            builder.OwnsOne(t => t.CurrentPrice, money =>
{
    money.Property(m => m.Amount)
                                .HasColumnName("SentAmount")
                                .HasColumnType("decimal(18,8)");

    money.Property(m => m.CurrencyCode)
                                .HasColumnName("SentCurrency")
                                .HasMaxLength(3);
});

        }
    }
}
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Portfolio.Domain.Entities;

namespace Portfolio.Infrastructure.Data.Configurations
{
    public class WalletConfiguration : IEntityTypeConfiguration<Wallet>
    {
        public void Configure(EntityTypeBuilder<Wallet> builder)
        {
            builder.ToTable("Wallets");

            builder.HasKey(w => w.Id);

            builder.Property(w => w.Name)
                   .IsRequired()
                   .HasMaxLength(100);

            builder.HasMany<FinancialTransaction>("Transactions")
                   .WithOne()                   
                   .HasForeignKey(t => t.WalletId)
                   .OnDelete(DeleteBehavior.Cascade);

        }
    }
}
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Portfolio.Domain.Entities;

namespace Portfolio.Infrastructure.Data.Configurations
{
    public class PortfolioConfiguration : IEntityTypeConfiguration<UserPortfolio>
    {
        public void Configure(EntityTypeBuilder<UserPortfolio> builder)
        {
            builder.ToTable("UserPortfolios");

            builder.HasKey(p => p.Id);

            builder.Property(p => p.DefaultCurrency);

            builder.HasMany(p => p.Wallets)
                   .WithOne()
                   .HasForeignKey(f => f.PortfolioId)
                   .OnDelete(DeleteBehavior.Cascade);

            builder.HasMany(p => p.Holdings)
                   .WithOne()
                   .OnDelete(DeleteBehavior.Cascade);

            builder.HasMany(p => p.FinancialEvents)
                   .WithOne()
                   .OnDelete(DeleteBehavior.Cascade);
        }
    }
}
using MediatR;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Portfolio.Domain.Common;

namespace Portfolio.Infrastructure.Data.Interceptors
{
    public class DispatchDomainEventsInterceptor : SaveChangesInterceptor
    {
        private readonly IMediator _mediator;

        public DispatchDomainEventsInterceptor(IMediator mediator)
        {
            _mediator = mediator;
        }

        public override InterceptionResult<int> SavingChanges(DbContextEventData eventData, InterceptionResult<int> result)
        {
            DispatchDomainEvents(eventData.Context).GetAwaiter().GetResult();

            return base.SavingChanges(eventData, result);

        }

        public override async ValueTask<InterceptionResult<int>> SavingChangesAsync(DbContextEventData eventData, InterceptionResult<int> result, CancellationToken cancellationToken = default)
        {
            await DispatchDomainEvents(eventData.Context);

            return await base.SavingChangesAsync(eventData, result, cancellationToken);
        }

        public async Task DispatchDomainEvents(DbContext? context)
        {
            if (context == null) return;

            var entities = context.ChangeTracker
                .Entries<AggregateRoot>()
                .Where(e => e.Entity.DomainEvents.Any())
                .Select(e => e.Entity);

            var domainEvents = entities
                .SelectMany(e => e.DomainEvents)
                .ToList();

            entities.ToList().ForEach(e => e.ClearDomainEvents());

            foreach (var domainEvent in domainEvents)
                await _mediator.Publish(domainEvent);
        }
    }
}using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Portfolio.Domain.Common;
using Portfolio.Domain.Interfaces;

namespace Portfolio.Infrastructure.Data.Interceptors
{
    public class AuditableEntityInterceptor : SaveChangesInterceptor
    {
        private readonly IUser _user;
        private readonly TimeProvider _dateTime;

        public AuditableEntityInterceptor(
            IUser user,
            TimeProvider dateTime)
        {
            _user = user;
            _dateTime = dateTime;
        }

        public override InterceptionResult<int> SavingChanges(DbContextEventData eventData, InterceptionResult<int> result)
        {
            UpdateEntities(eventData.Context);

            return base.SavingChanges(eventData, result);
        }

        public override ValueTask<InterceptionResult<int>> SavingChangesAsync(DbContextEventData eventData, InterceptionResult<int> result, CancellationToken cancellationToken = default)
        {
            UpdateEntities(eventData.Context);

            return base.SavingChangesAsync(eventData, result, cancellationToken);
        }

        public void UpdateEntities(DbContext? context)
        {
            if (context == null) return;

            foreach (var entry in context.ChangeTracker.Entries<BaseAuditableEntity>())
            {
                if (entry.State is EntityState.Added or EntityState.Modified || entry.HasChangedOwnedEntities())
                {
                    var utcNow = _dateTime.GetUtcNow();
                    if (entry.State == EntityState.Added)
                    {
                        entry.Entity.CreatedBy = _user.Id;
                        entry.Entity.Created = utcNow;
                    }
                    entry.Entity.LastModifiedBy = _user.Id;
                    entry.Entity.LastModified = utcNow;
                }
            }
        }
    }

    public static class Extensions
    {
        public static bool HasChangedOwnedEntities(this EntityEntry entry) =>
            entry.References.Any(r =>
                r.TargetEntry != null &&
                r.TargetEntry.Metadata.IsOwned() &&
                (r.TargetEntry.State == EntityState.Added || r.TargetEntry.State == EntityState.Modified));
    }
}﻿using MediatR;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;
using Portfolio.App.Common.Interfaces;
using Portfolio.Domain.Common;
using Portfolio.Domain.Entities;
using Portfolio.Infrastructure.Data.Configurations;
using Portfolio.Infrastructure.Identity;
using Portfolio.Infrastructure.Persistence.Configurations;

namespace Portfolio.Infrastructure
{
    public class PortfolioDbContext : IdentityDbContext<ApplicationUser>, IApplicationDbContext
    {
        private readonly IMediator _mediator;

        public PortfolioDbContext(DbContextOptions<PortfolioDbContext> options, IMediator mediator)
            : base(options)
        {
            _mediator = mediator;
        }

        public DbSet<UserPortfolio> Portfolios { get; set; }
        public DbSet<Wallet> Wallets { get; set; }
        public DbSet<AssetHolding> Holdings { get; set; }
        public DbSet<FinancialTransaction> RawTransactions { get; set; }

        public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {
            var entitiesWithEvents = ChangeTracker.Entries<AggregateRoot>()
                .Where(e => e.Entity.DomainEvents.Any())
                .Select(e => e.Entity)
                .ToList();

            foreach (var entity in entitiesWithEvents)
            {
                var domainEvents = entity.DomainEvents.ToList();
                entity.ClearDomainEvents();

                foreach (var domainEvent in domainEvents)
                {
                    await _mediator.Publish(domainEvent, cancellationToken);
                }
            }

            return await base.SaveChangesAsync(cancellationToken);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.ApplyConfiguration(new FinancialTransactionConfiguration());  
            modelBuilder.ApplyConfiguration(new AssetHoldingConfiguration());
            modelBuilder.ApplyConfiguration(new WalletConfiguration());
            modelBuilder.ApplyConfiguration(new PortfolioConfiguration());
            modelBuilder.ApplyConfiguration(new FinancialEventConfiguration());
        }
    }
}
﻿using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using Portfolio.Domain.Constants;
using Portfolio.Infrastructure.Identity;

namespace Portfolio.Infrastructure.Data;

public class PortfolioDbContextInitialiser
{
    private readonly ILogger<PortfolioDbContextInitialiser> _logger;
    private readonly PortfolioDbContext _context;
    private readonly UserManager<ApplicationUser> _userManager;
    private readonly RoleManager<IdentityRole> _roleManager;

    public PortfolioDbContextInitialiser(ILogger<PortfolioDbContextInitialiser> logger, PortfolioDbContext context, UserManager<ApplicationUser> userManager, RoleManager<IdentityRole> roleManager)
    {
        _logger = logger;
        _context = context;
        _userManager = userManager;
        _roleManager = roleManager;
    }

    public async Task InitialiseAsync()
    {
        try
        {
            await _context.Database.MigrateAsync();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while initialising the database.");
            throw;
        }
    }

    public async Task SeedAsync()
    {
        try
        {
            await TrySeedAsync();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while seeding the database.");
            throw;
        }
    }

    public async Task TrySeedAsync()
    {
        var administratorRole = new IdentityRole(Roles.Administrator);

        if (_roleManager.Roles.All(r => r.Name != administratorRole.Name))
        {
            await _roleManager.CreateAsync(administratorRole);
        }

        var administrator = new ApplicationUser { UserName = "administrator@localhost", Email = "administrator@localhost" };

        if (_userManager.Users.All(u => u.UserName != administrator.UserName))
        {
            await _userManager.CreateAsync(administrator, "Administrator1!");
            if (!string.IsNullOrWhiteSpace(administratorRole.Name))
            {
                await _userManager.AddToRolesAsync(administrator, new[] { administratorRole.Name });
            }
        }


    }
}
﻿namespace Portfolio.App.Common.Interfaces;

public interface IApplicationDbContext
{
    Task<int> SaveChangesAsync(CancellationToken cancellationToken);
}
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

public class EmptyMoneyAmountConverter : ValueConverter<decimal, decimal?>
{
    public EmptyMoneyAmountConverter()
        : base(
            money => (money == 0) ? new decimal?() : money,
            value => value != null ? value.Value : 0)
    {
    }
}// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Portfolio.Transactions.Importers")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+b939afd4dad8882c516038f6d4d9b6d835809e0d")]
[assembly: System.Reflection.AssemblyProductAttribute("Portfolio.Transactions.Importers")]
[assembly: System.Reflection.AssemblyTitleAttribute("Portfolio.Transactions.Importers")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]


using CSharpFunctionalExtensions;

namespace Portfolio.Transactions.Importers.Utilities
{
    public static class StreamReaderValidator
    {
        public static Result ValidateStreamReader(StreamReader streamReader)
        {
            if (streamReader == null)
                return Result.Failure("StreamReader cannot be null.");

            if (streamReader.BaseStream == null)
                return Result.Failure("StreamReader's BaseStream is null.");

            if (!streamReader.BaseStream.CanRead)
                return Result.Failure("StreamReader's BaseStream cannot be read.");

            try
            {
                if (streamReader.BaseStream.Length == 0)
                    return Result.Failure("StreamReader's BaseStream is empty.");
            }
            catch (Exception ex)
            {
                return Result.Failure($"Exception occurred while validating StreamReader: {ex.Message}");
            }

            return Result.Success();
        }
    }
}
using CsvHelper.Configuration;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Transactions.Importers.Csv.LedgerLive
{
    public class LedgerLiveCsvLineMap : ClassMap<LedgerLiveCsvEntry>
    {
        public LedgerLiveCsvLineMap()
        {
            Map(m => m.TransactionId).Name("Operation Hash");
            Map(m => m.Date).Name("Operation Date").Convert(args => DateTime.Parse(args.Row.GetField("Operation Date"), null, System.Globalization.DateTimeStyles.RoundtripKind));
            Map(m => m.Type).Name("Operation Type");
            Map(m => m.Asset).Name("Currency Ticker");
            Map(m => m.WalletName).Name("Account Name");
            Map(m => m.Amount).Name("Operation Amount").Convert(args => new Money(ToDecimal(args.Row.GetField("Operation Amount")), args.Row.GetField("Currency Ticker")));
            Map(m => m.Fee).Name("Operation Fees").Convert(args => new Money(ToDecimal(args.Row.GetField("Operation Fees")), args.Row.GetField("Currency Ticker")));
        }

        private decimal ToDecimal(string originalAmount)
        {
            if (string.IsNullOrWhiteSpace(originalAmount))
            {
                return 0;
            }
            if (decimal.TryParse(originalAmount, out decimal amount))
            {
                return amount;
            }
            throw new ArgumentException("Unrecognized amount.");
        }
    }

    public class LedgerLiveCsvEntry
    {
        public string TransactionId { get; set; } = null!;
        public DateTime Date { get; set; }
        public string Type { get; set; } = null!;
        public string Asset { get; set; } = null!;
        public string WalletName { get; set; } = null!;
        public Money Amount { get; set; } = null!;
        public Money Fee { get; set; } = null!;
    }
}
using System.Globalization;
using CsvHelper;
using CsvHelper.Configuration;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Interfaces;
using Serilog;

namespace Portfolio.Transactions.Importers.Csv.LedgerLive
{
    public class LedgerLiveCsvParser
    {
        private string _filename;

        public LedgerLiveCsvParser(string filename)
        {
            _filename = filename ?? throw new ArgumentNullException("The file path cannot be null or empty.");
        }

        public IEnumerable<ICryptoCurrencyTransaction> ExtractTransactions()
        {
            var csvLines = ReadCsvFile();

            var rawLedger = csvLines.OrderBy(x => x.Date).ToList();
            var transactions = new List<ICryptoCurrencyTransaction>();

            var trades = ProcessTrades(rawLedger);
            var processedRefIds = trades.SelectMany(x => x.TransactionIds).ToList();
            transactions.AddRange(trades);

            var stakes = ProcessStaking(rawLedger.Where(x => !processedRefIds.Contains(x.TransactionId)));
            processedRefIds.AddRange(stakes.SelectMany(x => x.TransactionIds).ToList());
            transactions.AddRange(stakes);

            var deposits = ProcessDeposits(rawLedger.Where(x => !processedRefIds.Contains(x.TransactionId)));
            processedRefIds.AddRange(deposits.SelectMany(x => x.TransactionIds).ToList());
            transactions.AddRange(deposits);

            var withdrawals = ProcessWithdrawals(rawLedger.Where(x => !processedRefIds.Contains(x.TransactionId)));
            processedRefIds.AddRange(withdrawals.SelectMany(x => x.TransactionIds).ToList());
            transactions.AddRange(withdrawals);

            return transactions;
        }

        private List<LedgerLiveCsvEntry> ReadCsvFile()
        {
            var config = new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                HasHeaderRecord = true
            };

            using (var reader = new StreamReader(_filename))
            using (var csv = new CsvReader(reader, config))
            {
                csv.Context.RegisterClassMap<LedgerLiveCsvLineMap>();
                var records = csv.GetRecords<LedgerLiveCsvEntry>();
                return records.ToList();
            }
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessWithdrawals(IEnumerable<LedgerLiveCsvEntry> rawLedger)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();
            var processedRefIds = new HashSet<string>();
            var withdrawals = rawLedger.Where(x => x.Type == "OUT");

            foreach (var withdraw in withdrawals)
            {
                var withdrawResult = CryptoCurrencyWithdrawTransaction.Create(
                    date: withdraw.Date,
                    amount: withdraw.Amount.ToAbsoluteAmountMoney(),
                    feeAmount: withdraw.Fee.ToAbsoluteAmountMoney(),
                    "ledgerlive",
                    transactionIds: [withdraw.TransactionId]
                    );

                if (withdrawResult.IsFailure)
                    throw new ArgumentException(withdrawResult.Error);

                withdrawResult.Value.State = new LedgerLiveCsvEntry[] { withdraw };

                transactions.Add(withdrawResult.Value);
            }

            return transactions;
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessDeposits(IEnumerable<LedgerLiveCsvEntry> rawLedger)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();
            var deposits = rawLedger.Where(x => x.Type == "IN");

            foreach (var deposit in deposits)
            {
                var depositResult = CryptoCurrencyDepositTransaction.Create(
                    date: deposit.Date,
                    receivedAmount: deposit.Amount.ToAbsoluteAmountMoney().Subtract(deposit.Fee.ToAbsoluteAmountMoney()),
                    feeAmount: deposit.Fee.ToAbsoluteAmountMoney(),
                    "ledgerlive",
                    transactionIds: [deposit.TransactionId]
                    );

                if (depositResult.IsFailure)
                    throw new ArgumentException(depositResult.Error);

                depositResult.Value.State = new LedgerLiveCsvEntry[] { deposit };

                transactions.Add(depositResult.Value);
            }

            return transactions;
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessStaking(IEnumerable<LedgerLiveCsvEntry> rawLedger)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();
            var stakes = rawLedger.Where(x => x.Type == "DELEGATE");

            foreach (var stake in stakes)
            {
                Log.Warning($"Skipping staking transaction {stake.TransactionId}, not supported at this time ");
            }

            return transactions;
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessTrades(IEnumerable<LedgerLiveCsvEntry> rawLedger)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();


            return transactions;
        }
    }
}using CsvHelper.Configuration;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Transactions.Importers.Csv.Coinbase
{
    public class CoinbaseCsvLineMap : ClassMap<CoinbaseCsvEntry>
    {
        public CoinbaseCsvLineMap()
        {
            Map(m => m.TransactionId).Name("ID");
            Map(m => m.Date).Name("Timestamp").Convert(args => DateTime.Parse(args.Row.GetField("Timestamp").Replace(" UTC", ""), null, System.Globalization.DateTimeStyles.RoundtripKind));
            Map(m => m.Type).Name("Transaction Type");
            Map(m => m.Asset).Name("Asset");
            Map(m => m.Amount).Name("Quantity Transacted").Convert(args => new Money(ToDecimal(args.Row.GetField("Quantity Transacted")), args.Row.GetField("Asset")));
            Map(m => m.PriceCurrency).Name("Price Currency");
            Map(m => m.Subtotal).Name("Subtotal").Convert(args => new Money(ToDecimal(args.Row.GetField("Subtotal")), args.Row.GetField("Price Currency")));
            Map(m => m.Fee).Name("Fees and/or Spread").Convert(args => new Money(ToDecimal(args.Row.GetField("Fees and/or Spread")), args.Row.GetField("Price Currency")));
            Map(m => m.Notes).Name("Notes");
        }

        private decimal ToDecimal(string originalAmount)
        {
            if (string.IsNullOrWhiteSpace(originalAmount))
            {
                return 0;
            }
            if (decimal.TryParse(originalAmount, out decimal amount))
            {
                return amount;
            }
            throw new ArgumentException("Unrecognized amount.");
        }
    }

    public class CoinbaseCsvEntry
    {
        public string TransactionId { get; set; } = null!;
        public DateTime Date { get; set; }
        public string Type { get; set; } = null!;
        public string Asset { get; set; } = null!;
        public Money Amount { get; set; } = null!;
        public string PriceCurrency { get; set; } = null!;
        public Money Subtotal { get; set; } = null!;
        public Money Fee { get; set; } = null!;
        public string Notes { get; set; } = string.Empty;
    }
}
using System.Globalization;
using CsvHelper;
using CsvHelper.Configuration;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Interfaces;
using Serilog;

namespace Portfolio.Transactions.Importers.Csv.Coinbase
{
    public class CoinbaseCsvParser
    {
        private string _filename;

        public CoinbaseCsvParser(string filename)
        {
            _filename = filename ?? throw new ArgumentNullException("The file path cannot be null or empty.");
        }

        public IEnumerable<ICryptoCurrencyTransaction> ExtractTransactions()
        {
            var csvLines = ReadCsvFile();

            var rawLedger = csvLines.OrderBy(x => x.Date).ToList();
            var transactions = new List<ICryptoCurrencyTransaction>();

            var deposits = ProcessDeposits(rawLedger);
            var processedRefIds = deposits.SelectMany(x => x.TransactionIds).ToList();
            transactions.AddRange(deposits);

            var withdrawals = ProcessWithdrawals(rawLedger.Where(x => !processedRefIds.Contains(x.TransactionId)));
            processedRefIds.AddRange(withdrawals.SelectMany(x => x.TransactionIds).ToList());
            transactions.AddRange(withdrawals);

            var trades = ProcessTrades(rawLedger.Where(x => !processedRefIds.Contains(x.TransactionId)));
            processedRefIds.AddRange(trades.SelectMany(x => x.TransactionIds).ToList());
            transactions.AddRange(trades);

            var stakes = ProcessStaking(rawLedger.Where(x => !processedRefIds.Contains(x.TransactionId)));
            processedRefIds.AddRange(stakes.SelectMany(x => x.TransactionIds).ToList());
            transactions.AddRange(stakes);

            return transactions;
        }

        private List<CoinbaseCsvEntry> ReadCsvFile()
        {
            var config = new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                HasHeaderRecord = true
            };

            using (var reader = new StreamReader(_filename))
            {
                reader.ReadLine();
                reader.ReadLine();
                reader.ReadLine();

                using (var csv = new CsvReader(reader, config))
                {
                    csv.Context.RegisterClassMap<CoinbaseCsvLineMap>();
                    var records = csv.GetRecords<CoinbaseCsvEntry>();
                    return records.ToList();
                }
            }
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessWithdrawals(IEnumerable<CoinbaseCsvEntry> rawLedger)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();
            var processedRefIds = new HashSet<string>();
            var sentMoneyTxs = rawLedger.Where(x => x.Type == "Send");

            foreach (var withdraw in sentMoneyTxs)
            {
                var withdrawResult = CryptoCurrencyWithdrawTransaction.Create(
                    date: withdraw.Date,
                    amount: withdraw.Amount.ToAbsoluteAmountMoney(),
                    feeAmount: withdraw.Fee.ToAbsoluteAmountMoney(),
                    "coinbase",
                    transactionIds: [withdraw.TransactionId]);

                if (withdrawResult.IsFailure)
                    throw new ArgumentException(withdrawResult.Error);

                withdrawResult.Value.State = new CoinbaseCsvEntry[] { withdraw };

                transactions.Add(withdrawResult.Value);
            }

            var withdrawals = rawLedger.Where(x => x.Type == "Withdrawal");
            foreach (var withdraw in withdrawals)
            {
                var withdrawResult = CryptoCurrencyWithdrawTransaction.Create(
                    date: withdraw.Date,
                    amount: withdraw.Subtotal.ToAbsoluteAmountMoney(),
                    feeAmount: withdraw.Fee.ToAbsoluteAmountMoney(),
                    "coinbase",
                    transactionIds: [withdraw.TransactionId]);

                if (withdrawResult.IsFailure)
                    throw new ArgumentException(withdrawResult.Error);

                withdrawResult.Value.State = new CoinbaseCsvEntry[] { withdraw };

                transactions.Add(withdrawResult.Value);
            }

            return transactions;
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessDeposits(IEnumerable<CoinbaseCsvEntry> rawLedger)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();
            var deposits = rawLedger.Where(x => x.Type == "Deposit");

            foreach (var deposit in deposits)
            {
                var depositResult = CryptoCurrencyDepositTransaction.Create(
                    date: deposit.Date,
                    receivedAmount: deposit.Subtotal.ToAbsoluteAmountMoney(),
                    feeAmount: deposit.Fee.ToAbsoluteAmountMoney(),
                    "coinbase",
                    transactionIds: [deposit.TransactionId]);

                if (depositResult.IsFailure)
                    throw new ArgumentException(depositResult.Error);

                depositResult.Value.State = new CoinbaseCsvEntry[] { deposit };

                transactions.Add(depositResult.Value);
            }

            return transactions;
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessStaking(IEnumerable<CoinbaseCsvEntry> rawLedger)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();
            var stakes = rawLedger.Where(x => x.Type == "DELEGATE");

            foreach (var stake in stakes)
            {
                Log.Warning($"Skipping staking transaction {stake.TransactionId}, not supported at this time ");
            }

            return transactions;
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessTrades(IEnumerable<CoinbaseCsvEntry> rawLedger)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();
            var trades = rawLedger.Where(x => x.Type == "Buy");

            foreach (var trade in trades)
            {
                var tradeResult = CryptoCurrencyTradeTransaction.Create(
                    date: trade.Date,
                    receivedAmount: trade.Amount.ToAbsoluteAmountMoney(),
                    sentAmount: trade.Subtotal.ToAbsoluteAmountMoney(),
                    feeAmount: trade.Fee.ToAbsoluteAmountMoney(),
                    "coinbase",
                    transactionIds: [trade.TransactionId]);

                if (tradeResult.IsFailure)
                    throw new ArgumentException(tradeResult.Error);

                tradeResult.Value.State = new CoinbaseCsvEntry[] { trade };

                transactions.Add(tradeResult.Value);
            }

            var advTrades = rawLedger.Where(x => x.Type == "Advance Trade Sell");
            foreach (var trade in advTrades)
            {
                var tradeResult = CryptoCurrencyTradeTransaction.Create(
                    date: trade.Date,
                    receivedAmount: trade.Subtotal.ToAbsoluteAmountMoney(),
                    sentAmount: trade.Amount.ToAbsoluteAmountMoney(),
                    feeAmount: trade.Fee.ToAbsoluteAmountMoney(),
                    "coinbase",
                    transactionIds: [trade.TransactionId]
                    );

                if (tradeResult.IsFailure)
                    throw new ArgumentException(tradeResult.Error);

                tradeResult.Value.State = new CoinbaseCsvEntry[] { trade };

                transactions.Add(tradeResult.Value);
            }

            return transactions;
        }
    }
}using CsvHelper.Configuration;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Transactions.Importers.Csv.Kucoin
{
    public class KucoinWithdrawCsvLineMap : ClassMap<KucoinWithdrawCsvEntry>
    {
        public KucoinWithdrawCsvLineMap()
        {
            Map(m => m.TransactionId).Name("UID");
            Map(m => m.Date).Name("Time(UTC)").Convert(args => DateTime.Parse(args.Row.GetField("Time(UTC)"), null, System.Globalization.DateTimeStyles.RoundtripKind));
            Map(m => m.Asset).Name("Coin");
            Map(m => m.Amount).Name("Amount").Convert(args => new Money(ToDecimal(args.Row.GetField("Amount")), args.Row.GetField("Coin")));
            Map(m => m.Fee).Name("Fee").Convert(args => new Money(ToDecimal(args.Row.GetField("Fee")), args.Row.GetField("Coin")));
            Map(m => m.Remark).Name("Remarks");
            Map(m => m.Status).Name("Status");
        }

        private decimal ToDecimal(string originalAmount)
        {
            if (string.IsNullOrWhiteSpace(originalAmount))
            {
                return 0;
            }
            if (decimal.TryParse(originalAmount, out decimal amount))
            {
                return amount;
            }
            throw new ArgumentException("Unrecognized amount.");
        }
    }

    public class KucoinWithdrawCsvEntry
    {
        public string TransactionId { get; set; } = null!;
        public DateTime Date { get; set; }
        public string Asset { get; set; } = null!;
        public Money Amount { get; set; } = null!;
        public Money Fee { get; set; } = null!;
        public string Remark { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
    }
}
using CsvHelper.Configuration;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Transactions.Importers.Csv.Kucoin
{
    public class KucoinDepositCsvLineMap : ClassMap<KucoinDepositCsvEntry>
    {
        public KucoinDepositCsvLineMap()
        {
            Map(m => m.TransactionId).Name("UID");
            Map(m => m.Date).Name("Time(UTC)").Convert(args => DateTime.Parse(args.Row.GetField("Time(UTC)"), null, System.Globalization.DateTimeStyles.RoundtripKind));
            Map(m => m.Asset).Name("Coin");
            Map(m => m.Amount).Name("Amount").Convert(args => new Money(ToDecimal(args.Row.GetField("Amount")), args.Row.GetField("Coin")));
            Map(m => m.Fee).Name("Fee").Convert(args => new Money(ToDecimal(args.Row.GetField("Fee")), args.Row.GetField("Coin")));
            Map(m => m.Remark).Name("Remarks");
            Map(m => m.Status).Name("Status");
        }

        private decimal ToDecimal(string originalAmount)
        {
            if (string.IsNullOrWhiteSpace(originalAmount))
            {
                return 0;
            }
            if (decimal.TryParse(originalAmount, out decimal amount))
            {
                return amount;
            }
            throw new ArgumentException("Unrecognized amount.");
        }
    }

    public class KucoinDepositCsvEntry
    {
        public string TransactionId { get; set; } = null!;
        public DateTime Date { get; set; }
        public string Asset { get; set; } = null!;
        public Money Amount { get; set; } = null!;
        public Money Fee { get; set; } = null!;
        public string Remark { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
    }
}
using CsvHelper.Configuration;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Transactions.Importers.Csv.Kucoin
{
    public class KucoinFilledOrderCsvLineMap : ClassMap<KucoinFilledOrderCsvEntry>
    {
        public KucoinFilledOrderCsvLineMap()
        {
            Map(m => m.TransactionId).Name("Order ID");
            Map(m => m.Date).Name("Filled Time(UTC)").Convert(args => DateTime.Parse(args.Row.GetField("Filled Time(UTC)"), null, System.Globalization.DateTimeStyles.RoundtripKind));
            Map(m => m.Type).Name("Side");
            Map(m => m.OrderAmount).Name("Filled Amount").Convert(args => new Money(ToDecimal(args.Row.GetField("Filled Amount")), GetTradingPairPart(args.Row.GetField("Symbol"), 0)));
            Map(m => m.FilledVolume).Name("Filled Volume").Convert(args => new Money(ToDecimal(args.Row.GetField("Filled Volume")), GetTradingPairPart(args.Row.GetField("Symbol"), 1)));
            Map(m => m.Fee).Name("Fee").Convert(args => new Money(ToDecimal(args.Row.GetField("Fee")), args.Row.GetField("Fee Currency")));
        }

        private string GetTradingPairPart(string tradingPair, int partNumber)
        {
            string[] parts = tradingPair.Split("-");
            if (parts.Length != 2)
            {
                throw new InvalidOperationException($"Invalid trading pair {tradingPair}");
            }
            if (partNumber > 1)
            {
                throw new InvalidOperationException($"Invalid part number {partNumber}");
            }
            return parts[partNumber];
        }

        private decimal ToDecimal(string originalAmount)
        {
            if (string.IsNullOrWhiteSpace(originalAmount))
            {
                return 0;
            }
            if (decimal.TryParse(originalAmount, out decimal amount))
            {
                return amount;
            }
            throw new ArgumentException("Unrecognized amount.");
        }
    }

    public class KucoinFilledOrderCsvEntry
    {
        public string TransactionId { get; set; } = null!;
        public DateTime Date { get; set; }
        public string Type { get; set; } = null!;
        public Money OrderAmount { get; set; } = null!;
        public Money FilledVolume { get; set; } = null!;
        public Money Fee { get; set; } = null!;
    }
}
using System.Globalization;
using CsvHelper;
using CsvHelper.Configuration;
using Portfolio.Domain.Entities;
using Portfolio.Domain.Interfaces;
using Serilog;

namespace Portfolio.Transactions.Importers.Csv.Kucoin
{
    public class KucoinCsvParser
    {
        string TRADING_CSV_HEADERS = "UID,Account Type,Order ID,Order Time(UTC),Symbol,Side,Order Type,Order Price,Order Amount,Avg. Filled Price,Filled Amount,Filled Volume,Filled Volume (USDT),Filled Time(UTC),Fee,Fee Currency,Tax,Status";
        string WITHDRAWAL_CSV_HEADERS = "UID,Account Type,Time(UTC),Remarks,Status,Fee,Amount,Coin,Transfer Network,Withdrawal Address/Account";
        string DEPOSIT_CSV_HEADERS = "UID,Account Type,Time(UTC),Remarks,Status,Fee,Amount,Coin,Transfer Network";

        private string _folderPath;
        private List<KucoinFilledOrderCsvEntry> _tradesCsvLines = new();
        private List<KucoinDepositCsvEntry> _depositCsvLines = new();
        private List<KucoinWithdrawCsvEntry> _withdrawCsvLines = new();

        public KucoinCsvParser(string folderPath)
        {
            _folderPath = folderPath ?? throw new ArgumentNullException("The folder path cannot be null or empty.");
        }

        public IEnumerable<ICryptoCurrencyTransaction> ExtractTransactions()
        {
            List<ICryptoCurrencyTransaction> transactions = new();

            ReadCsvFile();

            var deposits = ProcessDeposits(_depositCsvLines);
            transactions.AddRange(deposits);

            var withdrawals = ProcessWithdrawals(_withdrawCsvLines);
            transactions.AddRange(withdrawals);

            var trades = ProcessTrades(_tradesCsvLines);
            transactions.AddRange(trades);


            return transactions.OrderBy(tx => tx.DateTime);
        }

        private void ReadCsvFile()
        {
            var config = new CsvConfiguration(CultureInfo.InvariantCulture)
            {
                HasHeaderRecord = true
            };

            string[] csvFiles = Directory.GetFiles(_folderPath, "*.csv");

            foreach (string file in csvFiles)
            {
                using (var reader = new StreamReader(file))
                {
                    using (var csv = new CsvReader(reader, config))
                    {
                        csv.Read();
                        csv.ReadHeader();
                        var headers = csv.HeaderRecord; // Getting the header record
                        string headerString = string.Join(",", headers);
                        if (csv.ColumnCount == 18 && headerString == TRADING_CSV_HEADERS)
                        {
                            csv.Context.RegisterClassMap<KucoinFilledOrderCsvLineMap>();
                            _tradesCsvLines.AddRange(csv.GetRecords<KucoinFilledOrderCsvEntry>().ToList());
                        }
                        else if (csv.ColumnCount == 10 && headerString == WITHDRAWAL_CSV_HEADERS)
                        {
                            csv.Context.RegisterClassMap<KucoinWithdrawCsvLineMap>();
                            _withdrawCsvLines.AddRange(csv.GetRecords<KucoinWithdrawCsvEntry>().ToList());
                        }
                        else if (csv.ColumnCount == 9 && headerString == DEPOSIT_CSV_HEADERS)
                        {
                            csv.Context.RegisterClassMap<KucoinDepositCsvLineMap>();
                            _depositCsvLines.AddRange(csv.GetRecords<KucoinDepositCsvEntry>().ToList());
                        }
                        else
                        {
                            Log.Error($"Unrecognized file {file} with headers: {headerString}");
                        }
                    }
                }
            }
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessWithdrawals(IEnumerable<KucoinWithdrawCsvEntry> withdrawals)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();

            foreach (var withdraw in withdrawals)
            {
                var withdrawResult = CryptoCurrencyWithdrawTransaction.Create(
                    date: withdraw.Date,
                    amount: withdraw.Amount.ToAbsoluteAmountMoney(),
                    feeAmount: withdraw.Fee.ToAbsoluteAmountMoney(),
                    "kucoin",
                    transactionIds: [withdraw.TransactionId],
                    note: withdraw.Remark);

                if (withdrawResult.IsFailure)
                    throw new ArgumentException(withdrawResult.Error);

                withdrawResult.Value.State = new KucoinWithdrawCsvEntry[] { withdraw };

                transactions.Add(withdrawResult.Value);
            }

            return transactions;
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessDeposits(IEnumerable<KucoinDepositCsvEntry> deposits)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();

            foreach (var deposit in deposits)
            {
                var depositResult = CryptoCurrencyDepositTransaction.Create(
                    date: deposit.Date,
                    receivedAmount: deposit.Amount.ToAbsoluteAmountMoney(),
                    feeAmount: deposit.Fee.ToAbsoluteAmountMoney(),
                    "kucoin",
                    transactionIds: [deposit.TransactionId],
                    note: deposit.Remark);

                if (depositResult.IsFailure)
                    throw new ArgumentException(depositResult.Error);

                depositResult.Value.State = new KucoinDepositCsvEntry[] { deposit };


                transactions.Add(depositResult.Value);
            }

            return transactions;
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessStaking(IEnumerable<KucoinFilledOrderCsvEntry> rawLedger)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();
            var stakes = rawLedger.Where(x => x.Type == "DELEGATE");

            foreach (var stake in stakes)
            {
                Log.Warning($"Skipping staking transaction {stake.TransactionId}, not supported at this time ");
            }

            return transactions;
        }

        private static IEnumerable<ICryptoCurrencyTransaction> ProcessTrades(IEnumerable<KucoinFilledOrderCsvEntry> rawLedger)
        {
            var transactions = new List<ICryptoCurrencyTransaction>();
            var trades = rawLedger.Where(x => x.Type == "BUY");

            foreach (var trade in trades)
            {
                var tradeResult = CryptoCurrencyTradeTransaction.Create(
                    date: trade.Date,
                    receivedAmount: trade.OrderAmount.ToAbsoluteAmountMoney(),
                    sentAmount: trade.FilledVolume.ToAbsoluteAmountMoney(),
                    feeAmount: trade.Fee.ToAbsoluteAmountMoney(),
                    "kucoin",
                    transactionIds: [trade.TransactionId]
                    );

                if (tradeResult.IsFailure)
                    throw new ArgumentException(tradeResult.Error);

                tradeResult.Value.State = new KucoinFilledOrderCsvEntry[] { trade };

                transactions.Add(tradeResult.Value);
            }

            return transactions;
        }
    }
}using System.Globalization;
using System.Text.Json;
using CSharpFunctionalExtensions;
using CsvHelper;
using CsvHelper.Configuration;
using Portfolio.Domain.Entities;
using Portfolio.Domain.ValueObjects;
using Portfolio.Transactions.Importers.Utilities;
using Serilog;

namespace Portfolio.Transactions.Importers.Csv.Kraken
{
    public class KrakenCsvParser
    {
        public static readonly string EXPECTED_FILE_HEADER = "txid,refid,time,type,subtype,aclass,asset,wallet,amount,fee,balance";
        private readonly IEnumerable<KrakenCsvEntry> _csvLines;
        private readonly IEnumerable<string>? _refidsToIgnore = new List<string>();

        public static Result<KrakenCsvParser> Create(StreamReader streamReader, IEnumerable<string>? ignoreRefIds = null)
        {
            var streamValidResult = StreamReaderValidator.ValidateStreamReader(streamReader);
            if (streamValidResult.IsFailure)
                return Result.Failure<KrakenCsvParser>(streamValidResult.Error);

            try
            {
                var config = new CsvConfiguration(CultureInfo.InvariantCulture)
                {
                    HasHeaderRecord = true
                };

                using (var csv = new CsvReader(streamReader, config))
                {
                    csv.Context.RegisterClassMap<KrakenCsvLineMap>();
                    var records = csv.GetRecords<KrakenCsvEntry>();
                    return new KrakenCsvParser(records.ToList(), ignoreRefIds);
                }
            }
            catch (Exception ex)
            {
                return Result.Failure<KrakenCsvParser>($"Failed to import transactions from CSV: {ex.Message}");
            }
        }

        private KrakenCsvParser(IEnumerable<KrakenCsvEntry> csvLines, IEnumerable<string>? ignoreRefIds = null)
        {
            _csvLines = csvLines ?? throw new ArgumentNullException(nameof(csvLines));
            _refidsToIgnore = ignoreRefIds;
        }

        public IEnumerable<FinancialTransaction> ExtractTransactions()
        {
            var rawLedger = _csvLines.Where(x => _refidsToIgnore == null || !_refidsToIgnore.Any() || !_refidsToIgnore.Contains(x.ReferenceId)).OrderBy(x => x.Date).ToList();
            var transactions = new List<FinancialTransaction>();

            var trades = ProcessTrades(rawLedger);
            var processedRefIds = trades.SelectMany(x => x.TransactionIds).ToList();
            transactions.AddRange(trades);


            var deposits = ProcessDeposits(rawLedger.Where(x => !processedRefIds.Contains(x.ReferenceId)));
            processedRefIds.AddRange(deposits.SelectMany(x => x.TransactionIds).ToList());
            transactions.AddRange(deposits);

            var withdrawals = ProcessWithdrawals(rawLedger.Where(x => !processedRefIds.Contains(x.ReferenceId)));
            processedRefIds.AddRange(withdrawals.SelectMany(x => x.TransactionIds).ToList());
            transactions.AddRange(withdrawals);

            var notProcessed = rawLedger.Select(t => t.ReferenceId).Except(processedRefIds);
            foreach (var tx in notProcessed)
            {
                Log.Warning($"Unprocessed transaction with refId: {tx}");
            }

            return transactions.OrderBy(t => t.DateTime);
        }

        private static IEnumerable<FinancialTransaction> ProcessWithdrawals(IEnumerable<KrakenCsvEntry> rawLedger)
        {
            var transactions = new List<FinancialTransaction>();
            var processedRefIds = new HashSet<string>();
            var withdrawals = rawLedger.Where(x => x.Type == "withdrawal");

            if (!withdrawals.All(x => x.Amount.Amount < 0))
            {
                var invalids = withdrawals.Where(x => x.Amount.Amount > 0);
                Log.Warning($"Positive withdrawals found: {string.Join("|", invalids.Select(x => x.ReferenceId))}");
            }

            foreach (var withdraw in withdrawals)
            {
                var withdrawResult = FinancialTransaction.CreateWithdraw(
                    date: withdraw.Date,
                    sentAmount: withdraw.Amount.ToAbsoluteAmountMoney(),
                    feeAmount: withdraw.Fee.ToAbsoluteAmountMoney(),
                    "kraken",
                    transactionIds: [withdraw.ReferenceId]);

                if (withdrawResult.IsFailure)
                    throw new ArgumentException(withdrawResult.Error);

                withdrawResult.Value.CsvLinesJson = JsonSerializer.Serialize(new KrakenCsvEntry[] { withdraw });

                transactions.Add(withdrawResult.Value);
            }

            return transactions;
        }

        private static IEnumerable<FinancialTransaction> ProcessDeposits(IEnumerable<KrakenCsvEntry> rawLedger)
        {
            var transactions = new List<FinancialTransaction>();
            var deposits = rawLedger.Where(x => x.Type == "deposit");

            if (!deposits.All(x => x.Amount.Amount > 0))
            {
                var invalids = deposits.Where(x => x.Amount.Amount < 0);
                Log.Warning($"Negative deposits found: {string.Join("|", invalids.Select(x => x.ReferenceId))}");
            }

            foreach (var deposit in deposits)
            {
                var depositResult = FinancialTransaction.CreateDeposit(
                    date: deposit.Date,
                    receivedAmount: deposit.Amount.ToAbsoluteAmountMoney().Subtract(deposit.Fee.ToAbsoluteAmountMoney()),
                    feeAmount: deposit.Fee.ToAbsoluteAmountMoney(),
                    "kraken",
                    transactionIds: [deposit.ReferenceId]);

                if (depositResult.IsFailure)
                    throw new ArgumentException(depositResult.Error);

                depositResult.Value.CsvLinesJson = JsonSerializer.Serialize(new KrakenCsvEntry[] { deposit });

                transactions.Add(depositResult.Value);
            }

            return transactions;
        }





        private static IEnumerable<FinancialTransaction> ProcessTrades(IEnumerable<KrakenCsvEntry> rawLedger)
        {
            var trades = new List<FinancialTransaction>();
            var processedRefIds = new HashSet<string>();
            var txGroupsByRefid = rawLedger.GroupBy(x => x.ReferenceId).Where(group => group.Count() > 1);
            foreach (var group in txGroupsByRefid)
            {
                var receiveTx = group.Single(l => l.Amount.Amount > 0 && (l.Type == "receive" || l.Type == "trade"));
                if (group.Count() > 2)
                {
                    if (receiveTx.Amount.Amount < 1)
                    {
                        var depositResult = FinancialTransaction.CreateDeposit(
                            date: receiveTx.Date,
                            receivedAmount: receiveTx.Amount.ToAbsoluteAmountMoney().Subtract(receiveTx.Fee.ToAbsoluteAmountMoney()),
                            feeAmount: receiveTx.Fee.ToAbsoluteAmountMoney(),
                            "kraken",
                            transactionIds: group.Select(t => t.ReferenceId),
                            "dustsweeping"
                        );

                        if (depositResult.IsFailure)
                            throw new ArgumentException(depositResult.Error);

                        depositResult.Value.CsvLinesJson = JsonSerializer.Serialize(new KrakenCsvEntry[] { receiveTx });
                        trades.Add(depositResult.Value);

                        foreach (var sTx in group.Where(t => t != receiveTx))
                        {
                            var withdrawResult = FinancialTransaction.CreateWithdraw(
                                date: sTx.Date,
                                sentAmount: sTx.Amount.ToAbsoluteAmountMoney(),
                                feeAmount: sTx.Fee.ToAbsoluteAmountMoney(),
                                "kraken",
                                transactionIds: group.Select(t => t.ReferenceId),
                                "dustsweeping"
                                );

                            if (withdrawResult.IsFailure)
                                throw new ArgumentException(withdrawResult.Error);

                            withdrawResult.Value.CsvLinesJson = JsonSerializer.Serialize(new KrakenCsvEntry[] { sTx });
                            trades.Add(withdrawResult.Value);
                        }
                        Log.Warning($"Dust sweeping found, deposit created for {receiveTx.Amount.Amount}{receiveTx.Amount.CurrencyCode}, refid {group.Key} ...");
                        continue;
                    }
                    else
                    {
                        throw new InvalidDataException($"A trade involving more than two currency has been detected. Review the transaction with refid {receiveTx.ReferenceId}");
                    }
                }

                var spendTx = group.Single(l => l.Amount.Amount < 0 && (l.Type == "spend" || l.Type == "trade"));
                decimal receivedAmount = receiveTx.Amount.AbsoluteAmount;
                Money fee = spendTx.Fee.AbsoluteAmount > 0 ? spendTx.Fee.ToAbsoluteAmountMoney() : receiveTx.Fee.ToAbsoluteAmountMoney();

                var isSellTransaction = receiveTx.Amount.IsFiatCurrency && !spendTx.Amount.IsFiatCurrency;
                var isReceiveFee = receiveTx.Amount.CurrencyCode == receiveTx.Fee.CurrencyCode && receiveTx.Fee.Amount > 0;
                if (isReceiveFee/* && isSellTransaction*/)
                    receivedAmount -= fee.AbsoluteAmount;

                var tradeResult = FinancialTransaction.CreateTrade(
                    date: receiveTx.Date,
                    receivedAmount: new Money(receivedAmount, receiveTx.Amount.CurrencyCode),
                    sentAmount: spendTx.Amount.ToAbsoluteAmountMoney(),
                    feeAmount: fee.ToAbsoluteAmountMoney(),
                    "kraken",
                    transactionIds: [spendTx.ReferenceId, receiveTx.ReferenceId]);

                if (tradeResult.IsFailure)
                    throw new ArgumentException(tradeResult.Error);

                tradeResult.Value.CsvLinesJson = JsonSerializer.Serialize(new KrakenCsvEntry[] { receiveTx, spendTx });

                trades.Add(tradeResult.Value);
            }

            return trades;
        }
    }
}using CsvHelper.Configuration;
using Portfolio.Domain.ValueObjects;

namespace Portfolio.Transactions.Importers.Csv.Kraken
{
    public class KrakenCsvLineMap : ClassMap<KrakenCsvEntry>
    {
        public KrakenCsvLineMap()
        {
            Map(m => m.TransactionId).Name("txid");
            Map(m => m.ReferenceId).Name("refid");
            Map(m => m.Date).Name("time").Convert(args => DateTime.Parse(args.Row.GetField("time"), null, System.Globalization.DateTimeStyles.RoundtripKind));
            Map(m => m.Type).Name("type");
            Map(m => m.SubType).Name("subtype");
            Map(m => m.AClass).Name("aclass");
            Map(m => m.Asset).Name("asset").Convert(args => NormalizeCurrencyAbbreviation(args.Row.GetField("asset")));
            Map(m => m.WalletName).Name("wallet");
            Map(m => m.Amount).Name("amount").Convert(args => new Money(ToDecimal(args.Row.GetField("amount")), NormalizeCurrencyAbbreviation(args.Row.GetField("asset"))));
            Map(m => m.Fee).Name("fee").Convert(args => new Money(ToDecimal(args.Row.GetField("fee")), NormalizeCurrencyAbbreviation(args.Row.GetField("asset"))));
            Map(m => m.Balance).Name("balance").Convert(args => new Money(ToDecimal(args.Row.GetField("balance")), NormalizeCurrencyAbbreviation(args.Row.GetField("asset"))));            
        }

        private string NormalizeCurrencyAbbreviation(string currency)
        {
            if (KrakenSpecificAssetNamesDict.TryGetValue(currency, out string? normalized))
            {
                return normalized ?? string.Empty;
            }
            int dotIndex = currency.IndexOf('.');
            return dotIndex > -1 ? currency.Substring(0, dotIndex) : currency;
        }

        private decimal ToDecimal(string originalAmount)
        {
            if (string.IsNullOrWhiteSpace(originalAmount))
            {
                return 0;
            }
            if (decimal.TryParse(originalAmount, out decimal amount))
            {
                return amount;
            }
            throw new ArgumentException("Unrecognized amount.");
        }

        public static Dictionary<string, string> KrakenSpecificAssetNamesDict { get; } = new Dictionary<string, string>
        {
            {"KFEE", "FEE"},
            {"XETC", "ETC"},
            {"XETH", "ETH"},
            {"XLTC", "LTC"},
            {"XMLN", "MLN"},
            {"XREP", "REP"},
            {"XBT", "BTC"},
            {"XXBT", "BTC"},
            {"XXDG", "XDG"},
            {"XXLM", "XLM"},
            {"XXMR", "XMR"},
            {"XXRP", "XRP"},
            {"XZEC", "ZEC"},
            {"ZAUD", "AUD"},
            {"ZCAD", "CAD"},
            {"ZEUR", "EUR"},
            {"ZGBP", "GBP"},
            {"ZJPY", "JPY"},
            {"ZUSD", "USD"},
        };
    }

    public class KrakenCsvEntry
    {
        public string TransactionId { get; set; } = null!;
        public string ReferenceId { get; set; } = null!;
        public DateTime Date { get; set; }
        public string Type { get; set; } = null!;
        public string? SubType { get; set; }
        public string AClass { get; set; } = null!;
        public string Asset { get; set; } = null!;
        public string WalletName { get; set; } = null!;
        public Money Amount { get; set; } = null!;
        public Money Fee { get; set; } = null!;
        public Money Balance { get; set; } = null!;        
    }
}
