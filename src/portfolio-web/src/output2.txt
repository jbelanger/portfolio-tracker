.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
import React, { useState } from 'react';
import { createTheme, ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import Layout from './components/Layout';

const App: React.FC = () => {
  const [darkMode, setDarkMode] = useState(false);

  const theme = createTheme({
    palette: {
      mode: 'dark'
    },
    typography: {
      fontSize: 14,  // Smaller font size for compact UI      
      fontFamily: [
        '-apple-system',
        'BlinkMacSystemFont',
        '"Segoe UI"',
        'Roboto',
        '"Helvetica Neue"',
        'Arial',
        'sans-serif',
        '"Apple Color Emoji"',
        '"Segoe UI Emoji"',
        '"Segoe UI Symbol"',
      ].join(','),
    },
  });

  const handleToggleDarkMode = () => {
    setDarkMode(!darkMode);
  };

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Layout darkMode={darkMode} onToggleDarkMode={handleToggleDarkMode} />
    </ThemeProvider>
  );
};

export default App;
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>/// <reference types="react-scripts" />
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';
import axios from 'axios';

const apiClient = axios.create({
  baseURL: 'http://localhost:5262', // Replace with your API base URL
  headers: {
    'Content-Type': 'application/json',
  },
});

export default apiClient;
import React, { useState } from 'react';
import {
    Dialog, DialogTitle, DialogContent, DialogActions, Button, Box, Typography, RadioGroup, FormControl, FormControlLabel, Radio, InputLabel, Select, MenuItem
} from '@mui/material';
import { CsvFileImportType, CryptoCurrencyTransactionDto } from '../types/Wallet';
import apiClient from '../api/axios';
import TransactionForm from './TransactionForm';
import { Snackbar, Alert } from '@mui/material';

interface TransactionDialogProps {
    open: boolean;
    onClose: () => void;
    onTransactionAdded: () => void;
    selectedWalletId: number;
    showSnackbar: (message: string, severity: 'success' | 'error') => void; // Add this prop
}

const AddTransactionDialog: React.FC<TransactionDialogProps> = ({ open, onClose, onTransactionAdded, selectedWalletId, showSnackbar }) => {
    const [importType, setImportType] = useState<CsvFileImportType>(CsvFileImportType.Kraken); // Default import type
    const [selectedFile, setSelectedFile] = useState<File | null>(null);
    const [transactionMode, setTransactionMode] = useState<'manual' | 'csv'>('csv'); // Default to CSV import
    const [currentTransaction, setCurrentTransaction] = useState<CryptoCurrencyTransactionDto | null>(null);
    const [errorMessage, setErrorMessage] = useState<string | null>(null);
    const [snackbarOpen, setSnackbarOpen] = useState(false);
    const [snackbarMessage, setSnackbarMessage] = useState('');
    const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error'>('success');

    // const showSnackbar = (message: string, severity: 'success' | 'error' = 'success') => {
    //     setSnackbarMessage(message);
    //     setSnackbarSeverity(severity);
    //     setSnackbarOpen(true);
    // };

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.files && event.target.files[0]) {
            setSelectedFile(event.target.files[0]);
        }
    };

    const handleImportTransactions = async () => {
        if (!selectedFile) return;

        const formData = new FormData();
        formData.append('file', selectedFile);

        try {
            await apiClient.post(`/portfolios/1/wallets/${selectedWalletId}/transactions/upload-csv?csvImportType=${importType}`, formData, {
                headers: {
                    'Content-Type': 'multipart/form-data',
                },
            });
            showSnackbar('Transactions imported successfully.', 'success'); // Show success message
            onTransactionAdded(); // Trigger a refresh in the parent component
            onClose(); // Close the dialog
        } catch (error) {
            console.error('Error importing transactions:', error);
            showSnackbar('Error importing transactions. Please try again.', 'error'); // Show error message
        }
    };

    const handleSaveManualTransaction = async () => {
        if (!currentTransaction) return;

        try {
            await apiClient.post(`/portfolios/1/wallets/${selectedWalletId}/transactions`, currentTransaction);
            showSnackbar('Transaction added successfully.', 'success'); // Show success message
            onTransactionAdded(); // Trigger a refresh in the parent component
            onClose(); // Close the dialog
        } catch (error: any) {
            console.error('Error saving transaction:', error);
            if (error.response && error.response.data && typeof error.response.data === 'string') {
                showSnackbar(error.response.data, 'error'); // Show server error message
            } else {
                showSnackbar('An unexpected error occurred. Please try again.', 'error'); // Show generic error message
            }
        }
    };

    const renderCsvImportSection = () => (
        <>
            <Typography variant="h6">CSV Import</Typography>
            <FormControl fullWidth margin="dense">
                <InputLabel>Import Type</InputLabel>
                <Select
                    value={importType}
                    onChange={(e) => setImportType(e.target.value as CsvFileImportType)}
                    label="Import Type"
                >
                    <MenuItem value={CsvFileImportType.Kraken}>Kraken</MenuItem>
                    <MenuItem value={CsvFileImportType.Coinbase}>Coinbase</MenuItem>
                    <MenuItem value={CsvFileImportType.Binance}>Binance</MenuItem>
                    {/* Add more import types as needed */}
                </Select>
            </FormControl>
            <input
                accept=".csv"
                style={{ display: 'none' }}
                id="csv-file-input"
                type="file"
                onChange={handleFileChange}
            />
            <label htmlFor="csv-file-input">
                <Button
                    variant="contained"
                    color="primary"
                    component="span"
                    //disabled={!selectedFile}
                    style={{ marginTop: '15px' }}
                >
                    Choose CSV File
                </Button>
            </label>
            {selectedFile && (
                <Typography variant="body2" style={{ marginTop: '10px' }}>
                    Selected File: {selectedFile.name}
                </Typography>
            )}
            <Button
                variant="contained"
                color="secondary"
                onClick={handleImportTransactions}
                disabled={!selectedFile}
                style={{ marginTop: '15px' }}
            >
                Import Transactions
            </Button>
        </>
    );

    return (
        <Dialog open={open} onClose={onClose}>
            <DialogTitle>Add or Import Transactions</DialogTitle>
            <DialogContent>
                {errorMessage && (
                    <Typography color="error" variant="body2" gutterBottom>
                        {errorMessage}
                    </Typography>
                )}
                <Box marginBottom={2}>
                    <Typography variant="subtitle1">Choose Transaction Mode</Typography>
                    <RadioGroup
                        row
                        value={transactionMode}
                        onChange={(e) => setTransactionMode(e.target.value as 'manual' | 'csv')}
                    >
                        <FormControlLabel value="csv" control={<Radio />} label="CSV Import" />
                        <FormControlLabel value="manual" control={<Radio />} label="Manual Entry" />
                    </RadioGroup>
                </Box>
                {transactionMode === 'csv' ? (
                    renderCsvImportSection()
                ) : (
                    <TransactionForm
                        transaction={currentTransaction}
                        onChange={setCurrentTransaction}
                        onSave={handleSaveManualTransaction}
                        isEditing={false} // Assuming we're adding a new transaction here
                    />
                )}
            </DialogContent>
            <DialogActions>
                <Button onClick={onClose} color="primary">Cancel</Button>
            </DialogActions>
        </Dialog>
    );
};

export default AddTransactionDialog;import React from 'react';
import {
    Dialog, DialogTitle, DialogContent, DialogActions, Button
} from '@mui/material';

interface BulkEditDialogProps {
    open: boolean;
    onClose: () => void;
    selectedTransactions: number[];
}

const BulkEditDialog: React.FC<BulkEditDialogProps> = ({ open, onClose, selectedTransactions }) => {
    return (
        <Dialog open={open} onClose={onClose}>
            <DialogTitle>Bulk Edit Transactions</DialogTitle>
            <DialogContent>
                {/* Placeholder content, to be customized based on your editing needs */}
                <p>{`You have selected ${selectedTransactions.length} transactions for bulk editing.`}</p>
                {/* Add form fields or bulk edit options here */}
            </DialogContent>
            <DialogActions>
                <Button onClick={onClose} color="primary">Cancel</Button>
                <Button onClick={onClose} color="primary">Apply Changes</Button>
            </DialogActions>
        </Dialog>
    );
};

export default BulkEditDialog;
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { IconButton } from '@mui/material';
import { Delete } from '@mui/icons-material';
import apiClient from '../api/axios';
import { Wallet } from '../types/Wallet';

interface DeleteWalletButtonProps {
    wallet: Wallet;
    onDelete: () => void;
    showSnackbar: (message: string, severity: 'success' | 'error') => void;
}

const DeleteWalletButton: React.FC<DeleteWalletButtonProps> = ({ wallet, onDelete, showSnackbar }) => {
    const navigate = useNavigate();
    
    const handleDeleteWallet = async () => {
        try {
            await apiClient.delete(`/portfolios/1/wallets/${wallet.id}`);  // Replace 1 with your portfolio ID
            onDelete();
            showSnackbar('Wallet deleted successfully.', 'success');
            navigate('/');
        } catch (error) {
            console.error('Error deleting wallet:', error);
            showSnackbar('Error deleting wallet. Please try again.', 'error');
        }
    };

    return (
        <IconButton onClick={handleDeleteWallet}>
            <Delete />
        </IconButton>
    );
};

export default DeleteWalletButton;
import React, { useState, useEffect } from 'react';
import { Box, CssBaseline, Toolbar, AppBar, Typography, IconButton } from '@mui/material';
import { AccountCircle } from '@mui/icons-material';
import { Routes, Route, BrowserRouter as Router } from 'react-router-dom';
import WalletList from './WalletList'; // Import your components/pages
import LeftMenu from './LeftMenu'; // Import the LeftMenu component
import { Wallet } from '../types/Wallet';
import MainPage from './MainPage';

const drawerWidthExpanded = 240;
const drawerWidthCollapsed = 60;

interface LayoutProps {
    darkMode: boolean;
    onToggleDarkMode: () => void;
}

const Layout: React.FC<LayoutProps> = ({ darkMode, onToggleDarkMode }) => {
    const [selectedWallet, setSelectedWallet] = useState<Wallet | null>(null);
    const [menuCollapsed, setMenuCollapsed] = useState(false);

    const handleSelectWallet = (walletId: Wallet | null) => {
        setSelectedWallet(walletId);
    };

    const showSnackbar = (message: string, severity: 'success' | 'error') => {
        console.log(message, severity); // Replace with actual snackbar implementation
    };

        // Function to handle wallet deletion and navigate back to the main page
        const handleWalletDeleted = () => {
            showSnackbar('Wallet deleted successfully.', 'success');
            //navigate('/'); // Redirect to the main page
        };

        // Trigger a window resize event whenever the menu collapses or expands
        useEffect(() => {
            const resizeGrid = () => {
                window.dispatchEvent(new Event('resize'));
            };
            resizeGrid(); // Trigger resize on initial load
            window.addEventListener('resize', resizeGrid);
    
            return () => {
                window.removeEventListener('resize', resizeGrid);
            };
        }, [menuCollapsed]);

    return (
        <Router>
            <Box sx={{ display: 'flex', height: '100vh', overflow: 'hidden' }}>
                <CssBaseline />
                <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
                    <Toolbar>
                        <Typography variant="h6" noWrap sx={{ flexGrow: 1 }}>
                            Portfolio Manager
                        </Typography>
                        <IconButton edge="end" color="inherit">
                            <AccountCircle />
                        </IconButton>
                    </Toolbar>
                </AppBar>
                <LeftMenu onWalletDeleted={handleWalletDeleted}  onSelectWallet={handleSelectWallet} showSnackbar={showSnackbar} />
                <Box
                    component="main"
                    sx={{
                        flexGrow: 1,
                        bgcolor: 'background.default',
                        p: 3,
                        transition: 'margin-left 0.3s'
                    }}
                >
                    <Toolbar />
                    <Routes>
                    <Route path="/" element={<MainPage />} />
                        <Route path="/" element={<WalletList allWallets />} />
                        {selectedWallet !== null && (
                            <Route
                                path={`/wallets/${selectedWallet.id}`}
                                element={<WalletList wallet={selectedWallet} />}
                            />
                        )}                        
                        <Route path="/another-page" element={<Typography variant="h4">Another Page</Typography>} />
                    </Routes>
                </Box>
            </Box>
        </Router>
    );
};

export default Layout;
import React, { useState, useEffect } from 'react';
import {
    List, ListItem, ListItemText, Button, Divider, Box, Toolbar, IconButton, ListItemIcon, Tooltip
} from '@mui/material';
import { Add, ChevronLeft, ChevronRight, Wallet, AccountBalanceWallet } from '@mui/icons-material';
import { Link } from 'react-router-dom';
import apiClient from '../api/axios';
import { Wallet as WalletType } from '../types/Wallet';
import NewWalletDialog from './NewWalletDialog';
import DeleteWalletButton from './DeleteWalletButton';

interface LeftMenuProps {
    onSelectWallet: (wallet: WalletType | null) => void;
    showSnackbar: (message: string, severity: 'success' | 'error') => void;
    onWalletDeleted: () => void;  // Add this prop to handle wallet deletion
}

const drawerWidthExpanded = 240;
const drawerWidthCollapsed = 60;

const LeftMenu: React.FC<LeftMenuProps> = ({ onSelectWallet, showSnackbar, onWalletDeleted }) => {
    const [wallets, setWallets] = useState<WalletType[]>([]);
    const [newWalletDialogOpen, setNewWalletDialogOpen] = useState(false);
    const [menuCollapsed, setMenuCollapsed] = useState(false); // State for collapse/expand

    useEffect(() => {
        fetchWallets();
    }, []);

    const fetchWallets = async () => {
        try {
            const response = await apiClient.get<WalletType[]>('/portfolios/1/wallets');  // Replace 1 with your portfolio ID
            setWallets(response.data);
        } catch (error) {
            console.error('Error fetching wallets:', error);
        }
    };

    const handleWalletCreated = () => {
        setNewWalletDialogOpen(false);
        fetchWallets();
    };

    const handleAddWallet = () => {
        setNewWalletDialogOpen(true);
    };

    const toggleMenuCollapse = () => {
        setMenuCollapsed(!menuCollapsed);
    };

    return (
        <Box
            sx={{
                width: menuCollapsed ? drawerWidthCollapsed : drawerWidthExpanded,
                flexShrink: 0,
                whiteSpace: 'nowrap',
                transition: 'width 0.3s',
                [`& .MuiDrawer-paper`]: {
                    width: menuCollapsed ? drawerWidthCollapsed : drawerWidthExpanded,
                    boxSizing: 'border-box',
                    transition: 'width 0.3s'
                },
            }}
        >
            <Toolbar />
            <Box sx={{ overflow: 'auto' }}>
                <List component="nav">
                    <ListItem button onClick={toggleMenuCollapse}>
                        <ListItemIcon>
                            {menuCollapsed ? <ChevronRight /> : <ChevronLeft />}
                        </ListItemIcon>
                        {!menuCollapsed && <ListItemText primary="Collapse Menu" />}
                    </ListItem>
                    <Divider />
                    <ListItem button component={Link} to="/" onClick={() => onSelectWallet(null)}>
                        <Tooltip title="All Wallets" placement="right">
                            <ListItemIcon>
                                <AccountBalanceWallet />
                            </ListItemIcon>
                        </Tooltip>
                        {!menuCollapsed && <ListItemText primary="All Wallets" />}
                    </ListItem>
                    <Divider />
                    {wallets.map((wallet) => (
                        <ListItem
                            button
                            key={wallet.id}
                            component={Link}
                            to={`/wallets/${wallet.id}`}
                            onClick={() => onSelectWallet(wallet)}
                            sx={{ display: 'flex', justifyContent: 'space-between' }} // Aligns delete button to the right
                        >
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <Tooltip title={wallet.name} placement="right">
                                    <ListItemIcon>
                                        <Wallet />
                                    </ListItemIcon>
                                </Tooltip>
                                {!menuCollapsed && <ListItemText primary={wallet.name} />}
                            </Box>
                            {!menuCollapsed && (
                                <DeleteWalletButton 
                                    wallet={wallet} 
                                    onDelete={() => {
                                        fetchWallets();
                                        onWalletDeleted(); // Trigger redirect to the main page
                                    }} 
                                    showSnackbar={showSnackbar} 
                                />
                            )}
                        </ListItem>
                    ))}
                    <Divider />
                    <ListItem>
                        <Button
                            variant="contained"
                            color="primary"
                            startIcon={<Add />}
                            onClick={handleAddWallet}
                            fullWidth={!menuCollapsed}
                            sx={{ justifyContent: menuCollapsed ? 'center' : 'flex-start' }}
                        >
                            {!menuCollapsed && "Add Wallet"}
                        </Button>
                    </ListItem>
                </List>
            </Box>
            <NewWalletDialog
                open={newWalletDialogOpen}
                onClose={() => setNewWalletDialogOpen(false)}
                onWalletCreated={handleWalletCreated}
                showSnackbar={showSnackbar}
            />
        </Box>
    );
};

export default LeftMenu;
import React from 'react';
import { Box, Typography } from '@mui/material';

const MainPage: React.FC = () => {
    return (
        <Box sx={{ padding: '20px' }}>
            <Typography variant="h4" gutterBottom>
                Welcome to Your Portfolio
            </Typography>
            <Typography variant="body1">
                Please select a wallet from the left menu to view its transactions, or create a new wallet to start tracking your cryptocurrency assets.
            </Typography>
        </Box>
    );
};

export default MainPage;
import React, { useState } from 'react';
import { AppBar, Toolbar, IconButton, Menu, MenuItem, Typography, Switch } from '@mui/material';
import { AccountCircle } from '@mui/icons-material';

interface NavbarProps {
  darkMode: boolean;
  onToggleDarkMode: () => void;
}

const Navbar: React.FC<NavbarProps> = ({ darkMode, onToggleDarkMode }) => {
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);

  const handleMenu = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  return (
    <AppBar position="static">
      <Toolbar variant="regular" disableGutters>
        <Typography variant="h6" style={{ flexGrow: 1 }}>
          Portfolio
        </Typography>
        <div>
          <IconButton edge="end" color="inherit" onClick={handleMenu}>
            <AccountCircle />
          </IconButton>
          <Menu
            anchorEl={anchorEl}
            keepMounted
            open={Boolean(anchorEl)}
            onClose={handleClose}
          >
            <MenuItem>
              <Typography variant="body1">Dark Mode</Typography>
              <Switch checked={darkMode} onChange={onToggleDarkMode} />
            </MenuItem>
            <MenuItem onClick={handleClose}>Logout</MenuItem>
          </Menu>
        </div>
      </Toolbar>
    </AppBar>
  );
};

export default Navbar;
import React, { useState } from 'react';
import {
    Dialog, DialogTitle, DialogContent, DialogActions, Button, TextField
} from '@mui/material';
import apiClient from '../api/axios';

interface NewWalletDialogProps {
    open: boolean;
    onClose: () => void;
    onWalletCreated: () => void;
    showSnackbar: (message: string, severity: 'success' | 'error') => void;
}

const NewWalletDialog: React.FC<NewWalletDialogProps> = ({ open, onClose, onWalletCreated, showSnackbar }) => {
    const [walletName, setWalletName] = useState('');

    const handleCreateWallet = async () => {
        if (!walletName.trim()) {
            showSnackbar('Wallet name cannot be empty.', 'error');
            return;
        }

        try {
            await apiClient.post('/portfolios/1/wallets', { name: walletName });  // Replace 1 with your portfolio ID
            showSnackbar('Wallet created successfully.', 'success');
            onWalletCreated();
            onClose();
        } catch (error) {
            console.error('Error creating wallet:', error);
            showSnackbar('Error creating wallet. Please try again.', 'error');
        }
    };

    return (
        <Dialog open={open} onClose={onClose}>
            <DialogTitle>Create New Wallet</DialogTitle>
            <DialogContent>
                <TextField
                    autoFocus
                    fullWidth
                    margin="dense"
                    label="Wallet Name"
                    value={walletName}
                    onChange={(e) => setWalletName(e.target.value)}
                />
            </DialogContent>
            <DialogActions>
                <Button onClick={onClose} color="primary">Cancel</Button>
                <Button onClick={handleCreateWallet} color="primary">Create</Button>
            </DialogActions>
        </Dialog>
    );
};

export default NewWalletDialog;
import React from 'react';
import {
    TextField, MenuItem, Select, InputLabel, FormControl, Button, Grid
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { DateTimePicker } from '@mui/x-date-pickers';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import dayjs from 'dayjs';
import { CryptoCurrencyTransactionDto } from '../types/Wallet';

interface TransactionFormProps {
    transaction: CryptoCurrencyTransactionDto | null;
    onChange: (transaction: CryptoCurrencyTransactionDto) => void;
    onSave: () => void;
    isEditing: boolean;
}

const TransactionForm: React.FC<TransactionFormProps> = ({ transaction, onChange, onSave, isEditing }) => {
    return (
        <>
            <Grid container spacing={2}>
                <Grid item xs={12} sm={6}>
                    <FormControl fullWidth margin="dense">
                        <InputLabel>Transaction Type</InputLabel>
                        <Select
                            fullWidth
                            value={transaction?.type || ''}
                            disabled={isEditing}
                            onChange={(e) =>
                                onChange({
                                    ...transaction!,
                                    type: e.target.value,
                                })
                            }
                            label="Transaction Type"
                        >
                            <MenuItem value="Deposit">Deposit</MenuItem>
                            <MenuItem value="Withdrawal">Withdrawal</MenuItem>
                            <MenuItem value="Trade">Trade</MenuItem>
                        </Select>
                    </FormControl>
                </Grid>
                <Grid item xs={12} sm={6}>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DateTimePicker
                            label="Transaction Date"
                            value={dayjs(transaction?.dateTime || new Date())}
                            onChange={(date) => {
                                onChange({
                                    ...transaction!,
                                    dateTime: date?.toDate() || new Date(), // Handle null case by setting to current date
                                });
                            }}
                            slotProps={{ textField: { margin: "dense", fullWidth: true } }}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={12} sm={6}>
                    <TextField
                        fullWidth
                        margin="dense"
                        label="Received Amount"
                        type="number"
                        value={transaction?.receivedAmount || ''}
                        onChange={(e) => onChange({ ...transaction!, receivedAmount: parseFloat(e.target.value) })}
                        InputProps={{ style: { fontSize: '0.875rem' } }}  // Smaller input text
                        disabled={transaction?.type == "Withdrawal"}
                    />
                </Grid>
                <Grid item xs={12} sm={6}>
                    <TextField
                        fullWidth
                        margin="dense"
                        label="Received Currency"
                        value={transaction?.receivedCurrency || ''}
                        onChange={(e) => onChange({ ...transaction!, receivedCurrency: e.target.value })}
                        InputProps={{ style: { fontSize: '0.875rem' } }}  // Smaller input text
                        disabled={transaction?.type == "Withdrawal"}
                    />
                </Grid>
                <Grid item xs={12} sm={6}>
                    <TextField
                        fullWidth
                        margin="dense"
                        label="Sent Amount"
                        type="number"
                        value={transaction?.sentAmount || ''}
                        onChange={(e) => onChange({ ...transaction!, sentAmount: parseFloat(e.target.value) })}
                        InputProps={{ style: { fontSize: '0.875rem' } }}  // Smaller input text
                        disabled={transaction?.type == "Deposit"}
                    />
                </Grid>
                <Grid item xs={12} sm={6}>
                    <TextField
                        fullWidth
                        margin="dense"
                        label="Sent Currency"
                        value={transaction?.sentCurrency || ''}
                        onChange={(e) => onChange({ ...transaction!, sentCurrency: e.target.value })}
                        InputProps={{ style: { fontSize: '0.875rem' } }}  // Smaller input text
                        disabled={transaction?.type == "Deposit"}
                    />
                </Grid>
                <Grid item xs={12} sm={6}>

                    <TextField
                        fullWidth
                        margin="dense"
                        label="Fee Amount"
                        type="number"
                        value={transaction?.feeAmount || ''}
                        onChange={(e) => onChange({ ...transaction!, feeAmount: parseFloat(e.target.value) })}
                        InputProps={{ style: { fontSize: '0.875rem' } }}  // Smaller input text
                    />
                </Grid>
                <Grid item xs={12} sm={6}>

                    <TextField
                        fullWidth
                        margin="dense"
                        label="Fee Currency"
                        value={transaction?.feeCurrency || ''}
                        onChange={(e) => onChange({ ...transaction!, feeCurrency: e.target.value })}
                        InputProps={{ style: { fontSize: '0.875rem' } }}  // Smaller input text
                    />
                </Grid>
                <Grid item xs={12} sm={6}>

                    <TextField
                        fullWidth
                        margin="dense"
                        label="Account"
                        value={transaction?.account || ''}
                        onChange={(e) => onChange({ ...transaction!, account: e.target.value })}
                        InputProps={{ style: { fontSize: '0.875rem' } }}  // Smaller input text
                    />
                </Grid>
                <Grid item xs={12}>

                    <TextField
                        multiline
                        rows={5}
                        fullWidth
                        margin="dense"
                        label="Note"
                        value={transaction?.note || ''}
                        onChange={(e) => onChange({ ...transaction!, note: e.target.value })}
                        InputProps={{ style: { fontSize: '0.875rem' } }}  // Smaller input text
                    />
                </Grid>
            </Grid>
            <Button
                variant="contained"
                color="primary"
                onClick={onSave}
                style={{ marginTop: '15px' }}
            >
                {isEditing ? 'Save Changes' : 'Add Transaction'}
            </Button>
        </>
    );
};

export default TransactionForm;
import React, { useState, useEffect } from 'react';
import {
    IconButton, Typography, Snackbar, Alert,
    Dialog, DialogTitle, DialogContent, DialogActions, Button, Box, MenuItem, Select, InputLabel, FormControl
} from '@mui/material';
import { Delete, Edit, Add, Download } from '@mui/icons-material';
import { DataGrid, GridColDef, GridRenderCellParams } from '@mui/x-data-grid';
import apiClient from '../api/axios';
import { Wallet, CryptoCurrencyTransactionDto } from '../types/Wallet';
import dayjs from 'dayjs';
import TransactionForm from './TransactionForm'
import AddTransactionDialog from './AddTransactionDialog'
import BulkEditDialog from './BulkEditDialog';

interface WalletListProps {
    allWallets?: boolean;
    wallet?: Wallet | null;
}

const WalletList: React.FC<WalletListProps> = ({ allWallets = false, wallet = null }) => {
    const [transactions, setTransactions] = useState<CryptoCurrencyTransactionDto[]>([]);
    const [isEditing, setIsEditing] = useState(false);
    const [currentTransaction, setCurrentTransaction] = useState<CryptoCurrencyTransactionDto | null>(null);
    const [dialogOpen, setDialogOpen] = useState(false);
    const [exportFormat, setExportFormat] = useState('xlsx');
    const [errorMessage, setErrorMessage] = useState<string | null>(null);
    const [transactionDialogOpen, setTransactionDialogOpen] = useState(false);
    const [snackbarOpen, setSnackbarOpen] = useState(false);
    const [snackbarMessage, setSnackbarMessage] = useState('');
    const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error'>('success');
    const [deleting, setDeleting] = useState<number | null>(null); // Track the ID of the deleting transaction
    const [selectedTransactions, setSelectedTransactions] = useState<number[]>([]);
    const [bulkEditDialogOpen, setBulkEditDialogOpen] = useState(false);
    const [bulkEditOption, setBulkEditOption] = useState(''); // Track the selected bulk edit option
    const [bulkAction, setBulkAction] = useState<string | null>(null); // Track the selected bulk action
    const [confirmDeleteOpen, setConfirmDeleteOpen] = useState(false);

    useEffect(() => {
        if (allWallets) {
            fetchTransactions(null);
        } else if (wallet) {
            fetchTransactions(wallet?.id);
        }
    }, [allWallets, wallet]);

    const fetchTransactions = async (walletId: number | null) => {
        try {
            if (walletId === null) {
                const response = await apiClient.get<CryptoCurrencyTransactionDto[]>('/portfolios/1/transactions'); // Replace with the appropriate API endpoint
                setTransactions(response.data);
            }
            else {
                const response = await apiClient.get<CryptoCurrencyTransactionDto[]>(`/portfolios/1/wallets/${walletId}/transactions`);
                setTransactions(response.data);
            }
        } catch (error) {
            console.error('Error fetching transactions:', error);
            showSnackbar('Error fetching transactions from wallet(s).', 'error');
        }
    };

    const handleDeleteTransaction = async (transactionId: number) => {

        try {
            // Optimistically update the state
            const updatedTransactions = transactions.filter(transaction => transaction.id !== transactionId);
            setTransactions(updatedTransactions);
            setDeleting(transactionId);  // Set the deleting state to the ID of the transaction being deleted

            if (wallet) {
                await apiClient.delete(`/portfolios/1/wallets/${wallet.id}/transactions/${transactionId}`);
                setTransactions(transactions.filter(transaction => transaction.id !== transactionId));
                showSnackbar('Transaction deleted successfully.', 'success');
            }
        } catch (error) {
            // Rollback the state update if the API call fails
            setTransactions(transactions);
            console.error('Error deleting transaction:', error);
            showSnackbar('Error deleting transaction. Please try again.', 'error');
        } finally {
            // Temporarily disable the button to prevent double click
            setDeleting(null);  // Clear the deleting state once deletion is complete
        }
    };

    const handleBulkDelete = async () => {
        try {
            await apiClient.delete(`/portfolios/1/wallets/${wallet?.id}/transactions/bulk-delete`, {
                data: selectedTransactions, // Send selected transaction IDs
            });
            setTransactions(transactions.filter(transaction => !selectedTransactions.includes(transaction.id)));
            setSelectedTransactions([]);  // Clear selection after deletion
            showSnackbar('Selected transactions deleted successfully.', 'success');
        } catch (error) {
            console.error('Error deleting transactions:', error);
            showSnackbar('Error deleting transactions. Please try again.', 'error');
        }
    };



    const handleEditTransaction = (transaction: CryptoCurrencyTransactionDto) => {
        setCurrentTransaction(transaction);
        setIsEditing(true);
        setDialogOpen(true);
    };


    const handleBulkEdit = async (updatedFields: Partial<CryptoCurrencyTransactionDto>) => {
        try {
            const transactionsToUpdate = selectedTransactions.map(id => ({
                ...transactions.find(t => t.id === id),
                ...updatedFields, // Apply the updated fields
            }));

            await apiClient.put(`/portfolios/1/wallets/${wallet?.id}/transactions/bulk-edit`, transactionsToUpdate);

            // Optionally, refetch transactions from the server
            await fetchTransactions(wallet?.id!);

            setBulkEditDialogOpen(false);
            setSelectedTransactions([]);  // Clear selection after edit
            showSnackbar('Selected transactions updated successfully.', 'success');
        } catch (error) {
            console.error('Error updating transactions:', error);
            showSnackbar('Error updating transactions. Please try again.', 'error');
        }
    };



    const handleDialogClose = () => {
        setDialogOpen(false);
        setCurrentTransaction(null);
    };

    const handleSaveTransaction = async () => {
        if (!currentTransaction || !wallet) return;
        try {
            setErrorMessage(null); // Clear previous error message

            if (isEditing) {
                // If editing, use PUT to update the transaction
                await apiClient.put(`/portfolios/1/wallets/${wallet.id}/transactions/${currentTransaction.id}`, currentTransaction);
            } else {
                // If not editing, use POST to create a new transaction
                await apiClient.post(`/portfolios/1/wallets/${wallet.id}/transactions`, currentTransaction);
            }

            // Refresh the transactions from the server only after a successful save
            await fetchTransactions(wallet.id);
            handleDialogClose();
        } catch (error: any) {
            console.error('Error saving transaction:', error);
            if (error.response && error.response.data && typeof error.response.data === 'string') {
                setErrorMessage(error.response.data); // Display server error message
            } else {
                setErrorMessage('An unexpected error occurred. Please try again.'); // Generic error message
            }
        }
    };

    const handleAddTransaction = () => {
        setTransactionDialogOpen(true);
    };

    const handleTransactionDialogClose = () => {
        setTransactionDialogOpen(false);
        fetchTransactions(wallet?.id || 0); // Refresh transactions after dialog closes
    };

    const handleBulkAction = (action: string | null) => {
        if (action === 'bulkEdit') {
            setBulkEditDialogOpen(true);  // Open bulk edit dialog
        } else if (action === 'bulkDelete') {
            setConfirmDeleteOpen(true);  // Trigger bulk delete action
        }
        // Clear the selection after the action
        setBulkAction("");
    };

    const handleExport = async () => {
        if (!wallet) return;
        try {
            const response = await apiClient.get(`/portfolios/1/wallets/${wallet.id}/export?format=${exportFormat}`, {
                responseType: 'blob', // To handle file downloads
            });
            const url = window.URL.createObjectURL(new Blob([response.data]));
            const link = document.createElement('a');
            link.href = url;
            link.setAttribute('download', `transactions.${exportFormat}`);
            document.body.appendChild(link);
            link.click();
        } catch (error) {
            console.error('Error exporting transactions:', error);
        }
    };

    const showSnackbar = (message: string, severity: 'success' | 'error' = 'success') => {
        setSnackbarMessage(message);
        setSnackbarSeverity(severity);
        setSnackbarOpen(true);
    };

    const columns: GridColDef[] = [
        {
            field: 'dateTime',
            headerName: 'Date',
            flex: 2,
            valueGetter: (params: any, tx: CryptoCurrencyTransactionDto) => {
                return dayjs(tx.dateTime).format('YYYY-MM-DD HH:mm:ss UTC');
            },
        },
        { field: 'type', headerName: 'Type', flex: 1 },
        {
            field: 'receivedAmount',
            headerName: 'Received Amount',
            flex: 1,
            valueGetter: (params: any, tx: CryptoCurrencyTransactionDto) =>
                `${tx.receivedAmount ?? ''} ${tx.receivedCurrency ?? ''}`,
        },
        {
            field: 'sentAmount',
            headerName: 'Sent Amount',
            flex: 1,
            valueGetter: (params: any, tx: CryptoCurrencyTransactionDto) =>
                `${tx.sentAmount ?? ''} ${tx.sentCurrency ?? ''}`,
        },
        {
            field: 'feeAmount',
            headerName: 'Fee',
            //width: 20,
            flex: 1,
            valueGetter: (params: any, tx: CryptoCurrencyTransactionDto) =>
                `${tx.feeAmount ?? ''} ${tx.feeCurrency ?? ''}`,
        },
        { field: 'account', headerName: 'Account', flex: 1 },
        { field: 'note', headerName: 'Note', flex: 2 },
        {
            field: 'actions',
            headerName: 'Actions',
            flex: 0,
            sortable: false,
            renderCell: (params: GridRenderCellParams) => (
                <>
                    <IconButton
                        onClick={() => handleEditTransaction(params.row as CryptoCurrencyTransactionDto)}
                        disabled={deleting !== null}  // Disable the edit button when deleting is in progress
                    >
                        <Edit />
                    </IconButton>
                    <IconButton
                        onClick={() => handleDeleteTransaction((params.row as CryptoCurrencyTransactionDto).id)}
                        disabled={deleting === (params.row as CryptoCurrencyTransactionDto).id}  // Disable only the delete button for the transaction being deleted
                    >
                        <Delete />
                    </IconButton>
                </>
            ),
        },
    ];

    return (
        <div style={{ padding: '20px' }}>
            <Typography variant="h1" gutterBottom>{wallet?.name}</Typography>

            {wallet && (
                <div style={{ marginTop: '20px' }}>
                    <Box display="flex" justifyContent="space-between" mb={2}>
                        <Box display="flex" alignItems="left">
                            <Button
                                variant="contained"
                                color="primary"
                                startIcon={<Add />}
                                onClick={handleAddTransaction}
                                sx={{ mr: 2 }}
                            >
                                Add Transactions
                            </Button>
                            <FormControl variant="outlined" size="small" sx={{ minWidth: 150, mr: 2 }}>
                                <Select
                                    value={bulkAction}
                                    color='secondary'
                                    onChange={(e) => {
                                        setBulkAction(e.target.value);
                                        handleBulkAction(e.target.value);
                                    }}
                                    displayEmpty
                                    sx={{
                                        //backgroundColor: '#1976d2',
                                        color: 'white',
                                        //textTransform: 'uppercase',
                                        '& .MuiSelect-icon': {
                                            color: 'white',
                                        },
                                        '& .MuiOutlinedInput-notchedOutline': {
                                            //borderColor: 'transparent',
                                        },
                                        '&:hover .MuiOutlinedInput-notchedOutline': {
                                            //borderColor: 'transparent',
                                        },
                                        '&:focus .MuiOutlinedInput-notchedOutline': {
                                            //borderColor: 'transparent',
                                        },
                                    }}
                                //renderValue={(selected) => (selected ? selected : 'Bulk Actions')}
                                >
                                    <MenuItem value="" disabled>Bulk Action</MenuItem>
                                    <MenuItem value="bulkEdit">Bulk Edit</MenuItem>
                                    <MenuItem value="bulkDelete">Bulk Delete</MenuItem>
                                </Select>
                            </FormControl>
                        </Box>
                        <Box display="flex" alignItems="center">
                            <FormControl variant="outlined" size="small" sx={{ minWidth: 120, mr: 2 }}>
                                <InputLabel>Export Format</InputLabel>
                                <Select
                                    value={exportFormat}
                                    onChange={(e) => setExportFormat(e.target.value)}
                                    label="Export Format"
                                >
                                    <MenuItem value="xlsx">Excel (.xlsx)</MenuItem>
                                    <MenuItem value="csv">CSV (.csv)</MenuItem>
                                </Select>
                            </FormControl>
                            <Button
                                variant="contained"
                                color="secondary"
                                startIcon={<Download />}
                                onClick={handleExport}
                            >
                                Export
                            </Button>
                        </Box>
                    </Box>
                    <Typography variant="h6">Transactions for {wallet.name}</Typography>
                    <div style={{ display: 'flex', height: '100%' }}>
                        <div style={{ flexGrow: 1 }}>
                            <DataGrid
                                rows={transactions}
                                columns={columns}
                                initialState={{
                                    pagination: {
                                        paginationModel: {
                                            pageSize: 25,
                                        },
                                    },
                                }}
                                pageSizeOptions={[10, 25, 100]}
                                autoHeight
                                disableRowSelectionOnClick
                                checkboxSelection
                                onRowSelectionModelChange={(newSelection) => setSelectedTransactions(newSelection as number[])}

                            />
                        </div>
                    </div>
                </div>
            )}

            <Dialog open={dialogOpen} onClose={handleDialogClose}>
                <DialogTitle>{isEditing ? 'Edit Transaction' : 'Add Transaction'}</DialogTitle>
                <DialogContent>
                    {errorMessage && (
                        <Typography color="error" variant="body2" gutterBottom>
                            {errorMessage}
                        </Typography>
                    )}
                    <TransactionForm
                        transaction={currentTransaction}
                        onChange={setCurrentTransaction}
                        onSave={handleSaveTransaction}
                        isEditing={isEditing}
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleDialogClose} color="primary">Cancel</Button>
                </DialogActions>
            </Dialog>

            <AddTransactionDialog
                open={transactionDialogOpen}
                onClose={handleTransactionDialogClose}
                onTransactionAdded={handleTransactionDialogClose}
                selectedWalletId={wallet?.id || 0}
                showSnackbar={showSnackbar}  // Pass showSnackbar to the dialog
            />
            <BulkEditDialog
                open={bulkEditDialogOpen}
                onClose={() => setBulkEditDialogOpen(false)}
                selectedTransactions={selectedTransactions}
            />
            <Dialog
                open={confirmDeleteOpen}
                onClose={() => setConfirmDeleteOpen(false)}
            >
                <DialogTitle>Confirm Bulk Delete</DialogTitle>
                <DialogContent>
                    <Typography>Are you sure you want to delete the selected transactions?</Typography>
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setConfirmDeleteOpen(false)} color="primary">
                        Cancel
                    </Button>
                    <Button
                        onClick={() => {
                            setConfirmDeleteOpen(false);
                            handleBulkDelete();  // Perform bulk delete after confirmation
                        }}
                        color="secondary"
                    >
                        Delete
                    </Button>
                </DialogActions>
            </Dialog>


            <Snackbar
                open={snackbarOpen}
                autoHideDuration={6000}
                onClose={() => setSnackbarOpen(false)}
                anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
            >
                <Alert onClose={() => setSnackbarOpen(false)} severity={snackbarSeverity} sx={{ width: '100%' }}>
                    {snackbarMessage}
                </Alert>
            </Snackbar>
        </div>
    );
};

export default WalletList;
export interface CryptoCurrencyTransactionDto {
    id: number;
    dateTime: Date;
    type: string;
    receivedAmount?: number;
    receivedCurrency: string;
    sentAmount?: number;
    sentCurrency: string;
    feeAmount?: number;
    feeCurrency: string;
    account: string;
    note: string;
  }
  
  export interface Wallet {
    id: number;
    name: string;
    transactions: CryptoCurrencyTransactionDto[];
  }
  

  export enum CsvFileImportType {
    Kraken = 'Kraken',
    Coinbase = 'Coinbase',
    Binance = 'Binance',
    // Add more import types as needed
}