// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Portfolio.App")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+4834734cd94a4799d9d51fe5ea6241fd39baa561")]
[assembly: System.Reflection.AssemblyProductAttribute("Portfolio.App")]
[assembly: System.Reflection.AssemblyTitleAttribute("Portfolio.App")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
using CSharpFunctionalExtensions;

namespace Portfolio.App.HistoricalPrice;

public interface IPriceHistoryServiceFactory
{
    Task<Result<IPriceHistoryService>> Create(string symbolFrom, string symbolTo, DateTime startDate, DateTime endDate);
}
using System;
using System.Collections.Generic;
using System.Data;
using Microsoft.Data.Sqlite;
using System.Threading.Tasks;
using CSharpFunctionalExtensions;
using Serilog;

namespace Portfolio.App.HistoricalPrice
{
    public class SQLitePriceHistoryStorageService : IPriceHistoryStorageService
    {
        private readonly string _connectionString;

        public SQLitePriceHistoryStorageService(string databaseFilePath)
        {
            _connectionString = $"Data Source={databaseFilePath};";
            InitializeDatabase();
        }

        private void InitializeDatabase()
        {
            using var connection = new SqliteConnection(_connectionString);
            connection.Open();

            string createTableQuery = @"
                CREATE TABLE IF NOT EXISTS CryptoPriceRecords (
                    Id INTEGER PRIMARY KEY AUTOINCREMENT,
                    CurrencyPair TEXT NOT NULL,
                    CloseDate TEXT NOT NULL,
                    ClosePrice REAL NOT NULL,
                    UNIQUE(CurrencyPair, CloseDate)
                );";

            using var command = new SqliteCommand(createTableQuery, connection);
            command.ExecuteNonQuery();
        }

        public async Task<Result<IEnumerable<CryptoPriceRecord>>> LoadHistoryAsync(string symbol)
        {
            var priceHistory = new List<CryptoPriceRecord>();

            try
            {
                using var connection = new SqliteConnection(_connectionString);
                await connection.OpenAsync();

                string query = "SELECT CurrencyPair, CloseDate, ClosePrice FROM CryptoPriceRecords WHERE CurrencyPair = @CurrencyPair ORDER BY CloseDate;";
                using var command = new SqliteCommand(query, connection);
                command.Parameters.AddWithValue("@CurrencyPair", symbol);

                using var reader = await command.ExecuteReaderAsync();
                while (await reader.ReadAsync())
                {
                    var currencyPair = reader.GetString(0);
                    var closeDate = DateTime.Parse(reader.GetString(1));
                    var closePrice = reader.GetDecimal(2);

                    priceHistory.Add(new CryptoPriceRecord
                    {
                        CurrencyPair = currencyPair,
                        CloseDate = closeDate,
                        ClosePrice = closePrice
                    });
                }

                return Result.Success<IEnumerable<CryptoPriceRecord>>(priceHistory);
            }
            catch (Exception ex)
            {
                Log.Error($"[{nameof(SQLitePriceHistoryStorageService)}.{nameof(LoadHistoryAsync)}] An error occurred: {ex.GetBaseException().Message}");
                return Result.Failure<IEnumerable<CryptoPriceRecord>>("Error loading data from SQLite.");
            }
        }


        public async Task<Result> SaveHistoryAsync(string symbol, IEnumerable<CryptoPriceRecord> priceHistory)
        {
            try
            {
                using var connection = new SqliteConnection(_connectionString);
                await connection.OpenAsync();

                using var transaction = connection.BeginTransaction();

                string upsertQuery = @"
                    INSERT OR REPLACE INTO CryptoPriceRecords (CurrencyPair, CloseDate, ClosePrice) 
                    VALUES (@CurrencyPair, @CloseDate, @ClosePrice);";

                using var command = new SqliteCommand(upsertQuery, connection, transaction); // Associate the command with the transaction

                foreach (var record in priceHistory)
                {
                    command.Parameters.Clear();
                    command.Parameters.AddWithValue("@CurrencyPair", record.CurrencyPair);
                    command.Parameters.AddWithValue("@CloseDate", record.CloseDate.ToString("yyyy-MM-dd"));
                    command.Parameters.AddWithValue("@ClosePrice", record.ClosePrice);

                    await command.ExecuteNonQueryAsync(); // Command is now correctly associated with the transaction
                }

                transaction.Commit(); // Commit the transaction after all commands are executed

                return Result.Success();
            }
            catch (Exception ex)
            {
                Log.Error($"[{nameof(SQLitePriceHistoryStorageService)}.{nameof(SaveHistoryAsync)}] An error occurred: {ex.GetBaseException().Message}");
                return Result.Failure("Error saving data to SQLite.");
            }
        }

    }
}
using CSharpFunctionalExtensions;

namespace Portfolio.App.HistoricalPrice
{
    public interface IPriceHistoryApi
    {
        public string DetermineTradingPair(string fromSymbol, string toSymbol);
        public Task<Result<IEnumerable<CryptoPriceRecord>>> FetchPriceHistoryAsync(string symbol, DateTime startDate, DateTime endDate);
    }
}
using System.Globalization;
using CsvHelper;
using CSharpFunctionalExtensions;
using Serilog;
using CsvHelper.Configuration;

namespace Portfolio.App.HistoricalPrice;

public sealed class CryptoPriceRecordMap : ClassMap<CryptoPriceRecord>
{
    public CryptoPriceRecordMap()
    {
        AutoMap(CultureInfo.InvariantCulture);
        Map(m => m.CurrencyPair).Ignore();
    }
}

public class FilePriceHistoryStorageService : IPriceHistoryStorageService
{
    public string StorageLocation { get; set; } = "historical_price_data";

    public async Task<Result<IEnumerable<CryptoPriceRecord>>> LoadHistoryAsync(string symbol)
    {
        var csvFileName = $"{StorageLocation}/{symbol}_history.csv";

        if (!File.Exists(csvFileName))
            return Result.Failure<IEnumerable<CryptoPriceRecord>>($"File not found: {csvFileName}");

        try
        {
            using var reader = new StreamReader(csvFileName);
            using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
            csv.Context.RegisterClassMap<CryptoPriceRecordMap>();
            return await Task.FromResult(csv.GetRecords<CryptoPriceRecord>().ToList());  
        }
        catch (Exception ex)
        {
            Log.ForContext<FilePriceHistoryStorageService>().Error($"[{nameof(FilePriceHistoryStorageService)}.{nameof(LoadHistoryAsync)}] An error occurred: {ex.GetBaseException().Message}");
            
            // File might be corrupt. Delete it.
            File.Delete(csvFileName);
            
            return Result.Failure<IEnumerable<CryptoPriceRecord>>($"Error loading data from CSV.");
        }
    }

    public async Task<Result> SaveHistoryAsync(string symbol, IEnumerable<CryptoPriceRecord> priceHistory)
    {
        var csvFileName = $"{StorageLocation}/{symbol}_history.csv";

        if(!Directory.Exists(StorageLocation))
            Directory.CreateDirectory(StorageLocation);

        try
        {
            using (var writer = new StreamWriter(csvFileName))
            using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture))
            {
                csv.Context.RegisterClassMap<CryptoPriceRecordMap>();
                csv.WriteRecords(priceHistory.Select(data => new
                {
                    CloseDate = data.CloseDate.ToString(Strings.DATE_FORMAT),
                    data.ClosePrice
                }));
            }

            return await Task.FromResult(Result.Success());
        }
        catch (Exception ex)
        {
            Log.Error($"[{nameof(FilePriceHistoryStorageService)}.{nameof(SaveHistoryAsync)}] An error occurred: {ex.GetBaseException().Message}");
            return Result.Failure($"Error saving data to CSV.");
        }
    }
}
using System.Diagnostics;
using CSharpFunctionalExtensions;
using Serilog;
using YahooFinanceApi;

namespace Portfolio.App.HistoricalPrice.YahooFinance
{
    public class YahooFinancePriceHistoryApi : IPriceHistoryApi
    {
        public async Task<Result<IEnumerable<CryptoPriceRecord>>> FetchPriceHistoryAsync(string symbolPair, DateTime startDate, DateTime endDate)
        {
            try
            {
                // Log the beginning of the data fetch operation
                Log.Information("Initiating data fetch for {SymbolPair} from {StartDate:yyyy-MM-dd} to {EndDate:yyyy-MM-dd}.", symbolPair, startDate, endDate);

                // Start a timer to measure how long the data fetch takes
                var stopwatch = Stopwatch.StartNew();

                // Fetch the data from Yahoo Finance API
                var candles = await Yahoo.GetHistoricalAsync(symbolPair, startDate.Date, endDate.Date, Period.Daily);

                // Log the time taken to fetch the data
                stopwatch.Stop();
                Log.Information("Data fetch for {SymbolPair} completed in {ElapsedMilliseconds}ms. Retrieved {CandlesCount} day(s) of data.", symbolPair, stopwatch.ElapsedMilliseconds, candles.Count());

                return Result.Success(MapCandlesToCryptoPriceData(symbolPair, candles));
            }
            catch (HttpRequestException httpEx)
            {
                // Log specific errors for HTTP request issues
                Log.Error(httpEx, "HTTP error occurred while fetching data for {SymbolPair}.", symbolPair);
                return Result.Failure<IEnumerable<CryptoPriceRecord>>(Errors.ERR_YAHOO_API_FETCH_FAILURE);
            }
            catch (TimeoutException timeoutEx)
            {
                // Log timeout errors separately
                Log.Error(timeoutEx, "Timeout occurred while fetching data for {SymbolPair}.", symbolPair);
                return Result.Failure<IEnumerable<CryptoPriceRecord>>("Timeout while fetching data.");
            }
            catch (Exception ex)
            {
                // General catch-all for unexpected errors
                Log.Error(ex, "Unexpected error in {MethodName} for {SymbolPair}.", nameof(FetchPriceHistoryAsync), symbolPair);
                return Result.Failure<IEnumerable<CryptoPriceRecord>>(Errors.ERR_YAHOO_API_FETCH_FAILURE);
            }
        }

        public string DetermineTradingPair(string fromSymbol, string toSymbol)
        {
            if (FiatCurrencies.Codes.Contains(fromSymbol) && FiatCurrencies.Codes.Contains(toSymbol))
                return $"{fromSymbol}{toSymbol}=X";

            return fromSymbol switch
            {
                "IMX" => $"IMX10603-{toSymbol}",
                "GRT" => $"GRT6719-{toSymbol}",
                "RNDR" => $"RENDER-{toSymbol}",
                "UNI" => $"UNI7083-{toSymbol}",
                "BEAM" => $"BEAM28298-{toSymbol}",
                _ => $"{fromSymbol}-{toSymbol}"
            };
        }

        private static IEnumerable<CryptoPriceRecord> MapCandlesToCryptoPriceData(string currencyPair, IEnumerable<Candle> candles)
        {
            return candles.Select(c => ToCryptoPriceData(currencyPair, c));
        }

        private static CryptoPriceRecord ToCryptoPriceData(string currencyPair, Candle candle)
        {
            return new CryptoPriceRecord
            {
                CurrencyPair = currencyPair,
                CloseDate = candle.DateTime > DateTime.Now ? DateTime.Now.Date: candle.DateTime, // Yahoo API sometimes put tomorrow's date when fetching current day...
                ClosePrice = candle.Close
            };
        }
    }
}
using CSharpFunctionalExtensions;

namespace Portfolio.App.HistoricalPrice;

public class CryptoPriceRecord : ValueObject
{
    public string CurrencyPair { get; set; } = string.Empty;
    public DateTime CloseDate { get; set; }
    public decimal ClosePrice { get; set; }

    protected override IEnumerable<IComparable> GetEqualityComponents()
    {
        yield return CurrencyPair;
        yield return CloseDate;
        yield return ClosePrice;
    }
}
using System.Collections.Concurrent;
using CSharpFunctionalExtensions;
using Serilog;

namespace Portfolio.App.HistoricalPrice;

public class PriceHistoryService : IPriceHistoryService
{
    private readonly IPriceHistoryApi _priceHistoryApi;
    private readonly IPriceHistoryStorageService _priceHistoryStorage;
    private ConcurrentDictionary<string, Dictionary<DateTime, CryptoPriceRecord>> _dataStores = new();

    public string DefaultCurrency { get; set; }

    public PriceHistoryService(
        IPriceHistoryApi priceHistoryApi,
        IPriceHistoryStorageService priceHistoryStorage,
        string defaultCurrencySymbol = Strings.CURRENCY_USD)
    {
        _priceHistoryApi = priceHistoryApi ?? throw new ArgumentNullException(nameof(priceHistoryApi));
        _priceHistoryStorage = priceHistoryStorage ?? throw new ArgumentNullException(nameof(priceHistoryStorage));

        DefaultCurrency = defaultCurrencySymbol ?? throw new ArgumentNullException(nameof(defaultCurrencySymbol));
    }

    public async Task<Result<decimal>> GetPriceAtCloseTimeAsync(string symbol, DateTime date)
    {
        var dateOnly = date.Date;

        if (symbol == DefaultCurrency)
            return HandleDefaultCurrencyError(symbol);

        var history = await LoadPriceHistory(symbol);
        if (history.Any())
        {

            if (history.ContainsKey(dateOnly))
                return history[dateOnly].ClosePrice;

            if (FiatCurrencies.Codes.Contains(symbol))
            {
                var handleMissingFiatResult = HandleMissingFiatData(symbol, dateOnly, history);
                if (handleMissingFiatResult.IsSuccess)
                    return handleMissingFiatResult.Value;
            }
        }

        return await FetchAndSavePriceData(symbol, dateOnly, history);
    }

    private Result<decimal> HandleDefaultCurrencyError(string symbol)
    {
        Log.Warning("Attempted to fetch price for the same symbol as the default currency ({Symbol}).", symbol);
        return Result.Failure<decimal>(string.Format(Errors.ERR_SAME_SYMBOLS, symbol, DefaultCurrency));
    }

    private async Task<Dictionary<DateTime, CryptoPriceRecord>> LoadPriceHistory(string symbol)
    {
        return await LoadPriceHistoryFromStorageAsync(symbol);
    }

    private Result<decimal> HandleMissingFiatData(string symbol, DateTime date, Dictionary<DateTime, CryptoPriceRecord> history)
    {
        Log.Debug("Missing fiat data for {Symbol} on {Date:yyyy-MM-dd}. Trying previous working days...", symbol, date);

        var previousPriceData = GetPreviousWorkingDayPriceData(date, history);
        if (previousPriceData > -1)
        {
            Log.Debug("Fiat data found for {Symbol} on {Date:yyyy-MM-dd}.", symbol, date);
            return previousPriceData;
        }

        Log.Debug("No available fiat data for {Symbol} on previous working days..", symbol);
        return Result.Failure<decimal>($"No price data available for {symbol} on {date:yyyy-MM-dd}");
    }

    private async Task<Result<decimal>> FetchAndSavePriceData(string symbol, DateTime date, Dictionary<DateTime, CryptoPriceRecord> history)
    {
        var symbolTradingPair = _priceHistoryApi.DetermineTradingPair(symbol, DefaultCurrency);
        var endDate = AdjustEndDate(date);
        var result = await _priceHistoryApi.FetchPriceHistoryAsync(symbolTradingPair, date.Date, endDate);

        if (result.IsSuccess)
        {            
            // If save fails, we can still continue however date will be fetched all the time. 
            // Ensure error is logged and proper action is taken.
            var saveResult = await SaveNewPriceHistoryAsync(symbolTradingPair, history, result.Value)
                .TapError(Log.ForContext<PriceHistoryService>().Error); 

            UpdateHistoryWithFetchedData(history, result.Value);

            if (history.ContainsKey(date.Date))
                return history[date.Date].ClosePrice;
            else if (FiatCurrencies.Codes.Contains(symbol))
            {
                var handleMissingFiatResult = HandleMissingFiatData(symbol, date, history);
                if (handleMissingFiatResult.IsSuccess)
                    return handleMissingFiatResult.Value;
            }

            return Result.Failure<decimal>("Unexpected error has occurred. ");
        }

        return Result.Failure<decimal>(result.Error);
    }

    public async Task<Result> SaveNewPriceHistoryAsync(string symbol, Dictionary<DateTime, CryptoPriceRecord> currentHistory, IEnumerable<CryptoPriceRecord> newRecords)
    {
        var existingRecords = currentHistory.Values;

        // Filter out records that already exist
        var recordsToSave = newRecords
            .Where(newRecord => !existingRecords.Any(existingRecord =>
                existingRecord.CurrencyPair == newRecord.CurrencyPair &&
                existingRecord.CloseDate == newRecord.CloseDate))
            .ToList();

        if (recordsToSave.Any())
        {
            // Save only the new records
            return await _priceHistoryStorage.SaveHistoryAsync(symbol, recordsToSave);
        }
        else
        {
            Log.Information("No new records to save for {Symbol}.", symbol);
            return Result.Success();
        }
    }

    private DateTime AdjustEndDate(DateTime date)
    {
        var endDate = date.AddDays(365);
        return endDate > DateTime.Now ? DateTime.Now.AddDays(1) : endDate;
    }

    private void UpdateHistoryWithFetchedData(Dictionary<DateTime, CryptoPriceRecord> history, IEnumerable<CryptoPriceRecord> records)
    {
        foreach (var record in records)
        {
            var closeDate = record.CloseDate.Date;
            if (!history.ContainsKey(closeDate) && record.ClosePrice > 0)
                history[closeDate] = record;
        }
    }

    private async Task<Dictionary<DateTime, CryptoPriceRecord>> LoadPriceHistoryFromStorageAsync(string symbol)
    {
        return await _dataStores.GetOrAddAsync(symbol, async s =>
            {
                var symbolTradingPair = _priceHistoryApi.DetermineTradingPair(symbol, DefaultCurrency);
                var result = await _priceHistoryStorage.LoadHistoryAsync(symbolTradingPair);
                if (result.IsSuccess)
                {
                    return result.Value.Where(r => r.ClosePrice > 0).ToDictionary(
                        record => record.CloseDate.Date,
                        record => record
                    );
                }
                else
                {
                    // Save an empty file to avoid trying to fetch from API
                    // over and over again.      
                    var emptyDictionary = new Dictionary<DateTime, CryptoPriceRecord>();
                    var saveResult = await _priceHistoryStorage.SaveHistoryAsync(symbolTradingPair, emptyDictionary.Values)
                        .TapError(Log.Error);
                    return emptyDictionary;
                }
            });
    }

    private decimal GetPreviousWorkingDayPriceData(DateTime date, Dictionary<DateTime, CryptoPriceRecord> history)
    {
        for (int i = 1; i <= 4; i++)
        {
            var previousDate = date.AddDays(-i);
            if (history.TryGetValue(previousDate, out var priceData))
                return priceData.ClosePrice;
        }
        return -1;
    }
}
using CSharpFunctionalExtensions;
using Serilog;

namespace Portfolio.App.HistoricalPrice.CoinGecko
{
    public class CoinGeckoPriceHistoryApi : IPriceHistoryApi
    {
        private readonly HttpClient _httpClient;
        private const string BaseUrl = "https://api.coingecko.com/api/v3";

        public CoinGeckoPriceHistoryApi(HttpClient httpClient)
        {
            _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
        }

        /// <summary>
        /// Fetches historical price data from CoinGecko for a given symbol and date range.
        /// </summary>
        /// <param name="symbolPair">The trading pair symbol, e.g., "bitcoin/usd".</param>
        /// <param name="startDate">The start date for fetching data.</param>
        /// <param name="endDate">The end date for fetching data.</param>
        /// <returns>A <see cref="Result{T}"/> containing a list of <see cref="CryptoPriceRecord"/> or an error message.</returns>
        public async Task<Result<IEnumerable<CryptoPriceRecord>>> FetchPriceHistoryAsync(string symbolPair, DateTime startDate, DateTime endDate)
        {
            try
            {
                Log.Information("Fetching data from CoinGecko for {SymbolPair} from {StartDate:yyyy-MM-dd} to {EndDate:yyyy-MM-dd}.", symbolPair, startDate, endDate);

                var coinId = GetCoinGeckoId(symbolPair.Split('/')[0]);
                if (string.IsNullOrEmpty(coinId))
                {
                    return Result.Failure<IEnumerable<CryptoPriceRecord>>($"CoinGecko ID not found for symbol: {symbolPair}");
                }

                var priceData = new List<CryptoPriceRecord>();

                for (var date = startDate.Date; date <= endDate.Date; date = date.AddDays(1))
                {
                    var timestamp = ((DateTimeOffset)date).ToUnixTimeSeconds();
                    var url = $"{BaseUrl}/coins/{coinId}/history?date={date:dd-MM-yyyy}";
                    var response = await _httpClient.GetAsync(url);
                    if (!response.IsSuccessStatusCode)
                    {
                        Log.Warning("Failed to fetch data from CoinGecko for {SymbolPair} on {Date:yyyy-MM-dd}. Status Code: {StatusCode}.", symbolPair, date, response.StatusCode);
                        continue;
                    }

                    var content = await response.Content.ReadAsStringAsync();
                    var jsonData = Newtonsoft.Json.Linq.JObject.Parse(content);
                    var price = jsonData["market_data"]?["current_price"]?[symbolPair.Split('/')[1].ToLower()]?.ToObject<decimal?>();

                    if (price.HasValue)
                    {
                        priceData.Add(new CryptoPriceRecord
                        {
                            CurrencyPair = symbolPair,
                            CloseDate = date,
                            ClosePrice = price.Value
                        });
                    }
                    else
                    {
                        Log.Warning("Price data not available for {SymbolPair} on {Date:yyyy-MM-dd}.", symbolPair, date);
                    }
                }

                if (priceData.Any())
                {
                    Log.Information("Successfully retrieved price data from CoinGecko for {SymbolPair}.", symbolPair);
                    return Result.Success<IEnumerable<CryptoPriceRecord>>(priceData);
                }
                else
                {
                    return Result.Failure<IEnumerable<CryptoPriceRecord>>("No price data retrieved from CoinGecko.");
                }
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Error occurred while fetching data from CoinGecko for {SymbolPair}.", symbolPair);
                return Result.Failure<IEnumerable<CryptoPriceRecord>>("An error occurred while fetching data from CoinGecko.");
            }
        }

        /// <summary>
        /// Determines the appropriate CoinGecko ID based on the cryptocurrency symbol.
        /// </summary>
        /// <param name="symbol">The cryptocurrency symbol (e.g., "bitcoin").</param>
        /// <returns>The corresponding CoinGecko ID (e.g., "bitcoin").</returns>
        private string GetCoinGeckoId(string symbol)
        {
            // In a production scenario, you'd typically map these from a more extensive and dynamic source.
            return symbol.ToLower() switch
            {
                "btc" => "bitcoin",
                "eth" => "ethereum",
                "xrp" => "ripple",
                "ltc" => "litecoin",
                "ada" => "cardano",
                // Add more mappings as needed
                _ => string.Empty
            };
        }

        /// <summary>
        /// Determines the appropriate trading pair symbol for CoinGecko.
        /// </summary>
        /// <param name="fromSymbol">The base currency or coin symbol.</param>
        /// <param name="toSymbol">The quote currency or coin symbol.</param>
        /// <returns>The trading pair symbol in the format "base/quote" (e.g., "bitcoin/usd").</returns>
        public string DetermineTradingPair(string fromSymbol, string toSymbol)
        {
            return $"{fromSymbol.ToLower()}/{toSymbol.ToLower()}";
        }
    }
}
using CSharpFunctionalExtensions;

namespace Portfolio.App.HistoricalPrice;

public interface IPriceHistoryService
{
    public string DefaultCurrency { get; set; }
    Task<Result<decimal>> GetPriceAtCloseTimeAsync(string symbol, DateTime date);
}
using CSharpFunctionalExtensions;

namespace Portfolio.App.HistoricalPrice;

public interface IPriceHistoryStorageService
{
    Task<Result<IEnumerable<CryptoPriceRecord>>> LoadHistoryAsync(string symbol);
    Task<Result> SaveHistoryAsync(string symbol, IEnumerable<CryptoPriceRecord> priceHistory);
}
using System.Collections.Concurrent;

namespace Portfolio.App;

public static class ConcurrentDictionaryExtensions
{
    public static async Task<TValue> GetOrAddAsync<TKey, TValue>(
        this ConcurrentDictionary<TKey, TValue> dictionary,
        TKey key,
        Func<TKey, Task<TValue>> valueFactory)
    {
        if (dictionary.TryGetValue(key, out var existingValue))
        {
            return existingValue;
        }

        var newValue = await valueFactory(key);

        // TryAdd will return false if another thread added the key before us
        return dictionary.GetOrAdd(key, newValue);
    }

    public static async Task<bool> TryAddAsync<TKey, TValue>(
    this ConcurrentDictionary<TKey, TValue> dictionary,
    TKey key,
    Func<TKey, Task<TValue>> valueFactory)
    {
        if (dictionary.ContainsKey(key))
        {
            return false; // The key already exists, so we don't add a new value.
        }

        var newValue = await valueFactory(key);

        return dictionary.TryAdd(key, newValue);
    }
}using Newtonsoft.Json.Linq;

namespace Portfolio.App;

public class CurrencyExchangeService
{
    private readonly string _apiKey;
    private readonly HttpClient _httpClient;
    private const string BaseUrl = "https://api.exchangeratesapi.io";

    public CurrencyExchangeService(string apiKey)
    {
        _apiKey = apiKey ?? throw new ArgumentNullException(nameof(apiKey));
        _httpClient = new HttpClient();
    }

    public async Task<decimal> GetExchangeRateAsync(string fromCurrency, string toCurrency, DateTime date)
    {
        if (string.IsNullOrWhiteSpace(fromCurrency)) 
            throw new ArgumentException("From currency code cannot be null or empty.", nameof(fromCurrency));
        if (string.IsNullOrWhiteSpace(toCurrency)) 
            throw new ArgumentException("To currency code cannot be null or empty.", nameof(toCurrency));

        string formattedDate = date.ToString("yyyy-MM-dd");
        string url = $"{BaseUrl}/{formattedDate}?access_key={_apiKey}&base={fromCurrency}&symbols={toCurrency}";

        HttpResponseMessage response = await _httpClient.GetAsync(url);
        if (response.IsSuccessStatusCode)
        {
            string responseBody = await response.Content.ReadAsStringAsync();
            JObject json = JObject.Parse(responseBody);
            decimal exchangeRate = json["rates"][toCurrency].Value<decimal>();
            return exchangeRate;
        }
        else
        {
            throw new Exception($"Error fetching exchange rate: {response.ReasonPhrase}");
        }
    }
}
namespace Portfolio.App;

public interface ICurrencyExchangeService
{
    Task<decimal> GetExchangeRateAsync(string fromCurrency, string toCurrency, DateTime date);
}
using CSharpFunctionalExtensions;
using Portfolio.App.HistoricalPrice;
using Portfolio.Shared;
using Serilog;

namespace Portfolio.App;

public delegate void DepositAddedHandler(CryptoCurrencyDepositTransaction deposit, CryptoCurrencyHolding holding);
public delegate void WithdrawAddedHandler(CryptoCurrencyWithdrawTransaction deposit, CryptoCurrencyHolding holding);
public delegate void TradeAddedHandler(CryptoCurrencyTradeTransaction deposit, CryptoCurrencyHolding holding);

public class Portfolio
{
    private readonly IPriceHistoryService _priceHistoryService = null!;
    private List<CryptoCurrencyHolding> _holdings = new();

    public event DepositAddedHandler? OnDepositAdded;
    public event WithdrawAddedHandler? OnWithdrawAdded;
    public event TradeAddedHandler? OnTradeAdded;

    List<ICryptoCurrencyTransaction> _taxableEvents = new();

    public string DefaultCurrency { get; private set; } = Strings.CURRENCY_USD;
    public IReadOnlyCollection<Wallet> Wallets { get; private set; } = new List<Wallet>();
    public IReadOnlyCollection<CryptoCurrencyHolding> Holdings { get => _holdings; }

    public Portfolio(IPriceHistoryService priceHistoryService)
    {
        _priceHistoryService = priceHistoryService;
    }

    public Result SetDefaultCurrency(string currencyCode)
    {
        currencyCode = currencyCode.ToUpper();
        if (!FiatCurrencies.Codes.Contains(currencyCode))
            return Result.Failure("Currency code unknown.");

        DefaultCurrency = currencyCode;
        _priceHistoryService.DefaultCurrency = currencyCode;

        return Result.Success();
    }

    public Result AddWallet(Wallet wallet)
    {
        if (Wallets.Any(w => w.Name == wallet.Name))
            return Result.Failure("Wallet already exists.");

        var wallets = Wallets.ToList();
        wallets.Add(wallet);
        Wallets = wallets.AsReadOnly();

        return Result.Success();
    }

    public async Task<Result> Process()
    {
        if (!Wallets.Any())
            return Result.Failure("No wallets to process. Start by adding a wallet.");
        
        var transactions = GetTransactionsFromAllWallets();
        _holdings = (await GetHoldings(transactions)).ToList();

        return Result.Success();
    }
    private IEnumerable<ICryptoCurrencyTransaction> GetTransactionsFromAllWallets()
    {
        List<ICryptoCurrencyTransaction> allTransactions = [.. Wallets.SelectMany(w => w.Transactions)];
        return allTransactions.OrderBy(t => t.DateTime).ToList();
    }

    internal async Task<IEnumerable<CryptoCurrencyHolding>> GetHoldings(IEnumerable<ICryptoCurrencyTransaction> transactions)
    {
        foreach (var tx in transactions)
        {
            CryptoCurrencyHolding? sender = null;
            CryptoCurrencyHolding? receiver = null;

            if (tx is CryptoCurrencyDepositTransaction deposit)
            {
                receiver = GetOrCreateHolding(deposit.Amount.CurrencyCode);
                var addTxResult = receiver.AddTransaction(deposit);
                if (addTxResult.IsFailure)
                    throw new Exception(addTxResult.Error);

                if (deposit.Amount.CurrencyCode == DefaultCurrency)
                    receiver.AverageBoughtPrice = 1;
                else
                {
                    var priceResult = await _priceHistoryService.GetPriceAtCloseTimeAsync(deposit.Amount.CurrencyCode, deposit.DateTime);
                    if (priceResult.IsFailure)
                    {
                        Log.Error($"Failed to retrieve price history for asset {receiver.Asset} on {deposit.DateTime:yyyy-MM-dd}. Error: {priceResult.Error}");
                        continue;
                    }

                    deposit.UnitValue = new Money(priceResult.Value, DefaultCurrency);

                    decimal newAverage = ((receiver.AverageBoughtPrice * (receiver.Balance - deposit.Amount.Amount)) + (deposit.Amount.Amount * priceResult.Value)) / (receiver.Balance);
                    receiver.AverageBoughtPrice = newAverage;
                }

                //Log.Debug($"Deposit [{string.Join("|", tx.TransactionIds)}: {receiver.Asset}: {receiver.Balance}");

                OnDepositAdded?.Invoke(deposit, receiver);
            }

            if (tx is CryptoCurrencyWithdrawTransaction withdraw)
            {
                sender = GetOrCreateHolding(withdraw.Amount.CurrencyCode);
                var addTxResult = sender.AddTransaction(withdraw);
                if (addTxResult.IsFailure)
                    throw new Exception(addTxResult.Error);

                _taxableEvents.Add(tx);

                if (sender.Balance < 0)
                {
                    Log.Warning($"{sender.Asset} Balance is under zero: {sender.Balance}");
                }

                OnWithdrawAdded?.Invoke(withdraw, sender);

                //Log.Debug($"Withdraw [{string.Join("|", tx.TransactionIds)}: {sender.Asset}: {sender.Balance}");
            }

            if (tx is CryptoCurrencyTradeTransaction trade)
            {

                // TODO: Ensure to log whenever a trade amount comes from a currency not 
                // owned in holdings. It would means the user spends money he doesn't have deposited or traded before.

                receiver = GetOrCreateHolding(trade.Amount.CurrencyCode);
                sender = GetOrCreateHolding(trade.TradeAmount.CurrencyCode);

                if (trade.Amount.CurrencyCode == DefaultCurrency)
                    receiver.AverageBoughtPrice = 1;
                else //if(!deposit.Amount.IsFiatCurrency)
                {
                    decimal tradedCost = trade.TradeAmount.Amount * sender.AverageBoughtPrice; // 0.04 * 25000 = 1000
                    decimal boughtPrice = tradedCost / trade.Amount.Amount;

                    //var priceValue = await _priceHistoryStores[trade.Amount.CurrencyCode].GetPriceDataAsync(trade.DateTime);
                    //trade.UnitValue = new Money(priceValue.Close, DefaultCurrency);

                    decimal newAverage = ((receiver.AverageBoughtPrice * receiver.Balance) + (trade.Amount.Amount * boughtPrice)) / (receiver.Balance + trade.Amount.Amount);
                    receiver.AverageBoughtPrice = newAverage;
                }
                var addTxResult = receiver.AddTransaction(trade);
                if (addTxResult.IsFailure)
                    throw new Exception(addTxResult.Error);
                OnTradeAdded?.Invoke(trade, receiver);

                var addTxResult2 = sender.AddTransaction(trade);
                if (addTxResult2.IsFailure)
                    throw new Exception(addTxResult2.Error);
                OnTradeAdded?.Invoke(trade, sender);

                if (sender.Balance < 0)
                {
                    Log.Error($"{sender.Asset} Balance is under zero: {sender.Balance}");
                }

                // Log.Debug($"Trade Out [{string.Join("|", trade.TransactionIds)}: {sender.Asset}: {sender.Balance}");
                // Log.Debug($"Trade In [{string.Join("|", trade.TransactionIds)}: {receiver.Asset}: {receiver.Balance}");
            }
        }

        // Fetch latest prices...
        foreach (var holding in _holdings)
        {
            if (holding.Asset == DefaultCurrency)
                holding.CurrentPrice = new Money(1m, holding.Asset);
            else
            {
                var priceValueResult = await _priceHistoryService.GetPriceAtCloseTimeAsync(holding.Asset, DateTime.Now);            
                if (priceValueResult.IsFailure)
                {
                    Log.Error(priceValueResult.Error);
                    holding.CurrentPrice = new Money(0m, holding.Asset);
                    continue;
                }
                holding.CurrentPrice = new Money(priceValueResult.Value, holding.Asset);
            }
        }

        return _holdings;
    }

    public void CheckForMissingTransactions()
    {
        foreach (var holding in _holdings)
        {
            if (FiatCurrencies.Codes.Contains(holding.Asset))
                continue;

            decimal expectedTotal = 0;

            if (holding.Asset == "LINK")
                ;
            // Total number of IN transactions should equal to the balance.
            foreach (var tx in holding.Transactions)
            {
                if (tx is CryptoCurrencyDepositTransaction deposit)
                {
                    expectedTotal += deposit.Amount.Amount; //48,219
                }
                else if (tx is CryptoCurrencyWithdrawTransaction withdraw)
                {
                    expectedTotal -= withdraw.Amount.Amount;//15 36
                    expectedTotal -= withdraw.FeeAmount.Amount;
                }
                else if (tx is CryptoCurrencyTradeTransaction trade)
                {
                    if (trade.Amount.CurrencyCode == holding.Asset)
                        expectedTotal += trade.Amount.Amount;
                    else if (trade.TradeAmount.CurrencyCode == holding.Asset)
                    {
                        expectedTotal -= trade.TradeAmount.Amount;
                        if (trade.TradeAmount.CurrencyCode == trade.FeeAmount.CurrencyCode)
                            expectedTotal -= trade.FeeAmount.Amount;
                    }
                }
            }

            if (expectedTotal != holding.Balance)
                Log.Warning($"Missing transactions for holding {holding.Asset}");
        }

    }

    internal CryptoCurrencyHolding GetOrCreateHolding(string currencyCode)
    {
        var holding = _holdings.SingleOrDefault(h => h.Asset == currencyCode);
        if (holding == null)
        {
            holding = new CryptoCurrencyHolding(currencyCode);
            _holdings.Add(holding);
        }
        return holding;
    }
}namespace Portfolio.App;

public class Strings
{
    public const string DATE_FORMAT = "yyyy-MM-dd";
    public const string CURRENCY_USD = "USD";
}

public class Errors
{
    public const string ERR_SAME_SYMBOLS = "Symbols must be of different currency/coin ({0}-{1}).";
    public const string ERR_YAHOO_API_FETCH_FAILURE = "An error occurred while fetching from Yahoo Finance API.";
}using CSharpFunctionalExtensions;
using Portfolio.Shared;

namespace Portfolio.App;

public class Wallet
{
    public string Name { get; set; } = string.Empty;
    public IEnumerable<ICryptoCurrencyTransaction> Transactions { get; set; } = null!;

    private Wallet() {}

    public static Result<Wallet> Create(string walletName, IEnumerable<ICryptoCurrencyTransaction> transactions)
    {
        if(string.IsNullOrWhiteSpace(walletName)) return Result.Failure<Wallet>("Name cannot be empty.");
        
        return new Wallet 
        {
            Name = walletName,
            Transactions = transactions ?? new List<ICryptoCurrencyTransaction>()
        };
    }
}
namespace Portfolio.App;

public class MockCurrencyExchangeService : ICurrencyExchangeService
{
    public Task<decimal> GetExchangeRateAsync(string fromCurrency, string toCurrency, DateTime date)
    {
        // Return a mock exchange rate
        return Task.FromResult(1.4m);
    }
}
ï»¿using Serilog;
using Serilog.Events;
using Serilog.Formatting.Json;
using Portfolio.Kraken;
using Portfolio.Shared;
using Portfolio.App.HistoricalPrice;
using Portfolio.App.HistoricalPrice.YahooFinance;

namespace Portfolio.App;

internal class Program
{
    private static async Task Main(string[] args)
    {
        Log.Logger = new LoggerConfiguration()
            // add console as logging target
            .WriteTo.Console()
            // add a logging target for warnings and higher severity  logs
            // structured in JSON format
            .WriteTo.File(new JsonFormatter(), "important.json", restrictedToMinimumLevel: LogEventLevel.Warning)
            // add a rolling file for all logs
            .WriteTo.File("all-.logs", rollingInterval: RollingInterval.Day)
            // set default minimum level
            .MinimumLevel.Debug()
            .CreateLogger();

        var processor = new KrakenCsvParser(filename: "sample.csv");
        var transactions = processor.ExtractTransactions();

        var krakenWalletResult = Wallet.Create("kraken", transactions);
        if (krakenWalletResult.IsFailure)
            throw new Exception(krakenWalletResult.Error);

        //var storage = new FilePriceHistoryStorageService();

        var storage = new SQLitePriceHistoryStorageService("path_to_your_database_file.db");


        var api = new YahooFinancePriceHistoryApi();
        var svc = new PriceHistoryService(api, storage, "USD");
        var portfolio = new Portfolio(svc);
        portfolio.OnDepositAdded += CheckBalance;
        portfolio.OnWithdrawAdded += CheckBalance;
        portfolio.OnTradeAdded += CheckBalance;

        var addWalletResult = portfolio.AddWallet(krakenWalletResult.Value);
        if (addWalletResult.IsFailure)
            throw new Exception(addWalletResult.Error);

        var processResult = await portfolio.Process();
        if (processResult.IsFailure)
            throw new Exception(processResult.Error);

        portfolio.CheckForMissingTransactions();

        foreach (var h in portfolio.Holdings.Where(h => h.Balance > 0))
        {
            Log.Information($"Currency:{h.Asset}    Balance:{h.Balance:F2}     AvgPrice:{h.AverageBoughtPrice:F2}     Cost:{(h.Balance * h.AverageBoughtPrice):F2}     Value:{(h.Balance * h.CurrentPrice?.Amount):F2}");
        }
    }

    private static void CheckBalance(CryptoCurrencyDepositTransaction transaction, CryptoCurrencyHolding holding)
    {
        var lines = transaction.State as KrakenCsvEntry[];
        var line = lines.First();

        if (line.Balance.AbsoluteAmount != holding.Balance)
            Log.Error($"{transaction.Amount.CurrencyCode} balances do not match. Deposit RefId={transaction.TransactionIds}");
    }

    private static void CheckBalance(CryptoCurrencyWithdrawTransaction transaction, CryptoCurrencyHolding holding)
    {
        var lines = transaction.State as KrakenCsvEntry[];
        var line = lines.First();

        if (line.Balance.AbsoluteAmount != holding.Balance)
            Log.Error($"{transaction.Amount.CurrencyCode} balances do not match. Withdraw RefId={transaction.TransactionIds}");
    }

    private static void CheckBalance(CryptoCurrencyTradeTransaction transaction, CryptoCurrencyHolding holding)
    {
        var lines = transaction.State as KrakenCsvEntry[];
        var receiveTx = lines.First();
        var spendTx = lines.ElementAtOrDefault(1);

        if (transaction.Amount.CurrencyCode == holding.Asset)
        {
            if (receiveTx.Balance.AbsoluteAmount != holding.Balance)
                Log.Error($"{transaction.Amount.CurrencyCode} balances do not match. Withdraw RefId={transaction.TransactionIds}");
        }
        else if (transaction.TradeAmount.CurrencyCode == holding.Asset)
        {
            if (spendTx.Balance.AbsoluteAmount != holding.Balance)
                Log.Error($"{transaction.Amount.CurrencyCode} balances do not match. Withdraw RefId={transaction.TransactionIds}");
        }
    }
}