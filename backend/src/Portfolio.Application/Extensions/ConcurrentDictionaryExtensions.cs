using System.Collections.Concurrent;

namespace Portfolio.App
{
    /// <summary>
    /// Provides extension methods for <see cref="ConcurrentDictionary{TKey, TValue}"/> to support asynchronous operations.
    /// </summary>
    public static class ConcurrentDictionaryExtensions
    {
        /// <summary>
        /// Asynchronously gets the value associated with the specified key, or adds a new value generated by the provided function.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the dictionary.</typeparam>
        /// <typeparam name="TValue">The type of the value in the dictionary.</typeparam>
        /// <param name="dictionary">The <see cref="ConcurrentDictionary{TKey, TValue}"/> to operate on.</param>
        /// <param name="key">The key of the value to get or add.</param>
        /// <param name="valueFactory">The function to generate a new value if the key does not exist.</param>
        /// <returns>A task representing the asynchronous operation, with the value associated with the specified key.</returns>
        public static async Task<TValue> GetOrAddAsync<TKey, TValue>(
            this ConcurrentDictionary<TKey, Lazy<Task<TValue>>> dictionary,
            TKey key,
            Func<TKey, Task<TValue>> valueFactory) where TKey : notnull
        {
            var lazyValue = dictionary.GetOrAdd(key, k => new Lazy<Task<TValue>>(() => valueFactory(k)));

            try
            {
                return await lazyValue.Value.ConfigureAwait(false);
            }
            catch
            {
                // If the valueFactory throws an exception, remove the key to avoid leaving an invalid entry in the dictionary.
                dictionary.TryRemove(key, out _);
                throw;
            }
        }

        /// <summary>
        /// Asynchronously attempts to add a key-value pair to the dictionary, using the provided function to generate the value if the key does not exist.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the dictionary.</typeparam>
        /// <typeparam name="TValue">The type of the value in the dictionary.</typeparam>
        /// <param name="dictionary">The <see cref="ConcurrentDictionary{TKey, TValue}"/> to operate on.</param>
        /// <param name="key">The key of the value to add.</param>
        /// <param name="valueFactory">The function to generate a new value if the key does not exist.</param>
        /// <returns>A task representing the asynchronous operation, with a boolean indicating whether the key-value pair was added.</returns>
        public static async Task<bool> TryAddAsync<TKey, TValue>(
            this ConcurrentDictionary<TKey, Lazy<Task<TValue>>> dictionary,
            TKey key,
            Func<TKey, Task<TValue>> valueFactory) where TKey : notnull
        {
            var lazyValue = new Lazy<Task<TValue>>(() => valueFactory(key));

            if (dictionary.TryAdd(key, lazyValue))
            {
                try
                {
                    await lazyValue.Value.ConfigureAwait(false);
                    return true;
                }
                catch
                {
                    // If the valueFactory throws an exception, remove the key to avoid leaving an invalid entry in the dictionary.
                    dictionary.TryRemove(key, out _);
                    throw;
                }
            }

            return false; // The key already exists, so we don't add a new value.
        }

        /// <summary>
        /// Asynchronously adds or updates a key-value pair in the dictionary. If the key already exists, the existing value is updated using the provided function.
        /// </summary>
        /// <typeparam name="TKey">The type of the key in the dictionary.</typeparam>
        /// <typeparam name="TValue">The type of the value in the dictionary.</typeparam>
        /// <param name="dictionary">The <see cref="ConcurrentDictionary{TKey, TValue}"/> to operate on.</param>
        /// <param name="key">The key of the value to add or update.</param>
        /// <param name="addValueFactory">The function to generate a new value if the key does not exist.</param>
        /// <param name="updateValueFactory">The function to generate an updated value if the key already exists.</param>
        /// <returns>A task representing the asynchronous operation, with the updated value associated with the specified key.</returns>
        public static async Task<TValue> AddOrUpdateAsync<TKey, TValue>(
            this ConcurrentDictionary<TKey, Lazy<Task<TValue>>> dictionary,
            TKey key,
            Func<TKey, Task<TValue>> addValueFactory,
            Func<TKey, TValue, Task<TValue>> updateValueFactory) where TKey : notnull
        {
            var lazyValue = new Lazy<Task<TValue>>(() => addValueFactory(key));

            var result = dictionary.AddOrUpdate(
                key,
                lazyValue,
                (k, existingLazyValue) => new Lazy<Task<TValue>>(async () =>
                {
                    var existingValue = await existingLazyValue.Value.ConfigureAwait(false);
                    return await updateValueFactory(k, existingValue).ConfigureAwait(false);
                }));

            try
            {
                return await result.Value.ConfigureAwait(false);
            }
            catch
            {
                dictionary.TryRemove(key, out _);
                throw;
            }
        }
    }
}
